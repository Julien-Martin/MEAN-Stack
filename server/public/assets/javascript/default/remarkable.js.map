{"version":3,"names":[],"mappings":"","sources":["default/remarkable.js"],"sourcesContent":["/*! remarkable 1.6.0 https://github.com/jonschlinkert/remarkable @license MIT */(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Remarkable = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// List of valid entities\n//\n// Generate with ./support/entities.js script\n//\n    'use strict';\n\n    /*eslint quotes:0*/\n    module.exports = {\n        \"Aacute\":\"\\u00C1\",\n        \"aacute\":\"\\u00E1\",\n        \"Abreve\":\"\\u0102\",\n        \"abreve\":\"\\u0103\",\n        \"ac\":\"\\u223E\",\n        \"acd\":\"\\u223F\",\n        \"acE\":\"\\u223E\\u0333\",\n        \"Acirc\":\"\\u00C2\",\n        \"acirc\":\"\\u00E2\",\n        \"acute\":\"\\u00B4\",\n        \"Acy\":\"\\u0410\",\n        \"acy\":\"\\u0430\",\n        \"AElig\":\"\\u00C6\",\n        \"aelig\":\"\\u00E6\",\n        \"af\":\"\\u2061\",\n        \"Afr\":\"\\uD835\\uDD04\",\n        \"afr\":\"\\uD835\\uDD1E\",\n        \"Agrave\":\"\\u00C0\",\n        \"agrave\":\"\\u00E0\",\n        \"alefsym\":\"\\u2135\",\n        \"aleph\":\"\\u2135\",\n        \"Alpha\":\"\\u0391\",\n        \"alpha\":\"\\u03B1\",\n        \"Amacr\":\"\\u0100\",\n        \"amacr\":\"\\u0101\",\n        \"amalg\":\"\\u2A3F\",\n        \"AMP\":\"\\u0026\",\n        \"amp\":\"\\u0026\",\n        \"And\":\"\\u2A53\",\n        \"and\":\"\\u2227\",\n        \"andand\":\"\\u2A55\",\n        \"andd\":\"\\u2A5C\",\n        \"andslope\":\"\\u2A58\",\n        \"andv\":\"\\u2A5A\",\n        \"ang\":\"\\u2220\",\n        \"ange\":\"\\u29A4\",\n        \"angle\":\"\\u2220\",\n        \"angmsd\":\"\\u2221\",\n        \"angmsdaa\":\"\\u29A8\",\n        \"angmsdab\":\"\\u29A9\",\n        \"angmsdac\":\"\\u29AA\",\n        \"angmsdad\":\"\\u29AB\",\n        \"angmsdae\":\"\\u29AC\",\n        \"angmsdaf\":\"\\u29AD\",\n        \"angmsdag\":\"\\u29AE\",\n        \"angmsdah\":\"\\u29AF\",\n        \"angrt\":\"\\u221F\",\n        \"angrtvb\":\"\\u22BE\",\n        \"angrtvbd\":\"\\u299D\",\n        \"angsph\":\"\\u2222\",\n        \"angst\":\"\\u00C5\",\n        \"angzarr\":\"\\u237C\",\n        \"Aogon\":\"\\u0104\",\n        \"aogon\":\"\\u0105\",\n        \"Aopf\":\"\\uD835\\uDD38\",\n        \"aopf\":\"\\uD835\\uDD52\",\n        \"ap\":\"\\u2248\",\n        \"apacir\":\"\\u2A6F\",\n        \"apE\":\"\\u2A70\",\n        \"ape\":\"\\u224A\",\n        \"apid\":\"\\u224B\",\n        \"apos\":\"\\u0027\",\n        \"ApplyFunction\":\"\\u2061\",\n        \"approx\":\"\\u2248\",\n        \"approxeq\":\"\\u224A\",\n        \"Aring\":\"\\u00C5\",\n        \"aring\":\"\\u00E5\",\n        \"Ascr\":\"\\uD835\\uDC9C\",\n        \"ascr\":\"\\uD835\\uDCB6\",\n        \"Assign\":\"\\u2254\",\n        \"ast\":\"\\u002A\",\n        \"asymp\":\"\\u2248\",\n        \"asympeq\":\"\\u224D\",\n        \"Atilde\":\"\\u00C3\",\n        \"atilde\":\"\\u00E3\",\n        \"Auml\":\"\\u00C4\",\n        \"auml\":\"\\u00E4\",\n        \"awconint\":\"\\u2233\",\n        \"awint\":\"\\u2A11\",\n        \"backcong\":\"\\u224C\",\n        \"backepsilon\":\"\\u03F6\",\n        \"backprime\":\"\\u2035\",\n        \"backsim\":\"\\u223D\",\n        \"backsimeq\":\"\\u22CD\",\n        \"Backslash\":\"\\u2216\",\n        \"Barv\":\"\\u2AE7\",\n        \"barvee\":\"\\u22BD\",\n        \"Barwed\":\"\\u2306\",\n        \"barwed\":\"\\u2305\",\n        \"barwedge\":\"\\u2305\",\n        \"bbrk\":\"\\u23B5\",\n        \"bbrktbrk\":\"\\u23B6\",\n        \"bcong\":\"\\u224C\",\n        \"Bcy\":\"\\u0411\",\n        \"bcy\":\"\\u0431\",\n        \"bdquo\":\"\\u201E\",\n        \"becaus\":\"\\u2235\",\n        \"Because\":\"\\u2235\",\n        \"because\":\"\\u2235\",\n        \"bemptyv\":\"\\u29B0\",\n        \"bepsi\":\"\\u03F6\",\n        \"bernou\":\"\\u212C\",\n        \"Bernoullis\":\"\\u212C\",\n        \"Beta\":\"\\u0392\",\n        \"beta\":\"\\u03B2\",\n        \"beth\":\"\\u2136\",\n        \"between\":\"\\u226C\",\n        \"Bfr\":\"\\uD835\\uDD05\",\n        \"bfr\":\"\\uD835\\uDD1F\",\n        \"bigcap\":\"\\u22C2\",\n        \"bigcirc\":\"\\u25EF\",\n        \"bigcup\":\"\\u22C3\",\n        \"bigodot\":\"\\u2A00\",\n        \"bigoplus\":\"\\u2A01\",\n        \"bigotimes\":\"\\u2A02\",\n        \"bigsqcup\":\"\\u2A06\",\n        \"bigstar\":\"\\u2605\",\n        \"bigtriangledown\":\"\\u25BD\",\n        \"bigtriangleup\":\"\\u25B3\",\n        \"biguplus\":\"\\u2A04\",\n        \"bigvee\":\"\\u22C1\",\n        \"bigwedge\":\"\\u22C0\",\n        \"bkarow\":\"\\u290D\",\n        \"blacklozenge\":\"\\u29EB\",\n        \"blacksquare\":\"\\u25AA\",\n        \"blacktriangle\":\"\\u25B4\",\n        \"blacktriangledown\":\"\\u25BE\",\n        \"blacktriangleleft\":\"\\u25C2\",\n        \"blacktriangleright\":\"\\u25B8\",\n        \"blank\":\"\\u2423\",\n        \"blk12\":\"\\u2592\",\n        \"blk14\":\"\\u2591\",\n        \"blk34\":\"\\u2593\",\n        \"block\":\"\\u2588\",\n        \"bne\":\"\\u003D\\u20E5\",\n        \"bnequiv\":\"\\u2261\\u20E5\",\n        \"bNot\":\"\\u2AED\",\n        \"bnot\":\"\\u2310\",\n        \"Bopf\":\"\\uD835\\uDD39\",\n        \"bopf\":\"\\uD835\\uDD53\",\n        \"bot\":\"\\u22A5\",\n        \"bottom\":\"\\u22A5\",\n        \"bowtie\":\"\\u22C8\",\n        \"boxbox\":\"\\u29C9\",\n        \"boxDL\":\"\\u2557\",\n        \"boxDl\":\"\\u2556\",\n        \"boxdL\":\"\\u2555\",\n        \"boxdl\":\"\\u2510\",\n        \"boxDR\":\"\\u2554\",\n        \"boxDr\":\"\\u2553\",\n        \"boxdR\":\"\\u2552\",\n        \"boxdr\":\"\\u250C\",\n        \"boxH\":\"\\u2550\",\n        \"boxh\":\"\\u2500\",\n        \"boxHD\":\"\\u2566\",\n        \"boxHd\":\"\\u2564\",\n        \"boxhD\":\"\\u2565\",\n        \"boxhd\":\"\\u252C\",\n        \"boxHU\":\"\\u2569\",\n        \"boxHu\":\"\\u2567\",\n        \"boxhU\":\"\\u2568\",\n        \"boxhu\":\"\\u2534\",\n        \"boxminus\":\"\\u229F\",\n        \"boxplus\":\"\\u229E\",\n        \"boxtimes\":\"\\u22A0\",\n        \"boxUL\":\"\\u255D\",\n        \"boxUl\":\"\\u255C\",\n        \"boxuL\":\"\\u255B\",\n        \"boxul\":\"\\u2518\",\n        \"boxUR\":\"\\u255A\",\n        \"boxUr\":\"\\u2559\",\n        \"boxuR\":\"\\u2558\",\n        \"boxur\":\"\\u2514\",\n        \"boxV\":\"\\u2551\",\n        \"boxv\":\"\\u2502\",\n        \"boxVH\":\"\\u256C\",\n        \"boxVh\":\"\\u256B\",\n        \"boxvH\":\"\\u256A\",\n        \"boxvh\":\"\\u253C\",\n        \"boxVL\":\"\\u2563\",\n        \"boxVl\":\"\\u2562\",\n        \"boxvL\":\"\\u2561\",\n        \"boxvl\":\"\\u2524\",\n        \"boxVR\":\"\\u2560\",\n        \"boxVr\":\"\\u255F\",\n        \"boxvR\":\"\\u255E\",\n        \"boxvr\":\"\\u251C\",\n        \"bprime\":\"\\u2035\",\n        \"Breve\":\"\\u02D8\",\n        \"breve\":\"\\u02D8\",\n        \"brvbar\":\"\\u00A6\",\n        \"Bscr\":\"\\u212C\",\n        \"bscr\":\"\\uD835\\uDCB7\",\n        \"bsemi\":\"\\u204F\",\n        \"bsim\":\"\\u223D\",\n        \"bsime\":\"\\u22CD\",\n        \"bsol\":\"\\u005C\",\n        \"bsolb\":\"\\u29C5\",\n        \"bsolhsub\":\"\\u27C8\",\n        \"bull\":\"\\u2022\",\n        \"bullet\":\"\\u2022\",\n        \"bump\":\"\\u224E\",\n        \"bumpE\":\"\\u2AAE\",\n        \"bumpe\":\"\\u224F\",\n        \"Bumpeq\":\"\\u224E\",\n        \"bumpeq\":\"\\u224F\",\n        \"Cacute\":\"\\u0106\",\n        \"cacute\":\"\\u0107\",\n        \"Cap\":\"\\u22D2\",\n        \"cap\":\"\\u2229\",\n        \"capand\":\"\\u2A44\",\n        \"capbrcup\":\"\\u2A49\",\n        \"capcap\":\"\\u2A4B\",\n        \"capcup\":\"\\u2A47\",\n        \"capdot\":\"\\u2A40\",\n        \"CapitalDifferentialD\":\"\\u2145\",\n        \"caps\":\"\\u2229\\uFE00\",\n        \"caret\":\"\\u2041\",\n        \"caron\":\"\\u02C7\",\n        \"Cayleys\":\"\\u212D\",\n        \"ccaps\":\"\\u2A4D\",\n        \"Ccaron\":\"\\u010C\",\n        \"ccaron\":\"\\u010D\",\n        \"Ccedil\":\"\\u00C7\",\n        \"ccedil\":\"\\u00E7\",\n        \"Ccirc\":\"\\u0108\",\n        \"ccirc\":\"\\u0109\",\n        \"Cconint\":\"\\u2230\",\n        \"ccups\":\"\\u2A4C\",\n        \"ccupssm\":\"\\u2A50\",\n        \"Cdot\":\"\\u010A\",\n        \"cdot\":\"\\u010B\",\n        \"cedil\":\"\\u00B8\",\n        \"Cedilla\":\"\\u00B8\",\n        \"cemptyv\":\"\\u29B2\",\n        \"cent\":\"\\u00A2\",\n        \"CenterDot\":\"\\u00B7\",\n        \"centerdot\":\"\\u00B7\",\n        \"Cfr\":\"\\u212D\",\n        \"cfr\":\"\\uD835\\uDD20\",\n        \"CHcy\":\"\\u0427\",\n        \"chcy\":\"\\u0447\",\n        \"check\":\"\\u2713\",\n        \"checkmark\":\"\\u2713\",\n        \"Chi\":\"\\u03A7\",\n        \"chi\":\"\\u03C7\",\n        \"cir\":\"\\u25CB\",\n        \"circ\":\"\\u02C6\",\n        \"circeq\":\"\\u2257\",\n        \"circlearrowleft\":\"\\u21BA\",\n        \"circlearrowright\":\"\\u21BB\",\n        \"circledast\":\"\\u229B\",\n        \"circledcirc\":\"\\u229A\",\n        \"circleddash\":\"\\u229D\",\n        \"CircleDot\":\"\\u2299\",\n        \"circledR\":\"\\u00AE\",\n        \"circledS\":\"\\u24C8\",\n        \"CircleMinus\":\"\\u2296\",\n        \"CirclePlus\":\"\\u2295\",\n        \"CircleTimes\":\"\\u2297\",\n        \"cirE\":\"\\u29C3\",\n        \"cire\":\"\\u2257\",\n        \"cirfnint\":\"\\u2A10\",\n        \"cirmid\":\"\\u2AEF\",\n        \"cirscir\":\"\\u29C2\",\n        \"ClockwiseContourIntegral\":\"\\u2232\",\n        \"CloseCurlyDoubleQuote\":\"\\u201D\",\n        \"CloseCurlyQuote\":\"\\u2019\",\n        \"clubs\":\"\\u2663\",\n        \"clubsuit\":\"\\u2663\",\n        \"Colon\":\"\\u2237\",\n        \"colon\":\"\\u003A\",\n        \"Colone\":\"\\u2A74\",\n        \"colone\":\"\\u2254\",\n        \"coloneq\":\"\\u2254\",\n        \"comma\":\"\\u002C\",\n        \"commat\":\"\\u0040\",\n        \"comp\":\"\\u2201\",\n        \"compfn\":\"\\u2218\",\n        \"complement\":\"\\u2201\",\n        \"complexes\":\"\\u2102\",\n        \"cong\":\"\\u2245\",\n        \"congdot\":\"\\u2A6D\",\n        \"Congruent\":\"\\u2261\",\n        \"Conint\":\"\\u222F\",\n        \"conint\":\"\\u222E\",\n        \"ContourIntegral\":\"\\u222E\",\n        \"Copf\":\"\\u2102\",\n        \"copf\":\"\\uD835\\uDD54\",\n        \"coprod\":\"\\u2210\",\n        \"Coproduct\":\"\\u2210\",\n        \"COPY\":\"\\u00A9\",\n        \"copy\":\"\\u00A9\",\n        \"copysr\":\"\\u2117\",\n        \"CounterClockwiseContourIntegral\":\"\\u2233\",\n        \"crarr\":\"\\u21B5\",\n        \"Cross\":\"\\u2A2F\",\n        \"cross\":\"\\u2717\",\n        \"Cscr\":\"\\uD835\\uDC9E\",\n        \"cscr\":\"\\uD835\\uDCB8\",\n        \"csub\":\"\\u2ACF\",\n        \"csube\":\"\\u2AD1\",\n        \"csup\":\"\\u2AD0\",\n        \"csupe\":\"\\u2AD2\",\n        \"ctdot\":\"\\u22EF\",\n        \"cudarrl\":\"\\u2938\",\n        \"cudarrr\":\"\\u2935\",\n        \"cuepr\":\"\\u22DE\",\n        \"cuesc\":\"\\u22DF\",\n        \"cularr\":\"\\u21B6\",\n        \"cularrp\":\"\\u293D\",\n        \"Cup\":\"\\u22D3\",\n        \"cup\":\"\\u222A\",\n        \"cupbrcap\":\"\\u2A48\",\n        \"CupCap\":\"\\u224D\",\n        \"cupcap\":\"\\u2A46\",\n        \"cupcup\":\"\\u2A4A\",\n        \"cupdot\":\"\\u228D\",\n        \"cupor\":\"\\u2A45\",\n        \"cups\":\"\\u222A\\uFE00\",\n        \"curarr\":\"\\u21B7\",\n        \"curarrm\":\"\\u293C\",\n        \"curlyeqprec\":\"\\u22DE\",\n        \"curlyeqsucc\":\"\\u22DF\",\n        \"curlyvee\":\"\\u22CE\",\n        \"curlywedge\":\"\\u22CF\",\n        \"curren\":\"\\u00A4\",\n        \"curvearrowleft\":\"\\u21B6\",\n        \"curvearrowright\":\"\\u21B7\",\n        \"cuvee\":\"\\u22CE\",\n        \"cuwed\":\"\\u22CF\",\n        \"cwconint\":\"\\u2232\",\n        \"cwint\":\"\\u2231\",\n        \"cylcty\":\"\\u232D\",\n        \"Dagger\":\"\\u2021\",\n        \"dagger\":\"\\u2020\",\n        \"daleth\":\"\\u2138\",\n        \"Darr\":\"\\u21A1\",\n        \"dArr\":\"\\u21D3\",\n        \"darr\":\"\\u2193\",\n        \"dash\":\"\\u2010\",\n        \"Dashv\":\"\\u2AE4\",\n        \"dashv\":\"\\u22A3\",\n        \"dbkarow\":\"\\u290F\",\n        \"dblac\":\"\\u02DD\",\n        \"Dcaron\":\"\\u010E\",\n        \"dcaron\":\"\\u010F\",\n        \"Dcy\":\"\\u0414\",\n        \"dcy\":\"\\u0434\",\n        \"DD\":\"\\u2145\",\n        \"dd\":\"\\u2146\",\n        \"ddagger\":\"\\u2021\",\n        \"ddarr\":\"\\u21CA\",\n        \"DDotrahd\":\"\\u2911\",\n        \"ddotseq\":\"\\u2A77\",\n        \"deg\":\"\\u00B0\",\n        \"Del\":\"\\u2207\",\n        \"Delta\":\"\\u0394\",\n        \"delta\":\"\\u03B4\",\n        \"demptyv\":\"\\u29B1\",\n        \"dfisht\":\"\\u297F\",\n        \"Dfr\":\"\\uD835\\uDD07\",\n        \"dfr\":\"\\uD835\\uDD21\",\n        \"dHar\":\"\\u2965\",\n        \"dharl\":\"\\u21C3\",\n        \"dharr\":\"\\u21C2\",\n        \"DiacriticalAcute\":\"\\u00B4\",\n        \"DiacriticalDot\":\"\\u02D9\",\n        \"DiacriticalDoubleAcute\":\"\\u02DD\",\n        \"DiacriticalGrave\":\"\\u0060\",\n        \"DiacriticalTilde\":\"\\u02DC\",\n        \"diam\":\"\\u22C4\",\n        \"Diamond\":\"\\u22C4\",\n        \"diamond\":\"\\u22C4\",\n        \"diamondsuit\":\"\\u2666\",\n        \"diams\":\"\\u2666\",\n        \"die\":\"\\u00A8\",\n        \"DifferentialD\":\"\\u2146\",\n        \"digamma\":\"\\u03DD\",\n        \"disin\":\"\\u22F2\",\n        \"div\":\"\\u00F7\",\n        \"divide\":\"\\u00F7\",\n        \"divideontimes\":\"\\u22C7\",\n        \"divonx\":\"\\u22C7\",\n        \"DJcy\":\"\\u0402\",\n        \"djcy\":\"\\u0452\",\n        \"dlcorn\":\"\\u231E\",\n        \"dlcrop\":\"\\u230D\",\n        \"dollar\":\"\\u0024\",\n        \"Dopf\":\"\\uD835\\uDD3B\",\n        \"dopf\":\"\\uD835\\uDD55\",\n        \"Dot\":\"\\u00A8\",\n        \"dot\":\"\\u02D9\",\n        \"DotDot\":\"\\u20DC\",\n        \"doteq\":\"\\u2250\",\n        \"doteqdot\":\"\\u2251\",\n        \"DotEqual\":\"\\u2250\",\n        \"dotminus\":\"\\u2238\",\n        \"dotplus\":\"\\u2214\",\n        \"dotsquare\":\"\\u22A1\",\n        \"doublebarwedge\":\"\\u2306\",\n        \"DoubleContourIntegral\":\"\\u222F\",\n        \"DoubleDot\":\"\\u00A8\",\n        \"DoubleDownArrow\":\"\\u21D3\",\n        \"DoubleLeftArrow\":\"\\u21D0\",\n        \"DoubleLeftRightArrow\":\"\\u21D4\",\n        \"DoubleLeftTee\":\"\\u2AE4\",\n        \"DoubleLongLeftArrow\":\"\\u27F8\",\n        \"DoubleLongLeftRightArrow\":\"\\u27FA\",\n        \"DoubleLongRightArrow\":\"\\u27F9\",\n        \"DoubleRightArrow\":\"\\u21D2\",\n        \"DoubleRightTee\":\"\\u22A8\",\n        \"DoubleUpArrow\":\"\\u21D1\",\n        \"DoubleUpDownArrow\":\"\\u21D5\",\n        \"DoubleVerticalBar\":\"\\u2225\",\n        \"DownArrow\":\"\\u2193\",\n        \"Downarrow\":\"\\u21D3\",\n        \"downarrow\":\"\\u2193\",\n        \"DownArrowBar\":\"\\u2913\",\n        \"DownArrowUpArrow\":\"\\u21F5\",\n        \"DownBreve\":\"\\u0311\",\n        \"downdownarrows\":\"\\u21CA\",\n        \"downharpoonleft\":\"\\u21C3\",\n        \"downharpoonright\":\"\\u21C2\",\n        \"DownLeftRightVector\":\"\\u2950\",\n        \"DownLeftTeeVector\":\"\\u295E\",\n        \"DownLeftVector\":\"\\u21BD\",\n        \"DownLeftVectorBar\":\"\\u2956\",\n        \"DownRightTeeVector\":\"\\u295F\",\n        \"DownRightVector\":\"\\u21C1\",\n        \"DownRightVectorBar\":\"\\u2957\",\n        \"DownTee\":\"\\u22A4\",\n        \"DownTeeArrow\":\"\\u21A7\",\n        \"drbkarow\":\"\\u2910\",\n        \"drcorn\":\"\\u231F\",\n        \"drcrop\":\"\\u230C\",\n        \"Dscr\":\"\\uD835\\uDC9F\",\n        \"dscr\":\"\\uD835\\uDCB9\",\n        \"DScy\":\"\\u0405\",\n        \"dscy\":\"\\u0455\",\n        \"dsol\":\"\\u29F6\",\n        \"Dstrok\":\"\\u0110\",\n        \"dstrok\":\"\\u0111\",\n        \"dtdot\":\"\\u22F1\",\n        \"dtri\":\"\\u25BF\",\n        \"dtrif\":\"\\u25BE\",\n        \"duarr\":\"\\u21F5\",\n        \"duhar\":\"\\u296F\",\n        \"dwangle\":\"\\u29A6\",\n        \"DZcy\":\"\\u040F\",\n        \"dzcy\":\"\\u045F\",\n        \"dzigrarr\":\"\\u27FF\",\n        \"Eacute\":\"\\u00C9\",\n        \"eacute\":\"\\u00E9\",\n        \"easter\":\"\\u2A6E\",\n        \"Ecaron\":\"\\u011A\",\n        \"ecaron\":\"\\u011B\",\n        \"ecir\":\"\\u2256\",\n        \"Ecirc\":\"\\u00CA\",\n        \"ecirc\":\"\\u00EA\",\n        \"ecolon\":\"\\u2255\",\n        \"Ecy\":\"\\u042D\",\n        \"ecy\":\"\\u044D\",\n        \"eDDot\":\"\\u2A77\",\n        \"Edot\":\"\\u0116\",\n        \"eDot\":\"\\u2251\",\n        \"edot\":\"\\u0117\",\n        \"ee\":\"\\u2147\",\n        \"efDot\":\"\\u2252\",\n        \"Efr\":\"\\uD835\\uDD08\",\n        \"efr\":\"\\uD835\\uDD22\",\n        \"eg\":\"\\u2A9A\",\n        \"Egrave\":\"\\u00C8\",\n        \"egrave\":\"\\u00E8\",\n        \"egs\":\"\\u2A96\",\n        \"egsdot\":\"\\u2A98\",\n        \"el\":\"\\u2A99\",\n        \"Element\":\"\\u2208\",\n        \"elinters\":\"\\u23E7\",\n        \"ell\":\"\\u2113\",\n        \"els\":\"\\u2A95\",\n        \"elsdot\":\"\\u2A97\",\n        \"Emacr\":\"\\u0112\",\n        \"emacr\":\"\\u0113\",\n        \"empty\":\"\\u2205\",\n        \"emptyset\":\"\\u2205\",\n        \"EmptySmallSquare\":\"\\u25FB\",\n        \"emptyv\":\"\\u2205\",\n        \"EmptyVerySmallSquare\":\"\\u25AB\",\n        \"emsp\":\"\\u2003\",\n        \"emsp13\":\"\\u2004\",\n        \"emsp14\":\"\\u2005\",\n        \"ENG\":\"\\u014A\",\n        \"eng\":\"\\u014B\",\n        \"ensp\":\"\\u2002\",\n        \"Eogon\":\"\\u0118\",\n        \"eogon\":\"\\u0119\",\n        \"Eopf\":\"\\uD835\\uDD3C\",\n        \"eopf\":\"\\uD835\\uDD56\",\n        \"epar\":\"\\u22D5\",\n        \"eparsl\":\"\\u29E3\",\n        \"eplus\":\"\\u2A71\",\n        \"epsi\":\"\\u03B5\",\n        \"Epsilon\":\"\\u0395\",\n        \"epsilon\":\"\\u03B5\",\n        \"epsiv\":\"\\u03F5\",\n        \"eqcirc\":\"\\u2256\",\n        \"eqcolon\":\"\\u2255\",\n        \"eqsim\":\"\\u2242\",\n        \"eqslantgtr\":\"\\u2A96\",\n        \"eqslantless\":\"\\u2A95\",\n        \"Equal\":\"\\u2A75\",\n        \"equals\":\"\\u003D\",\n        \"EqualTilde\":\"\\u2242\",\n        \"equest\":\"\\u225F\",\n        \"Equilibrium\":\"\\u21CC\",\n        \"equiv\":\"\\u2261\",\n        \"equivDD\":\"\\u2A78\",\n        \"eqvparsl\":\"\\u29E5\",\n        \"erarr\":\"\\u2971\",\n        \"erDot\":\"\\u2253\",\n        \"Escr\":\"\\u2130\",\n        \"escr\":\"\\u212F\",\n        \"esdot\":\"\\u2250\",\n        \"Esim\":\"\\u2A73\",\n        \"esim\":\"\\u2242\",\n        \"Eta\":\"\\u0397\",\n        \"eta\":\"\\u03B7\",\n        \"ETH\":\"\\u00D0\",\n        \"eth\":\"\\u00F0\",\n        \"Euml\":\"\\u00CB\",\n        \"euml\":\"\\u00EB\",\n        \"euro\":\"\\u20AC\",\n        \"excl\":\"\\u0021\",\n        \"exist\":\"\\u2203\",\n        \"Exists\":\"\\u2203\",\n        \"expectation\":\"\\u2130\",\n        \"ExponentialE\":\"\\u2147\",\n        \"exponentiale\":\"\\u2147\",\n        \"fallingdotseq\":\"\\u2252\",\n        \"Fcy\":\"\\u0424\",\n        \"fcy\":\"\\u0444\",\n        \"female\":\"\\u2640\",\n        \"ffilig\":\"\\uFB03\",\n        \"fflig\":\"\\uFB00\",\n        \"ffllig\":\"\\uFB04\",\n        \"Ffr\":\"\\uD835\\uDD09\",\n        \"ffr\":\"\\uD835\\uDD23\",\n        \"filig\":\"\\uFB01\",\n        \"FilledSmallSquare\":\"\\u25FC\",\n        \"FilledVerySmallSquare\":\"\\u25AA\",\n        \"fjlig\":\"\\u0066\\u006A\",\n        \"flat\":\"\\u266D\",\n        \"fllig\":\"\\uFB02\",\n        \"fltns\":\"\\u25B1\",\n        \"fnof\":\"\\u0192\",\n        \"Fopf\":\"\\uD835\\uDD3D\",\n        \"fopf\":\"\\uD835\\uDD57\",\n        \"ForAll\":\"\\u2200\",\n        \"forall\":\"\\u2200\",\n        \"fork\":\"\\u22D4\",\n        \"forkv\":\"\\u2AD9\",\n        \"Fouriertrf\":\"\\u2131\",\n        \"fpartint\":\"\\u2A0D\",\n        \"frac12\":\"\\u00BD\",\n        \"frac13\":\"\\u2153\",\n        \"frac14\":\"\\u00BC\",\n        \"frac15\":\"\\u2155\",\n        \"frac16\":\"\\u2159\",\n        \"frac18\":\"\\u215B\",\n        \"frac23\":\"\\u2154\",\n        \"frac25\":\"\\u2156\",\n        \"frac34\":\"\\u00BE\",\n        \"frac35\":\"\\u2157\",\n        \"frac38\":\"\\u215C\",\n        \"frac45\":\"\\u2158\",\n        \"frac56\":\"\\u215A\",\n        \"frac58\":\"\\u215D\",\n        \"frac78\":\"\\u215E\",\n        \"frasl\":\"\\u2044\",\n        \"frown\":\"\\u2322\",\n        \"Fscr\":\"\\u2131\",\n        \"fscr\":\"\\uD835\\uDCBB\",\n        \"gacute\":\"\\u01F5\",\n        \"Gamma\":\"\\u0393\",\n        \"gamma\":\"\\u03B3\",\n        \"Gammad\":\"\\u03DC\",\n        \"gammad\":\"\\u03DD\",\n        \"gap\":\"\\u2A86\",\n        \"Gbreve\":\"\\u011E\",\n        \"gbreve\":\"\\u011F\",\n        \"Gcedil\":\"\\u0122\",\n        \"Gcirc\":\"\\u011C\",\n        \"gcirc\":\"\\u011D\",\n        \"Gcy\":\"\\u0413\",\n        \"gcy\":\"\\u0433\",\n        \"Gdot\":\"\\u0120\",\n        \"gdot\":\"\\u0121\",\n        \"gE\":\"\\u2267\",\n        \"ge\":\"\\u2265\",\n        \"gEl\":\"\\u2A8C\",\n        \"gel\":\"\\u22DB\",\n        \"geq\":\"\\u2265\",\n        \"geqq\":\"\\u2267\",\n        \"geqslant\":\"\\u2A7E\",\n        \"ges\":\"\\u2A7E\",\n        \"gescc\":\"\\u2AA9\",\n        \"gesdot\":\"\\u2A80\",\n        \"gesdoto\":\"\\u2A82\",\n        \"gesdotol\":\"\\u2A84\",\n        \"gesl\":\"\\u22DB\\uFE00\",\n        \"gesles\":\"\\u2A94\",\n        \"Gfr\":\"\\uD835\\uDD0A\",\n        \"gfr\":\"\\uD835\\uDD24\",\n        \"Gg\":\"\\u22D9\",\n        \"gg\":\"\\u226B\",\n        \"ggg\":\"\\u22D9\",\n        \"gimel\":\"\\u2137\",\n        \"GJcy\":\"\\u0403\",\n        \"gjcy\":\"\\u0453\",\n        \"gl\":\"\\u2277\",\n        \"gla\":\"\\u2AA5\",\n        \"glE\":\"\\u2A92\",\n        \"glj\":\"\\u2AA4\",\n        \"gnap\":\"\\u2A8A\",\n        \"gnapprox\":\"\\u2A8A\",\n        \"gnE\":\"\\u2269\",\n        \"gne\":\"\\u2A88\",\n        \"gneq\":\"\\u2A88\",\n        \"gneqq\":\"\\u2269\",\n        \"gnsim\":\"\\u22E7\",\n        \"Gopf\":\"\\uD835\\uDD3E\",\n        \"gopf\":\"\\uD835\\uDD58\",\n        \"grave\":\"\\u0060\",\n        \"GreaterEqual\":\"\\u2265\",\n        \"GreaterEqualLess\":\"\\u22DB\",\n        \"GreaterFullEqual\":\"\\u2267\",\n        \"GreaterGreater\":\"\\u2AA2\",\n        \"GreaterLess\":\"\\u2277\",\n        \"GreaterSlantEqual\":\"\\u2A7E\",\n        \"GreaterTilde\":\"\\u2273\",\n        \"Gscr\":\"\\uD835\\uDCA2\",\n        \"gscr\":\"\\u210A\",\n        \"gsim\":\"\\u2273\",\n        \"gsime\":\"\\u2A8E\",\n        \"gsiml\":\"\\u2A90\",\n        \"GT\":\"\\u003E\",\n        \"Gt\":\"\\u226B\",\n        \"gt\":\"\\u003E\",\n        \"gtcc\":\"\\u2AA7\",\n        \"gtcir\":\"\\u2A7A\",\n        \"gtdot\":\"\\u22D7\",\n        \"gtlPar\":\"\\u2995\",\n        \"gtquest\":\"\\u2A7C\",\n        \"gtrapprox\":\"\\u2A86\",\n        \"gtrarr\":\"\\u2978\",\n        \"gtrdot\":\"\\u22D7\",\n        \"gtreqless\":\"\\u22DB\",\n        \"gtreqqless\":\"\\u2A8C\",\n        \"gtrless\":\"\\u2277\",\n        \"gtrsim\":\"\\u2273\",\n        \"gvertneqq\":\"\\u2269\\uFE00\",\n        \"gvnE\":\"\\u2269\\uFE00\",\n        \"Hacek\":\"\\u02C7\",\n        \"hairsp\":\"\\u200A\",\n        \"half\":\"\\u00BD\",\n        \"hamilt\":\"\\u210B\",\n        \"HARDcy\":\"\\u042A\",\n        \"hardcy\":\"\\u044A\",\n        \"hArr\":\"\\u21D4\",\n        \"harr\":\"\\u2194\",\n        \"harrcir\":\"\\u2948\",\n        \"harrw\":\"\\u21AD\",\n        \"Hat\":\"\\u005E\",\n        \"hbar\":\"\\u210F\",\n        \"Hcirc\":\"\\u0124\",\n        \"hcirc\":\"\\u0125\",\n        \"hearts\":\"\\u2665\",\n        \"heartsuit\":\"\\u2665\",\n        \"hellip\":\"\\u2026\",\n        \"hercon\":\"\\u22B9\",\n        \"Hfr\":\"\\u210C\",\n        \"hfr\":\"\\uD835\\uDD25\",\n        \"HilbertSpace\":\"\\u210B\",\n        \"hksearow\":\"\\u2925\",\n        \"hkswarow\":\"\\u2926\",\n        \"hoarr\":\"\\u21FF\",\n        \"homtht\":\"\\u223B\",\n        \"hookleftarrow\":\"\\u21A9\",\n        \"hookrightarrow\":\"\\u21AA\",\n        \"Hopf\":\"\\u210D\",\n        \"hopf\":\"\\uD835\\uDD59\",\n        \"horbar\":\"\\u2015\",\n        \"HorizontalLine\":\"\\u2500\",\n        \"Hscr\":\"\\u210B\",\n        \"hscr\":\"\\uD835\\uDCBD\",\n        \"hslash\":\"\\u210F\",\n        \"Hstrok\":\"\\u0126\",\n        \"hstrok\":\"\\u0127\",\n        \"HumpDownHump\":\"\\u224E\",\n        \"HumpEqual\":\"\\u224F\",\n        \"hybull\":\"\\u2043\",\n        \"hyphen\":\"\\u2010\",\n        \"Iacute\":\"\\u00CD\",\n        \"iacute\":\"\\u00ED\",\n        \"ic\":\"\\u2063\",\n        \"Icirc\":\"\\u00CE\",\n        \"icirc\":\"\\u00EE\",\n        \"Icy\":\"\\u0418\",\n        \"icy\":\"\\u0438\",\n        \"Idot\":\"\\u0130\",\n        \"IEcy\":\"\\u0415\",\n        \"iecy\":\"\\u0435\",\n        \"iexcl\":\"\\u00A1\",\n        \"iff\":\"\\u21D4\",\n        \"Ifr\":\"\\u2111\",\n        \"ifr\":\"\\uD835\\uDD26\",\n        \"Igrave\":\"\\u00CC\",\n        \"igrave\":\"\\u00EC\",\n        \"ii\":\"\\u2148\",\n        \"iiiint\":\"\\u2A0C\",\n        \"iiint\":\"\\u222D\",\n        \"iinfin\":\"\\u29DC\",\n        \"iiota\":\"\\u2129\",\n        \"IJlig\":\"\\u0132\",\n        \"ijlig\":\"\\u0133\",\n        \"Im\":\"\\u2111\",\n        \"Imacr\":\"\\u012A\",\n        \"imacr\":\"\\u012B\",\n        \"image\":\"\\u2111\",\n        \"ImaginaryI\":\"\\u2148\",\n        \"imagline\":\"\\u2110\",\n        \"imagpart\":\"\\u2111\",\n        \"imath\":\"\\u0131\",\n        \"imof\":\"\\u22B7\",\n        \"imped\":\"\\u01B5\",\n        \"Implies\":\"\\u21D2\",\n        \"in\":\"\\u2208\",\n        \"incare\":\"\\u2105\",\n        \"infin\":\"\\u221E\",\n        \"infintie\":\"\\u29DD\",\n        \"inodot\":\"\\u0131\",\n        \"Int\":\"\\u222C\",\n        \"int\":\"\\u222B\",\n        \"intcal\":\"\\u22BA\",\n        \"integers\":\"\\u2124\",\n        \"Integral\":\"\\u222B\",\n        \"intercal\":\"\\u22BA\",\n        \"Intersection\":\"\\u22C2\",\n        \"intlarhk\":\"\\u2A17\",\n        \"intprod\":\"\\u2A3C\",\n        \"InvisibleComma\":\"\\u2063\",\n        \"InvisibleTimes\":\"\\u2062\",\n        \"IOcy\":\"\\u0401\",\n        \"iocy\":\"\\u0451\",\n        \"Iogon\":\"\\u012E\",\n        \"iogon\":\"\\u012F\",\n        \"Iopf\":\"\\uD835\\uDD40\",\n        \"iopf\":\"\\uD835\\uDD5A\",\n        \"Iota\":\"\\u0399\",\n        \"iota\":\"\\u03B9\",\n        \"iprod\":\"\\u2A3C\",\n        \"iquest\":\"\\u00BF\",\n        \"Iscr\":\"\\u2110\",\n        \"iscr\":\"\\uD835\\uDCBE\",\n        \"isin\":\"\\u2208\",\n        \"isindot\":\"\\u22F5\",\n        \"isinE\":\"\\u22F9\",\n        \"isins\":\"\\u22F4\",\n        \"isinsv\":\"\\u22F3\",\n        \"isinv\":\"\\u2208\",\n        \"it\":\"\\u2062\",\n        \"Itilde\":\"\\u0128\",\n        \"itilde\":\"\\u0129\",\n        \"Iukcy\":\"\\u0406\",\n        \"iukcy\":\"\\u0456\",\n        \"Iuml\":\"\\u00CF\",\n        \"iuml\":\"\\u00EF\",\n        \"Jcirc\":\"\\u0134\",\n        \"jcirc\":\"\\u0135\",\n        \"Jcy\":\"\\u0419\",\n        \"jcy\":\"\\u0439\",\n        \"Jfr\":\"\\uD835\\uDD0D\",\n        \"jfr\":\"\\uD835\\uDD27\",\n        \"jmath\":\"\\u0237\",\n        \"Jopf\":\"\\uD835\\uDD41\",\n        \"jopf\":\"\\uD835\\uDD5B\",\n        \"Jscr\":\"\\uD835\\uDCA5\",\n        \"jscr\":\"\\uD835\\uDCBF\",\n        \"Jsercy\":\"\\u0408\",\n        \"jsercy\":\"\\u0458\",\n        \"Jukcy\":\"\\u0404\",\n        \"jukcy\":\"\\u0454\",\n        \"Kappa\":\"\\u039A\",\n        \"kappa\":\"\\u03BA\",\n        \"kappav\":\"\\u03F0\",\n        \"Kcedil\":\"\\u0136\",\n        \"kcedil\":\"\\u0137\",\n        \"Kcy\":\"\\u041A\",\n        \"kcy\":\"\\u043A\",\n        \"Kfr\":\"\\uD835\\uDD0E\",\n        \"kfr\":\"\\uD835\\uDD28\",\n        \"kgreen\":\"\\u0138\",\n        \"KHcy\":\"\\u0425\",\n        \"khcy\":\"\\u0445\",\n        \"KJcy\":\"\\u040C\",\n        \"kjcy\":\"\\u045C\",\n        \"Kopf\":\"\\uD835\\uDD42\",\n        \"kopf\":\"\\uD835\\uDD5C\",\n        \"Kscr\":\"\\uD835\\uDCA6\",\n        \"kscr\":\"\\uD835\\uDCC0\",\n        \"lAarr\":\"\\u21DA\",\n        \"Lacute\":\"\\u0139\",\n        \"lacute\":\"\\u013A\",\n        \"laemptyv\":\"\\u29B4\",\n        \"lagran\":\"\\u2112\",\n        \"Lambda\":\"\\u039B\",\n        \"lambda\":\"\\u03BB\",\n        \"Lang\":\"\\u27EA\",\n        \"lang\":\"\\u27E8\",\n        \"langd\":\"\\u2991\",\n        \"langle\":\"\\u27E8\",\n        \"lap\":\"\\u2A85\",\n        \"Laplacetrf\":\"\\u2112\",\n        \"laquo\":\"\\u00AB\",\n        \"Larr\":\"\\u219E\",\n        \"lArr\":\"\\u21D0\",\n        \"larr\":\"\\u2190\",\n        \"larrb\":\"\\u21E4\",\n        \"larrbfs\":\"\\u291F\",\n        \"larrfs\":\"\\u291D\",\n        \"larrhk\":\"\\u21A9\",\n        \"larrlp\":\"\\u21AB\",\n        \"larrpl\":\"\\u2939\",\n        \"larrsim\":\"\\u2973\",\n        \"larrtl\":\"\\u21A2\",\n        \"lat\":\"\\u2AAB\",\n        \"lAtail\":\"\\u291B\",\n        \"latail\":\"\\u2919\",\n        \"late\":\"\\u2AAD\",\n        \"lates\":\"\\u2AAD\\uFE00\",\n        \"lBarr\":\"\\u290E\",\n        \"lbarr\":\"\\u290C\",\n        \"lbbrk\":\"\\u2772\",\n        \"lbrace\":\"\\u007B\",\n        \"lbrack\":\"\\u005B\",\n        \"lbrke\":\"\\u298B\",\n        \"lbrksld\":\"\\u298F\",\n        \"lbrkslu\":\"\\u298D\",\n        \"Lcaron\":\"\\u013D\",\n        \"lcaron\":\"\\u013E\",\n        \"Lcedil\":\"\\u013B\",\n        \"lcedil\":\"\\u013C\",\n        \"lceil\":\"\\u2308\",\n        \"lcub\":\"\\u007B\",\n        \"Lcy\":\"\\u041B\",\n        \"lcy\":\"\\u043B\",\n        \"ldca\":\"\\u2936\",\n        \"ldquo\":\"\\u201C\",\n        \"ldquor\":\"\\u201E\",\n        \"ldrdhar\":\"\\u2967\",\n        \"ldrushar\":\"\\u294B\",\n        \"ldsh\":\"\\u21B2\",\n        \"lE\":\"\\u2266\",\n        \"le\":\"\\u2264\",\n        \"LeftAngleBracket\":\"\\u27E8\",\n        \"LeftArrow\":\"\\u2190\",\n        \"Leftarrow\":\"\\u21D0\",\n        \"leftarrow\":\"\\u2190\",\n        \"LeftArrowBar\":\"\\u21E4\",\n        \"LeftArrowRightArrow\":\"\\u21C6\",\n        \"leftarrowtail\":\"\\u21A2\",\n        \"LeftCeiling\":\"\\u2308\",\n        \"LeftDoubleBracket\":\"\\u27E6\",\n        \"LeftDownTeeVector\":\"\\u2961\",\n        \"LeftDownVector\":\"\\u21C3\",\n        \"LeftDownVectorBar\":\"\\u2959\",\n        \"LeftFloor\":\"\\u230A\",\n        \"leftharpoondown\":\"\\u21BD\",\n        \"leftharpoonup\":\"\\u21BC\",\n        \"leftleftarrows\":\"\\u21C7\",\n        \"LeftRightArrow\":\"\\u2194\",\n        \"Leftrightarrow\":\"\\u21D4\",\n        \"leftrightarrow\":\"\\u2194\",\n        \"leftrightarrows\":\"\\u21C6\",\n        \"leftrightharpoons\":\"\\u21CB\",\n        \"leftrightsquigarrow\":\"\\u21AD\",\n        \"LeftRightVector\":\"\\u294E\",\n        \"LeftTee\":\"\\u22A3\",\n        \"LeftTeeArrow\":\"\\u21A4\",\n        \"LeftTeeVector\":\"\\u295A\",\n        \"leftthreetimes\":\"\\u22CB\",\n        \"LeftTriangle\":\"\\u22B2\",\n        \"LeftTriangleBar\":\"\\u29CF\",\n        \"LeftTriangleEqual\":\"\\u22B4\",\n        \"LeftUpDownVector\":\"\\u2951\",\n        \"LeftUpTeeVector\":\"\\u2960\",\n        \"LeftUpVector\":\"\\u21BF\",\n        \"LeftUpVectorBar\":\"\\u2958\",\n        \"LeftVector\":\"\\u21BC\",\n        \"LeftVectorBar\":\"\\u2952\",\n        \"lEg\":\"\\u2A8B\",\n        \"leg\":\"\\u22DA\",\n        \"leq\":\"\\u2264\",\n        \"leqq\":\"\\u2266\",\n        \"leqslant\":\"\\u2A7D\",\n        \"les\":\"\\u2A7D\",\n        \"lescc\":\"\\u2AA8\",\n        \"lesdot\":\"\\u2A7F\",\n        \"lesdoto\":\"\\u2A81\",\n        \"lesdotor\":\"\\u2A83\",\n        \"lesg\":\"\\u22DA\\uFE00\",\n        \"lesges\":\"\\u2A93\",\n        \"lessapprox\":\"\\u2A85\",\n        \"lessdot\":\"\\u22D6\",\n        \"lesseqgtr\":\"\\u22DA\",\n        \"lesseqqgtr\":\"\\u2A8B\",\n        \"LessEqualGreater\":\"\\u22DA\",\n        \"LessFullEqual\":\"\\u2266\",\n        \"LessGreater\":\"\\u2276\",\n        \"lessgtr\":\"\\u2276\",\n        \"LessLess\":\"\\u2AA1\",\n        \"lesssim\":\"\\u2272\",\n        \"LessSlantEqual\":\"\\u2A7D\",\n        \"LessTilde\":\"\\u2272\",\n        \"lfisht\":\"\\u297C\",\n        \"lfloor\":\"\\u230A\",\n        \"Lfr\":\"\\uD835\\uDD0F\",\n        \"lfr\":\"\\uD835\\uDD29\",\n        \"lg\":\"\\u2276\",\n        \"lgE\":\"\\u2A91\",\n        \"lHar\":\"\\u2962\",\n        \"lhard\":\"\\u21BD\",\n        \"lharu\":\"\\u21BC\",\n        \"lharul\":\"\\u296A\",\n        \"lhblk\":\"\\u2584\",\n        \"LJcy\":\"\\u0409\",\n        \"ljcy\":\"\\u0459\",\n        \"Ll\":\"\\u22D8\",\n        \"ll\":\"\\u226A\",\n        \"llarr\":\"\\u21C7\",\n        \"llcorner\":\"\\u231E\",\n        \"Lleftarrow\":\"\\u21DA\",\n        \"llhard\":\"\\u296B\",\n        \"lltri\":\"\\u25FA\",\n        \"Lmidot\":\"\\u013F\",\n        \"lmidot\":\"\\u0140\",\n        \"lmoust\":\"\\u23B0\",\n        \"lmoustache\":\"\\u23B0\",\n        \"lnap\":\"\\u2A89\",\n        \"lnapprox\":\"\\u2A89\",\n        \"lnE\":\"\\u2268\",\n        \"lne\":\"\\u2A87\",\n        \"lneq\":\"\\u2A87\",\n        \"lneqq\":\"\\u2268\",\n        \"lnsim\":\"\\u22E6\",\n        \"loang\":\"\\u27EC\",\n        \"loarr\":\"\\u21FD\",\n        \"lobrk\":\"\\u27E6\",\n        \"LongLeftArrow\":\"\\u27F5\",\n        \"Longleftarrow\":\"\\u27F8\",\n        \"longleftarrow\":\"\\u27F5\",\n        \"LongLeftRightArrow\":\"\\u27F7\",\n        \"Longleftrightarrow\":\"\\u27FA\",\n        \"longleftrightarrow\":\"\\u27F7\",\n        \"longmapsto\":\"\\u27FC\",\n        \"LongRightArrow\":\"\\u27F6\",\n        \"Longrightarrow\":\"\\u27F9\",\n        \"longrightarrow\":\"\\u27F6\",\n        \"looparrowleft\":\"\\u21AB\",\n        \"looparrowright\":\"\\u21AC\",\n        \"lopar\":\"\\u2985\",\n        \"Lopf\":\"\\uD835\\uDD43\",\n        \"lopf\":\"\\uD835\\uDD5D\",\n        \"loplus\":\"\\u2A2D\",\n        \"lotimes\":\"\\u2A34\",\n        \"lowast\":\"\\u2217\",\n        \"lowbar\":\"\\u005F\",\n        \"LowerLeftArrow\":\"\\u2199\",\n        \"LowerRightArrow\":\"\\u2198\",\n        \"loz\":\"\\u25CA\",\n        \"lozenge\":\"\\u25CA\",\n        \"lozf\":\"\\u29EB\",\n        \"lpar\":\"\\u0028\",\n        \"lparlt\":\"\\u2993\",\n        \"lrarr\":\"\\u21C6\",\n        \"lrcorner\":\"\\u231F\",\n        \"lrhar\":\"\\u21CB\",\n        \"lrhard\":\"\\u296D\",\n        \"lrm\":\"\\u200E\",\n        \"lrtri\":\"\\u22BF\",\n        \"lsaquo\":\"\\u2039\",\n        \"Lscr\":\"\\u2112\",\n        \"lscr\":\"\\uD835\\uDCC1\",\n        \"Lsh\":\"\\u21B0\",\n        \"lsh\":\"\\u21B0\",\n        \"lsim\":\"\\u2272\",\n        \"lsime\":\"\\u2A8D\",\n        \"lsimg\":\"\\u2A8F\",\n        \"lsqb\":\"\\u005B\",\n        \"lsquo\":\"\\u2018\",\n        \"lsquor\":\"\\u201A\",\n        \"Lstrok\":\"\\u0141\",\n        \"lstrok\":\"\\u0142\",\n        \"LT\":\"\\u003C\",\n        \"Lt\":\"\\u226A\",\n        \"lt\":\"\\u003C\",\n        \"ltcc\":\"\\u2AA6\",\n        \"ltcir\":\"\\u2A79\",\n        \"ltdot\":\"\\u22D6\",\n        \"lthree\":\"\\u22CB\",\n        \"ltimes\":\"\\u22C9\",\n        \"ltlarr\":\"\\u2976\",\n        \"ltquest\":\"\\u2A7B\",\n        \"ltri\":\"\\u25C3\",\n        \"ltrie\":\"\\u22B4\",\n        \"ltrif\":\"\\u25C2\",\n        \"ltrPar\":\"\\u2996\",\n        \"lurdshar\":\"\\u294A\",\n        \"luruhar\":\"\\u2966\",\n        \"lvertneqq\":\"\\u2268\\uFE00\",\n        \"lvnE\":\"\\u2268\\uFE00\",\n        \"macr\":\"\\u00AF\",\n        \"male\":\"\\u2642\",\n        \"malt\":\"\\u2720\",\n        \"maltese\":\"\\u2720\",\n        \"Map\":\"\\u2905\",\n        \"map\":\"\\u21A6\",\n        \"mapsto\":\"\\u21A6\",\n        \"mapstodown\":\"\\u21A7\",\n        \"mapstoleft\":\"\\u21A4\",\n        \"mapstoup\":\"\\u21A5\",\n        \"marker\":\"\\u25AE\",\n        \"mcomma\":\"\\u2A29\",\n        \"Mcy\":\"\\u041C\",\n        \"mcy\":\"\\u043C\",\n        \"mdash\":\"\\u2014\",\n        \"mDDot\":\"\\u223A\",\n        \"measuredangle\":\"\\u2221\",\n        \"MediumSpace\":\"\\u205F\",\n        \"Mellintrf\":\"\\u2133\",\n        \"Mfr\":\"\\uD835\\uDD10\",\n        \"mfr\":\"\\uD835\\uDD2A\",\n        \"mho\":\"\\u2127\",\n        \"micro\":\"\\u00B5\",\n        \"mid\":\"\\u2223\",\n        \"midast\":\"\\u002A\",\n        \"midcir\":\"\\u2AF0\",\n        \"middot\":\"\\u00B7\",\n        \"minus\":\"\\u2212\",\n        \"minusb\":\"\\u229F\",\n        \"minusd\":\"\\u2238\",\n        \"minusdu\":\"\\u2A2A\",\n        \"MinusPlus\":\"\\u2213\",\n        \"mlcp\":\"\\u2ADB\",\n        \"mldr\":\"\\u2026\",\n        \"mnplus\":\"\\u2213\",\n        \"models\":\"\\u22A7\",\n        \"Mopf\":\"\\uD835\\uDD44\",\n        \"mopf\":\"\\uD835\\uDD5E\",\n        \"mp\":\"\\u2213\",\n        \"Mscr\":\"\\u2133\",\n        \"mscr\":\"\\uD835\\uDCC2\",\n        \"mstpos\":\"\\u223E\",\n        \"Mu\":\"\\u039C\",\n        \"mu\":\"\\u03BC\",\n        \"multimap\":\"\\u22B8\",\n        \"mumap\":\"\\u22B8\",\n        \"nabla\":\"\\u2207\",\n        \"Nacute\":\"\\u0143\",\n        \"nacute\":\"\\u0144\",\n        \"nang\":\"\\u2220\\u20D2\",\n        \"nap\":\"\\u2249\",\n        \"napE\":\"\\u2A70\\u0338\",\n        \"napid\":\"\\u224B\\u0338\",\n        \"napos\":\"\\u0149\",\n        \"napprox\":\"\\u2249\",\n        \"natur\":\"\\u266E\",\n        \"natural\":\"\\u266E\",\n        \"naturals\":\"\\u2115\",\n        \"nbsp\":\"\\u00A0\",\n        \"nbump\":\"\\u224E\\u0338\",\n        \"nbumpe\":\"\\u224F\\u0338\",\n        \"ncap\":\"\\u2A43\",\n        \"Ncaron\":\"\\u0147\",\n        \"ncaron\":\"\\u0148\",\n        \"Ncedil\":\"\\u0145\",\n        \"ncedil\":\"\\u0146\",\n        \"ncong\":\"\\u2247\",\n        \"ncongdot\":\"\\u2A6D\\u0338\",\n        \"ncup\":\"\\u2A42\",\n        \"Ncy\":\"\\u041D\",\n        \"ncy\":\"\\u043D\",\n        \"ndash\":\"\\u2013\",\n        \"ne\":\"\\u2260\",\n        \"nearhk\":\"\\u2924\",\n        \"neArr\":\"\\u21D7\",\n        \"nearr\":\"\\u2197\",\n        \"nearrow\":\"\\u2197\",\n        \"nedot\":\"\\u2250\\u0338\",\n        \"NegativeMediumSpace\":\"\\u200B\",\n        \"NegativeThickSpace\":\"\\u200B\",\n        \"NegativeThinSpace\":\"\\u200B\",\n        \"NegativeVeryThinSpace\":\"\\u200B\",\n        \"nequiv\":\"\\u2262\",\n        \"nesear\":\"\\u2928\",\n        \"nesim\":\"\\u2242\\u0338\",\n        \"NestedGreaterGreater\":\"\\u226B\",\n        \"NestedLessLess\":\"\\u226A\",\n        \"NewLine\":\"\\u000A\",\n        \"nexist\":\"\\u2204\",\n        \"nexists\":\"\\u2204\",\n        \"Nfr\":\"\\uD835\\uDD11\",\n        \"nfr\":\"\\uD835\\uDD2B\",\n        \"ngE\":\"\\u2267\\u0338\",\n        \"nge\":\"\\u2271\",\n        \"ngeq\":\"\\u2271\",\n        \"ngeqq\":\"\\u2267\\u0338\",\n        \"ngeqslant\":\"\\u2A7E\\u0338\",\n        \"nges\":\"\\u2A7E\\u0338\",\n        \"nGg\":\"\\u22D9\\u0338\",\n        \"ngsim\":\"\\u2275\",\n        \"nGt\":\"\\u226B\\u20D2\",\n        \"ngt\":\"\\u226F\",\n        \"ngtr\":\"\\u226F\",\n        \"nGtv\":\"\\u226B\\u0338\",\n        \"nhArr\":\"\\u21CE\",\n        \"nharr\":\"\\u21AE\",\n        \"nhpar\":\"\\u2AF2\",\n        \"ni\":\"\\u220B\",\n        \"nis\":\"\\u22FC\",\n        \"nisd\":\"\\u22FA\",\n        \"niv\":\"\\u220B\",\n        \"NJcy\":\"\\u040A\",\n        \"njcy\":\"\\u045A\",\n        \"nlArr\":\"\\u21CD\",\n        \"nlarr\":\"\\u219A\",\n        \"nldr\":\"\\u2025\",\n        \"nlE\":\"\\u2266\\u0338\",\n        \"nle\":\"\\u2270\",\n        \"nLeftarrow\":\"\\u21CD\",\n        \"nleftarrow\":\"\\u219A\",\n        \"nLeftrightarrow\":\"\\u21CE\",\n        \"nleftrightarrow\":\"\\u21AE\",\n        \"nleq\":\"\\u2270\",\n        \"nleqq\":\"\\u2266\\u0338\",\n        \"nleqslant\":\"\\u2A7D\\u0338\",\n        \"nles\":\"\\u2A7D\\u0338\",\n        \"nless\":\"\\u226E\",\n        \"nLl\":\"\\u22D8\\u0338\",\n        \"nlsim\":\"\\u2274\",\n        \"nLt\":\"\\u226A\\u20D2\",\n        \"nlt\":\"\\u226E\",\n        \"nltri\":\"\\u22EA\",\n        \"nltrie\":\"\\u22EC\",\n        \"nLtv\":\"\\u226A\\u0338\",\n        \"nmid\":\"\\u2224\",\n        \"NoBreak\":\"\\u2060\",\n        \"NonBreakingSpace\":\"\\u00A0\",\n        \"Nopf\":\"\\u2115\",\n        \"nopf\":\"\\uD835\\uDD5F\",\n        \"Not\":\"\\u2AEC\",\n        \"not\":\"\\u00AC\",\n        \"NotCongruent\":\"\\u2262\",\n        \"NotCupCap\":\"\\u226D\",\n        \"NotDoubleVerticalBar\":\"\\u2226\",\n        \"NotElement\":\"\\u2209\",\n        \"NotEqual\":\"\\u2260\",\n        \"NotEqualTilde\":\"\\u2242\\u0338\",\n        \"NotExists\":\"\\u2204\",\n        \"NotGreater\":\"\\u226F\",\n        \"NotGreaterEqual\":\"\\u2271\",\n        \"NotGreaterFullEqual\":\"\\u2267\\u0338\",\n        \"NotGreaterGreater\":\"\\u226B\\u0338\",\n        \"NotGreaterLess\":\"\\u2279\",\n        \"NotGreaterSlantEqual\":\"\\u2A7E\\u0338\",\n        \"NotGreaterTilde\":\"\\u2275\",\n        \"NotHumpDownHump\":\"\\u224E\\u0338\",\n        \"NotHumpEqual\":\"\\u224F\\u0338\",\n        \"notin\":\"\\u2209\",\n        \"notindot\":\"\\u22F5\\u0338\",\n        \"notinE\":\"\\u22F9\\u0338\",\n        \"notinva\":\"\\u2209\",\n        \"notinvb\":\"\\u22F7\",\n        \"notinvc\":\"\\u22F6\",\n        \"NotLeftTriangle\":\"\\u22EA\",\n        \"NotLeftTriangleBar\":\"\\u29CF\\u0338\",\n        \"NotLeftTriangleEqual\":\"\\u22EC\",\n        \"NotLess\":\"\\u226E\",\n        \"NotLessEqual\":\"\\u2270\",\n        \"NotLessGreater\":\"\\u2278\",\n        \"NotLessLess\":\"\\u226A\\u0338\",\n        \"NotLessSlantEqual\":\"\\u2A7D\\u0338\",\n        \"NotLessTilde\":\"\\u2274\",\n        \"NotNestedGreaterGreater\":\"\\u2AA2\\u0338\",\n        \"NotNestedLessLess\":\"\\u2AA1\\u0338\",\n        \"notni\":\"\\u220C\",\n        \"notniva\":\"\\u220C\",\n        \"notnivb\":\"\\u22FE\",\n        \"notnivc\":\"\\u22FD\",\n        \"NotPrecedes\":\"\\u2280\",\n        \"NotPrecedesEqual\":\"\\u2AAF\\u0338\",\n        \"NotPrecedesSlantEqual\":\"\\u22E0\",\n        \"NotReverseElement\":\"\\u220C\",\n        \"NotRightTriangle\":\"\\u22EB\",\n        \"NotRightTriangleBar\":\"\\u29D0\\u0338\",\n        \"NotRightTriangleEqual\":\"\\u22ED\",\n        \"NotSquareSubset\":\"\\u228F\\u0338\",\n        \"NotSquareSubsetEqual\":\"\\u22E2\",\n        \"NotSquareSuperset\":\"\\u2290\\u0338\",\n        \"NotSquareSupersetEqual\":\"\\u22E3\",\n        \"NotSubset\":\"\\u2282\\u20D2\",\n        \"NotSubsetEqual\":\"\\u2288\",\n        \"NotSucceeds\":\"\\u2281\",\n        \"NotSucceedsEqual\":\"\\u2AB0\\u0338\",\n        \"NotSucceedsSlantEqual\":\"\\u22E1\",\n        \"NotSucceedsTilde\":\"\\u227F\\u0338\",\n        \"NotSuperset\":\"\\u2283\\u20D2\",\n        \"NotSupersetEqual\":\"\\u2289\",\n        \"NotTilde\":\"\\u2241\",\n        \"NotTildeEqual\":\"\\u2244\",\n        \"NotTildeFullEqual\":\"\\u2247\",\n        \"NotTildeTilde\":\"\\u2249\",\n        \"NotVerticalBar\":\"\\u2224\",\n        \"npar\":\"\\u2226\",\n        \"nparallel\":\"\\u2226\",\n        \"nparsl\":\"\\u2AFD\\u20E5\",\n        \"npart\":\"\\u2202\\u0338\",\n        \"npolint\":\"\\u2A14\",\n        \"npr\":\"\\u2280\",\n        \"nprcue\":\"\\u22E0\",\n        \"npre\":\"\\u2AAF\\u0338\",\n        \"nprec\":\"\\u2280\",\n        \"npreceq\":\"\\u2AAF\\u0338\",\n        \"nrArr\":\"\\u21CF\",\n        \"nrarr\":\"\\u219B\",\n        \"nrarrc\":\"\\u2933\\u0338\",\n        \"nrarrw\":\"\\u219D\\u0338\",\n        \"nRightarrow\":\"\\u21CF\",\n        \"nrightarrow\":\"\\u219B\",\n        \"nrtri\":\"\\u22EB\",\n        \"nrtrie\":\"\\u22ED\",\n        \"nsc\":\"\\u2281\",\n        \"nsccue\":\"\\u22E1\",\n        \"nsce\":\"\\u2AB0\\u0338\",\n        \"Nscr\":\"\\uD835\\uDCA9\",\n        \"nscr\":\"\\uD835\\uDCC3\",\n        \"nshortmid\":\"\\u2224\",\n        \"nshortparallel\":\"\\u2226\",\n        \"nsim\":\"\\u2241\",\n        \"nsime\":\"\\u2244\",\n        \"nsimeq\":\"\\u2244\",\n        \"nsmid\":\"\\u2224\",\n        \"nspar\":\"\\u2226\",\n        \"nsqsube\":\"\\u22E2\",\n        \"nsqsupe\":\"\\u22E3\",\n        \"nsub\":\"\\u2284\",\n        \"nsubE\":\"\\u2AC5\\u0338\",\n        \"nsube\":\"\\u2288\",\n        \"nsubset\":\"\\u2282\\u20D2\",\n        \"nsubseteq\":\"\\u2288\",\n        \"nsubseteqq\":\"\\u2AC5\\u0338\",\n        \"nsucc\":\"\\u2281\",\n        \"nsucceq\":\"\\u2AB0\\u0338\",\n        \"nsup\":\"\\u2285\",\n        \"nsupE\":\"\\u2AC6\\u0338\",\n        \"nsupe\":\"\\u2289\",\n        \"nsupset\":\"\\u2283\\u20D2\",\n        \"nsupseteq\":\"\\u2289\",\n        \"nsupseteqq\":\"\\u2AC6\\u0338\",\n        \"ntgl\":\"\\u2279\",\n        \"Ntilde\":\"\\u00D1\",\n        \"ntilde\":\"\\u00F1\",\n        \"ntlg\":\"\\u2278\",\n        \"ntriangleleft\":\"\\u22EA\",\n        \"ntrianglelefteq\":\"\\u22EC\",\n        \"ntriangleright\":\"\\u22EB\",\n        \"ntrianglerighteq\":\"\\u22ED\",\n        \"Nu\":\"\\u039D\",\n        \"nu\":\"\\u03BD\",\n        \"num\":\"\\u0023\",\n        \"numero\":\"\\u2116\",\n        \"numsp\":\"\\u2007\",\n        \"nvap\":\"\\u224D\\u20D2\",\n        \"nVDash\":\"\\u22AF\",\n        \"nVdash\":\"\\u22AE\",\n        \"nvDash\":\"\\u22AD\",\n        \"nvdash\":\"\\u22AC\",\n        \"nvge\":\"\\u2265\\u20D2\",\n        \"nvgt\":\"\\u003E\\u20D2\",\n        \"nvHarr\":\"\\u2904\",\n        \"nvinfin\":\"\\u29DE\",\n        \"nvlArr\":\"\\u2902\",\n        \"nvle\":\"\\u2264\\u20D2\",\n        \"nvlt\":\"\\u003C\\u20D2\",\n        \"nvltrie\":\"\\u22B4\\u20D2\",\n        \"nvrArr\":\"\\u2903\",\n        \"nvrtrie\":\"\\u22B5\\u20D2\",\n        \"nvsim\":\"\\u223C\\u20D2\",\n        \"nwarhk\":\"\\u2923\",\n        \"nwArr\":\"\\u21D6\",\n        \"nwarr\":\"\\u2196\",\n        \"nwarrow\":\"\\u2196\",\n        \"nwnear\":\"\\u2927\",\n        \"Oacute\":\"\\u00D3\",\n        \"oacute\":\"\\u00F3\",\n        \"oast\":\"\\u229B\",\n        \"ocir\":\"\\u229A\",\n        \"Ocirc\":\"\\u00D4\",\n        \"ocirc\":\"\\u00F4\",\n        \"Ocy\":\"\\u041E\",\n        \"ocy\":\"\\u043E\",\n        \"odash\":\"\\u229D\",\n        \"Odblac\":\"\\u0150\",\n        \"odblac\":\"\\u0151\",\n        \"odiv\":\"\\u2A38\",\n        \"odot\":\"\\u2299\",\n        \"odsold\":\"\\u29BC\",\n        \"OElig\":\"\\u0152\",\n        \"oelig\":\"\\u0153\",\n        \"ofcir\":\"\\u29BF\",\n        \"Ofr\":\"\\uD835\\uDD12\",\n        \"ofr\":\"\\uD835\\uDD2C\",\n        \"ogon\":\"\\u02DB\",\n        \"Ograve\":\"\\u00D2\",\n        \"ograve\":\"\\u00F2\",\n        \"ogt\":\"\\u29C1\",\n        \"ohbar\":\"\\u29B5\",\n        \"ohm\":\"\\u03A9\",\n        \"oint\":\"\\u222E\",\n        \"olarr\":\"\\u21BA\",\n        \"olcir\":\"\\u29BE\",\n        \"olcross\":\"\\u29BB\",\n        \"oline\":\"\\u203E\",\n        \"olt\":\"\\u29C0\",\n        \"Omacr\":\"\\u014C\",\n        \"omacr\":\"\\u014D\",\n        \"Omega\":\"\\u03A9\",\n        \"omega\":\"\\u03C9\",\n        \"Omicron\":\"\\u039F\",\n        \"omicron\":\"\\u03BF\",\n        \"omid\":\"\\u29B6\",\n        \"ominus\":\"\\u2296\",\n        \"Oopf\":\"\\uD835\\uDD46\",\n        \"oopf\":\"\\uD835\\uDD60\",\n        \"opar\":\"\\u29B7\",\n        \"OpenCurlyDoubleQuote\":\"\\u201C\",\n        \"OpenCurlyQuote\":\"\\u2018\",\n        \"operp\":\"\\u29B9\",\n        \"oplus\":\"\\u2295\",\n        \"Or\":\"\\u2A54\",\n        \"or\":\"\\u2228\",\n        \"orarr\":\"\\u21BB\",\n        \"ord\":\"\\u2A5D\",\n        \"order\":\"\\u2134\",\n        \"orderof\":\"\\u2134\",\n        \"ordf\":\"\\u00AA\",\n        \"ordm\":\"\\u00BA\",\n        \"origof\":\"\\u22B6\",\n        \"oror\":\"\\u2A56\",\n        \"orslope\":\"\\u2A57\",\n        \"orv\":\"\\u2A5B\",\n        \"oS\":\"\\u24C8\",\n        \"Oscr\":\"\\uD835\\uDCAA\",\n        \"oscr\":\"\\u2134\",\n        \"Oslash\":\"\\u00D8\",\n        \"oslash\":\"\\u00F8\",\n        \"osol\":\"\\u2298\",\n        \"Otilde\":\"\\u00D5\",\n        \"otilde\":\"\\u00F5\",\n        \"Otimes\":\"\\u2A37\",\n        \"otimes\":\"\\u2297\",\n        \"otimesas\":\"\\u2A36\",\n        \"Ouml\":\"\\u00D6\",\n        \"ouml\":\"\\u00F6\",\n        \"ovbar\":\"\\u233D\",\n        \"OverBar\":\"\\u203E\",\n        \"OverBrace\":\"\\u23DE\",\n        \"OverBracket\":\"\\u23B4\",\n        \"OverParenthesis\":\"\\u23DC\",\n        \"par\":\"\\u2225\",\n        \"para\":\"\\u00B6\",\n        \"parallel\":\"\\u2225\",\n        \"parsim\":\"\\u2AF3\",\n        \"parsl\":\"\\u2AFD\",\n        \"part\":\"\\u2202\",\n        \"PartialD\":\"\\u2202\",\n        \"Pcy\":\"\\u041F\",\n        \"pcy\":\"\\u043F\",\n        \"percnt\":\"\\u0025\",\n        \"period\":\"\\u002E\",\n        \"permil\":\"\\u2030\",\n        \"perp\":\"\\u22A5\",\n        \"pertenk\":\"\\u2031\",\n        \"Pfr\":\"\\uD835\\uDD13\",\n        \"pfr\":\"\\uD835\\uDD2D\",\n        \"Phi\":\"\\u03A6\",\n        \"phi\":\"\\u03C6\",\n        \"phiv\":\"\\u03D5\",\n        \"phmmat\":\"\\u2133\",\n        \"phone\":\"\\u260E\",\n        \"Pi\":\"\\u03A0\",\n        \"pi\":\"\\u03C0\",\n        \"pitchfork\":\"\\u22D4\",\n        \"piv\":\"\\u03D6\",\n        \"planck\":\"\\u210F\",\n        \"planckh\":\"\\u210E\",\n        \"plankv\":\"\\u210F\",\n        \"plus\":\"\\u002B\",\n        \"plusacir\":\"\\u2A23\",\n        \"plusb\":\"\\u229E\",\n        \"pluscir\":\"\\u2A22\",\n        \"plusdo\":\"\\u2214\",\n        \"plusdu\":\"\\u2A25\",\n        \"pluse\":\"\\u2A72\",\n        \"PlusMinus\":\"\\u00B1\",\n        \"plusmn\":\"\\u00B1\",\n        \"plussim\":\"\\u2A26\",\n        \"plustwo\":\"\\u2A27\",\n        \"pm\":\"\\u00B1\",\n        \"Poincareplane\":\"\\u210C\",\n        \"pointint\":\"\\u2A15\",\n        \"Popf\":\"\\u2119\",\n        \"popf\":\"\\uD835\\uDD61\",\n        \"pound\":\"\\u00A3\",\n        \"Pr\":\"\\u2ABB\",\n        \"pr\":\"\\u227A\",\n        \"prap\":\"\\u2AB7\",\n        \"prcue\":\"\\u227C\",\n        \"prE\":\"\\u2AB3\",\n        \"pre\":\"\\u2AAF\",\n        \"prec\":\"\\u227A\",\n        \"precapprox\":\"\\u2AB7\",\n        \"preccurlyeq\":\"\\u227C\",\n        \"Precedes\":\"\\u227A\",\n        \"PrecedesEqual\":\"\\u2AAF\",\n        \"PrecedesSlantEqual\":\"\\u227C\",\n        \"PrecedesTilde\":\"\\u227E\",\n        \"preceq\":\"\\u2AAF\",\n        \"precnapprox\":\"\\u2AB9\",\n        \"precneqq\":\"\\u2AB5\",\n        \"precnsim\":\"\\u22E8\",\n        \"precsim\":\"\\u227E\",\n        \"Prime\":\"\\u2033\",\n        \"prime\":\"\\u2032\",\n        \"primes\":\"\\u2119\",\n        \"prnap\":\"\\u2AB9\",\n        \"prnE\":\"\\u2AB5\",\n        \"prnsim\":\"\\u22E8\",\n        \"prod\":\"\\u220F\",\n        \"Product\":\"\\u220F\",\n        \"profalar\":\"\\u232E\",\n        \"profline\":\"\\u2312\",\n        \"profsurf\":\"\\u2313\",\n        \"prop\":\"\\u221D\",\n        \"Proportion\":\"\\u2237\",\n        \"Proportional\":\"\\u221D\",\n        \"propto\":\"\\u221D\",\n        \"prsim\":\"\\u227E\",\n        \"prurel\":\"\\u22B0\",\n        \"Pscr\":\"\\uD835\\uDCAB\",\n        \"pscr\":\"\\uD835\\uDCC5\",\n        \"Psi\":\"\\u03A8\",\n        \"psi\":\"\\u03C8\",\n        \"puncsp\":\"\\u2008\",\n        \"Qfr\":\"\\uD835\\uDD14\",\n        \"qfr\":\"\\uD835\\uDD2E\",\n        \"qint\":\"\\u2A0C\",\n        \"Qopf\":\"\\u211A\",\n        \"qopf\":\"\\uD835\\uDD62\",\n        \"qprime\":\"\\u2057\",\n        \"Qscr\":\"\\uD835\\uDCAC\",\n        \"qscr\":\"\\uD835\\uDCC6\",\n        \"quaternions\":\"\\u210D\",\n        \"quatint\":\"\\u2A16\",\n        \"quest\":\"\\u003F\",\n        \"questeq\":\"\\u225F\",\n        \"QUOT\":\"\\u0022\",\n        \"quot\":\"\\u0022\",\n        \"rAarr\":\"\\u21DB\",\n        \"race\":\"\\u223D\\u0331\",\n        \"Racute\":\"\\u0154\",\n        \"racute\":\"\\u0155\",\n        \"radic\":\"\\u221A\",\n        \"raemptyv\":\"\\u29B3\",\n        \"Rang\":\"\\u27EB\",\n        \"rang\":\"\\u27E9\",\n        \"rangd\":\"\\u2992\",\n        \"range\":\"\\u29A5\",\n        \"rangle\":\"\\u27E9\",\n        \"raquo\":\"\\u00BB\",\n        \"Rarr\":\"\\u21A0\",\n        \"rArr\":\"\\u21D2\",\n        \"rarr\":\"\\u2192\",\n        \"rarrap\":\"\\u2975\",\n        \"rarrb\":\"\\u21E5\",\n        \"rarrbfs\":\"\\u2920\",\n        \"rarrc\":\"\\u2933\",\n        \"rarrfs\":\"\\u291E\",\n        \"rarrhk\":\"\\u21AA\",\n        \"rarrlp\":\"\\u21AC\",\n        \"rarrpl\":\"\\u2945\",\n        \"rarrsim\":\"\\u2974\",\n        \"Rarrtl\":\"\\u2916\",\n        \"rarrtl\":\"\\u21A3\",\n        \"rarrw\":\"\\u219D\",\n        \"rAtail\":\"\\u291C\",\n        \"ratail\":\"\\u291A\",\n        \"ratio\":\"\\u2236\",\n        \"rationals\":\"\\u211A\",\n        \"RBarr\":\"\\u2910\",\n        \"rBarr\":\"\\u290F\",\n        \"rbarr\":\"\\u290D\",\n        \"rbbrk\":\"\\u2773\",\n        \"rbrace\":\"\\u007D\",\n        \"rbrack\":\"\\u005D\",\n        \"rbrke\":\"\\u298C\",\n        \"rbrksld\":\"\\u298E\",\n        \"rbrkslu\":\"\\u2990\",\n        \"Rcaron\":\"\\u0158\",\n        \"rcaron\":\"\\u0159\",\n        \"Rcedil\":\"\\u0156\",\n        \"rcedil\":\"\\u0157\",\n        \"rceil\":\"\\u2309\",\n        \"rcub\":\"\\u007D\",\n        \"Rcy\":\"\\u0420\",\n        \"rcy\":\"\\u0440\",\n        \"rdca\":\"\\u2937\",\n        \"rdldhar\":\"\\u2969\",\n        \"rdquo\":\"\\u201D\",\n        \"rdquor\":\"\\u201D\",\n        \"rdsh\":\"\\u21B3\",\n        \"Re\":\"\\u211C\",\n        \"real\":\"\\u211C\",\n        \"realine\":\"\\u211B\",\n        \"realpart\":\"\\u211C\",\n        \"reals\":\"\\u211D\",\n        \"rect\":\"\\u25AD\",\n        \"REG\":\"\\u00AE\",\n        \"reg\":\"\\u00AE\",\n        \"ReverseElement\":\"\\u220B\",\n        \"ReverseEquilibrium\":\"\\u21CB\",\n        \"ReverseUpEquilibrium\":\"\\u296F\",\n        \"rfisht\":\"\\u297D\",\n        \"rfloor\":\"\\u230B\",\n        \"Rfr\":\"\\u211C\",\n        \"rfr\":\"\\uD835\\uDD2F\",\n        \"rHar\":\"\\u2964\",\n        \"rhard\":\"\\u21C1\",\n        \"rharu\":\"\\u21C0\",\n        \"rharul\":\"\\u296C\",\n        \"Rho\":\"\\u03A1\",\n        \"rho\":\"\\u03C1\",\n        \"rhov\":\"\\u03F1\",\n        \"RightAngleBracket\":\"\\u27E9\",\n        \"RightArrow\":\"\\u2192\",\n        \"Rightarrow\":\"\\u21D2\",\n        \"rightarrow\":\"\\u2192\",\n        \"RightArrowBar\":\"\\u21E5\",\n        \"RightArrowLeftArrow\":\"\\u21C4\",\n        \"rightarrowtail\":\"\\u21A3\",\n        \"RightCeiling\":\"\\u2309\",\n        \"RightDoubleBracket\":\"\\u27E7\",\n        \"RightDownTeeVector\":\"\\u295D\",\n        \"RightDownVector\":\"\\u21C2\",\n        \"RightDownVectorBar\":\"\\u2955\",\n        \"RightFloor\":\"\\u230B\",\n        \"rightharpoondown\":\"\\u21C1\",\n        \"rightharpoonup\":\"\\u21C0\",\n        \"rightleftarrows\":\"\\u21C4\",\n        \"rightleftharpoons\":\"\\u21CC\",\n        \"rightrightarrows\":\"\\u21C9\",\n        \"rightsquigarrow\":\"\\u219D\",\n        \"RightTee\":\"\\u22A2\",\n        \"RightTeeArrow\":\"\\u21A6\",\n        \"RightTeeVector\":\"\\u295B\",\n        \"rightthreetimes\":\"\\u22CC\",\n        \"RightTriangle\":\"\\u22B3\",\n        \"RightTriangleBar\":\"\\u29D0\",\n        \"RightTriangleEqual\":\"\\u22B5\",\n        \"RightUpDownVector\":\"\\u294F\",\n        \"RightUpTeeVector\":\"\\u295C\",\n        \"RightUpVector\":\"\\u21BE\",\n        \"RightUpVectorBar\":\"\\u2954\",\n        \"RightVector\":\"\\u21C0\",\n        \"RightVectorBar\":\"\\u2953\",\n        \"ring\":\"\\u02DA\",\n        \"risingdotseq\":\"\\u2253\",\n        \"rlarr\":\"\\u21C4\",\n        \"rlhar\":\"\\u21CC\",\n        \"rlm\":\"\\u200F\",\n        \"rmoust\":\"\\u23B1\",\n        \"rmoustache\":\"\\u23B1\",\n        \"rnmid\":\"\\u2AEE\",\n        \"roang\":\"\\u27ED\",\n        \"roarr\":\"\\u21FE\",\n        \"robrk\":\"\\u27E7\",\n        \"ropar\":\"\\u2986\",\n        \"Ropf\":\"\\u211D\",\n        \"ropf\":\"\\uD835\\uDD63\",\n        \"roplus\":\"\\u2A2E\",\n        \"rotimes\":\"\\u2A35\",\n        \"RoundImplies\":\"\\u2970\",\n        \"rpar\":\"\\u0029\",\n        \"rpargt\":\"\\u2994\",\n        \"rppolint\":\"\\u2A12\",\n        \"rrarr\":\"\\u21C9\",\n        \"Rrightarrow\":\"\\u21DB\",\n        \"rsaquo\":\"\\u203A\",\n        \"Rscr\":\"\\u211B\",\n        \"rscr\":\"\\uD835\\uDCC7\",\n        \"Rsh\":\"\\u21B1\",\n        \"rsh\":\"\\u21B1\",\n        \"rsqb\":\"\\u005D\",\n        \"rsquo\":\"\\u2019\",\n        \"rsquor\":\"\\u2019\",\n        \"rthree\":\"\\u22CC\",\n        \"rtimes\":\"\\u22CA\",\n        \"rtri\":\"\\u25B9\",\n        \"rtrie\":\"\\u22B5\",\n        \"rtrif\":\"\\u25B8\",\n        \"rtriltri\":\"\\u29CE\",\n        \"RuleDelayed\":\"\\u29F4\",\n        \"ruluhar\":\"\\u2968\",\n        \"rx\":\"\\u211E\",\n        \"Sacute\":\"\\u015A\",\n        \"sacute\":\"\\u015B\",\n        \"sbquo\":\"\\u201A\",\n        \"Sc\":\"\\u2ABC\",\n        \"sc\":\"\\u227B\",\n        \"scap\":\"\\u2AB8\",\n        \"Scaron\":\"\\u0160\",\n        \"scaron\":\"\\u0161\",\n        \"sccue\":\"\\u227D\",\n        \"scE\":\"\\u2AB4\",\n        \"sce\":\"\\u2AB0\",\n        \"Scedil\":\"\\u015E\",\n        \"scedil\":\"\\u015F\",\n        \"Scirc\":\"\\u015C\",\n        \"scirc\":\"\\u015D\",\n        \"scnap\":\"\\u2ABA\",\n        \"scnE\":\"\\u2AB6\",\n        \"scnsim\":\"\\u22E9\",\n        \"scpolint\":\"\\u2A13\",\n        \"scsim\":\"\\u227F\",\n        \"Scy\":\"\\u0421\",\n        \"scy\":\"\\u0441\",\n        \"sdot\":\"\\u22C5\",\n        \"sdotb\":\"\\u22A1\",\n        \"sdote\":\"\\u2A66\",\n        \"searhk\":\"\\u2925\",\n        \"seArr\":\"\\u21D8\",\n        \"searr\":\"\\u2198\",\n        \"searrow\":\"\\u2198\",\n        \"sect\":\"\\u00A7\",\n        \"semi\":\"\\u003B\",\n        \"seswar\":\"\\u2929\",\n        \"setminus\":\"\\u2216\",\n        \"setmn\":\"\\u2216\",\n        \"sext\":\"\\u2736\",\n        \"Sfr\":\"\\uD835\\uDD16\",\n        \"sfr\":\"\\uD835\\uDD30\",\n        \"sfrown\":\"\\u2322\",\n        \"sharp\":\"\\u266F\",\n        \"SHCHcy\":\"\\u0429\",\n        \"shchcy\":\"\\u0449\",\n        \"SHcy\":\"\\u0428\",\n        \"shcy\":\"\\u0448\",\n        \"ShortDownArrow\":\"\\u2193\",\n        \"ShortLeftArrow\":\"\\u2190\",\n        \"shortmid\":\"\\u2223\",\n        \"shortparallel\":\"\\u2225\",\n        \"ShortRightArrow\":\"\\u2192\",\n        \"ShortUpArrow\":\"\\u2191\",\n        \"shy\":\"\\u00AD\",\n        \"Sigma\":\"\\u03A3\",\n        \"sigma\":\"\\u03C3\",\n        \"sigmaf\":\"\\u03C2\",\n        \"sigmav\":\"\\u03C2\",\n        \"sim\":\"\\u223C\",\n        \"simdot\":\"\\u2A6A\",\n        \"sime\":\"\\u2243\",\n        \"simeq\":\"\\u2243\",\n        \"simg\":\"\\u2A9E\",\n        \"simgE\":\"\\u2AA0\",\n        \"siml\":\"\\u2A9D\",\n        \"simlE\":\"\\u2A9F\",\n        \"simne\":\"\\u2246\",\n        \"simplus\":\"\\u2A24\",\n        \"simrarr\":\"\\u2972\",\n        \"slarr\":\"\\u2190\",\n        \"SmallCircle\":\"\\u2218\",\n        \"smallsetminus\":\"\\u2216\",\n        \"smashp\":\"\\u2A33\",\n        \"smeparsl\":\"\\u29E4\",\n        \"smid\":\"\\u2223\",\n        \"smile\":\"\\u2323\",\n        \"smt\":\"\\u2AAA\",\n        \"smte\":\"\\u2AAC\",\n        \"smtes\":\"\\u2AAC\\uFE00\",\n        \"SOFTcy\":\"\\u042C\",\n        \"softcy\":\"\\u044C\",\n        \"sol\":\"\\u002F\",\n        \"solb\":\"\\u29C4\",\n        \"solbar\":\"\\u233F\",\n        \"Sopf\":\"\\uD835\\uDD4A\",\n        \"sopf\":\"\\uD835\\uDD64\",\n        \"spades\":\"\\u2660\",\n        \"spadesuit\":\"\\u2660\",\n        \"spar\":\"\\u2225\",\n        \"sqcap\":\"\\u2293\",\n        \"sqcaps\":\"\\u2293\\uFE00\",\n        \"sqcup\":\"\\u2294\",\n        \"sqcups\":\"\\u2294\\uFE00\",\n        \"Sqrt\":\"\\u221A\",\n        \"sqsub\":\"\\u228F\",\n        \"sqsube\":\"\\u2291\",\n        \"sqsubset\":\"\\u228F\",\n        \"sqsubseteq\":\"\\u2291\",\n        \"sqsup\":\"\\u2290\",\n        \"sqsupe\":\"\\u2292\",\n        \"sqsupset\":\"\\u2290\",\n        \"sqsupseteq\":\"\\u2292\",\n        \"squ\":\"\\u25A1\",\n        \"Square\":\"\\u25A1\",\n        \"square\":\"\\u25A1\",\n        \"SquareIntersection\":\"\\u2293\",\n        \"SquareSubset\":\"\\u228F\",\n        \"SquareSubsetEqual\":\"\\u2291\",\n        \"SquareSuperset\":\"\\u2290\",\n        \"SquareSupersetEqual\":\"\\u2292\",\n        \"SquareUnion\":\"\\u2294\",\n        \"squarf\":\"\\u25AA\",\n        \"squf\":\"\\u25AA\",\n        \"srarr\":\"\\u2192\",\n        \"Sscr\":\"\\uD835\\uDCAE\",\n        \"sscr\":\"\\uD835\\uDCC8\",\n        \"ssetmn\":\"\\u2216\",\n        \"ssmile\":\"\\u2323\",\n        \"sstarf\":\"\\u22C6\",\n        \"Star\":\"\\u22C6\",\n        \"star\":\"\\u2606\",\n        \"starf\":\"\\u2605\",\n        \"straightepsilon\":\"\\u03F5\",\n        \"straightphi\":\"\\u03D5\",\n        \"strns\":\"\\u00AF\",\n        \"Sub\":\"\\u22D0\",\n        \"sub\":\"\\u2282\",\n        \"subdot\":\"\\u2ABD\",\n        \"subE\":\"\\u2AC5\",\n        \"sube\":\"\\u2286\",\n        \"subedot\":\"\\u2AC3\",\n        \"submult\":\"\\u2AC1\",\n        \"subnE\":\"\\u2ACB\",\n        \"subne\":\"\\u228A\",\n        \"subplus\":\"\\u2ABF\",\n        \"subrarr\":\"\\u2979\",\n        \"Subset\":\"\\u22D0\",\n        \"subset\":\"\\u2282\",\n        \"subseteq\":\"\\u2286\",\n        \"subseteqq\":\"\\u2AC5\",\n        \"SubsetEqual\":\"\\u2286\",\n        \"subsetneq\":\"\\u228A\",\n        \"subsetneqq\":\"\\u2ACB\",\n        \"subsim\":\"\\u2AC7\",\n        \"subsub\":\"\\u2AD5\",\n        \"subsup\":\"\\u2AD3\",\n        \"succ\":\"\\u227B\",\n        \"succapprox\":\"\\u2AB8\",\n        \"succcurlyeq\":\"\\u227D\",\n        \"Succeeds\":\"\\u227B\",\n        \"SucceedsEqual\":\"\\u2AB0\",\n        \"SucceedsSlantEqual\":\"\\u227D\",\n        \"SucceedsTilde\":\"\\u227F\",\n        \"succeq\":\"\\u2AB0\",\n        \"succnapprox\":\"\\u2ABA\",\n        \"succneqq\":\"\\u2AB6\",\n        \"succnsim\":\"\\u22E9\",\n        \"succsim\":\"\\u227F\",\n        \"SuchThat\":\"\\u220B\",\n        \"Sum\":\"\\u2211\",\n        \"sum\":\"\\u2211\",\n        \"sung\":\"\\u266A\",\n        \"Sup\":\"\\u22D1\",\n        \"sup\":\"\\u2283\",\n        \"sup1\":\"\\u00B9\",\n        \"sup2\":\"\\u00B2\",\n        \"sup3\":\"\\u00B3\",\n        \"supdot\":\"\\u2ABE\",\n        \"supdsub\":\"\\u2AD8\",\n        \"supE\":\"\\u2AC6\",\n        \"supe\":\"\\u2287\",\n        \"supedot\":\"\\u2AC4\",\n        \"Superset\":\"\\u2283\",\n        \"SupersetEqual\":\"\\u2287\",\n        \"suphsol\":\"\\u27C9\",\n        \"suphsub\":\"\\u2AD7\",\n        \"suplarr\":\"\\u297B\",\n        \"supmult\":\"\\u2AC2\",\n        \"supnE\":\"\\u2ACC\",\n        \"supne\":\"\\u228B\",\n        \"supplus\":\"\\u2AC0\",\n        \"Supset\":\"\\u22D1\",\n        \"supset\":\"\\u2283\",\n        \"supseteq\":\"\\u2287\",\n        \"supseteqq\":\"\\u2AC6\",\n        \"supsetneq\":\"\\u228B\",\n        \"supsetneqq\":\"\\u2ACC\",\n        \"supsim\":\"\\u2AC8\",\n        \"supsub\":\"\\u2AD4\",\n        \"supsup\":\"\\u2AD6\",\n        \"swarhk\":\"\\u2926\",\n        \"swArr\":\"\\u21D9\",\n        \"swarr\":\"\\u2199\",\n        \"swarrow\":\"\\u2199\",\n        \"swnwar\":\"\\u292A\",\n        \"szlig\":\"\\u00DF\",\n        \"Tab\":\"\\u0009\",\n        \"target\":\"\\u2316\",\n        \"Tau\":\"\\u03A4\",\n        \"tau\":\"\\u03C4\",\n        \"tbrk\":\"\\u23B4\",\n        \"Tcaron\":\"\\u0164\",\n        \"tcaron\":\"\\u0165\",\n        \"Tcedil\":\"\\u0162\",\n        \"tcedil\":\"\\u0163\",\n        \"Tcy\":\"\\u0422\",\n        \"tcy\":\"\\u0442\",\n        \"tdot\":\"\\u20DB\",\n        \"telrec\":\"\\u2315\",\n        \"Tfr\":\"\\uD835\\uDD17\",\n        \"tfr\":\"\\uD835\\uDD31\",\n        \"there4\":\"\\u2234\",\n        \"Therefore\":\"\\u2234\",\n        \"therefore\":\"\\u2234\",\n        \"Theta\":\"\\u0398\",\n        \"theta\":\"\\u03B8\",\n        \"thetasym\":\"\\u03D1\",\n        \"thetav\":\"\\u03D1\",\n        \"thickapprox\":\"\\u2248\",\n        \"thicksim\":\"\\u223C\",\n        \"ThickSpace\":\"\\u205F\\u200A\",\n        \"thinsp\":\"\\u2009\",\n        \"ThinSpace\":\"\\u2009\",\n        \"thkap\":\"\\u2248\",\n        \"thksim\":\"\\u223C\",\n        \"THORN\":\"\\u00DE\",\n        \"thorn\":\"\\u00FE\",\n        \"Tilde\":\"\\u223C\",\n        \"tilde\":\"\\u02DC\",\n        \"TildeEqual\":\"\\u2243\",\n        \"TildeFullEqual\":\"\\u2245\",\n        \"TildeTilde\":\"\\u2248\",\n        \"times\":\"\\u00D7\",\n        \"timesb\":\"\\u22A0\",\n        \"timesbar\":\"\\u2A31\",\n        \"timesd\":\"\\u2A30\",\n        \"tint\":\"\\u222D\",\n        \"toea\":\"\\u2928\",\n        \"top\":\"\\u22A4\",\n        \"topbot\":\"\\u2336\",\n        \"topcir\":\"\\u2AF1\",\n        \"Topf\":\"\\uD835\\uDD4B\",\n        \"topf\":\"\\uD835\\uDD65\",\n        \"topfork\":\"\\u2ADA\",\n        \"tosa\":\"\\u2929\",\n        \"tprime\":\"\\u2034\",\n        \"TRADE\":\"\\u2122\",\n        \"trade\":\"\\u2122\",\n        \"triangle\":\"\\u25B5\",\n        \"triangledown\":\"\\u25BF\",\n        \"triangleleft\":\"\\u25C3\",\n        \"trianglelefteq\":\"\\u22B4\",\n        \"triangleq\":\"\\u225C\",\n        \"triangleright\":\"\\u25B9\",\n        \"trianglerighteq\":\"\\u22B5\",\n        \"tridot\":\"\\u25EC\",\n        \"trie\":\"\\u225C\",\n        \"triminus\":\"\\u2A3A\",\n        \"TripleDot\":\"\\u20DB\",\n        \"triplus\":\"\\u2A39\",\n        \"trisb\":\"\\u29CD\",\n        \"tritime\":\"\\u2A3B\",\n        \"trpezium\":\"\\u23E2\",\n        \"Tscr\":\"\\uD835\\uDCAF\",\n        \"tscr\":\"\\uD835\\uDCC9\",\n        \"TScy\":\"\\u0426\",\n        \"tscy\":\"\\u0446\",\n        \"TSHcy\":\"\\u040B\",\n        \"tshcy\":\"\\u045B\",\n        \"Tstrok\":\"\\u0166\",\n        \"tstrok\":\"\\u0167\",\n        \"twixt\":\"\\u226C\",\n        \"twoheadleftarrow\":\"\\u219E\",\n        \"twoheadrightarrow\":\"\\u21A0\",\n        \"Uacute\":\"\\u00DA\",\n        \"uacute\":\"\\u00FA\",\n        \"Uarr\":\"\\u219F\",\n        \"uArr\":\"\\u21D1\",\n        \"uarr\":\"\\u2191\",\n        \"Uarrocir\":\"\\u2949\",\n        \"Ubrcy\":\"\\u040E\",\n        \"ubrcy\":\"\\u045E\",\n        \"Ubreve\":\"\\u016C\",\n        \"ubreve\":\"\\u016D\",\n        \"Ucirc\":\"\\u00DB\",\n        \"ucirc\":\"\\u00FB\",\n        \"Ucy\":\"\\u0423\",\n        \"ucy\":\"\\u0443\",\n        \"udarr\":\"\\u21C5\",\n        \"Udblac\":\"\\u0170\",\n        \"udblac\":\"\\u0171\",\n        \"udhar\":\"\\u296E\",\n        \"ufisht\":\"\\u297E\",\n        \"Ufr\":\"\\uD835\\uDD18\",\n        \"ufr\":\"\\uD835\\uDD32\",\n        \"Ugrave\":\"\\u00D9\",\n        \"ugrave\":\"\\u00F9\",\n        \"uHar\":\"\\u2963\",\n        \"uharl\":\"\\u21BF\",\n        \"uharr\":\"\\u21BE\",\n        \"uhblk\":\"\\u2580\",\n        \"ulcorn\":\"\\u231C\",\n        \"ulcorner\":\"\\u231C\",\n        \"ulcrop\":\"\\u230F\",\n        \"ultri\":\"\\u25F8\",\n        \"Umacr\":\"\\u016A\",\n        \"umacr\":\"\\u016B\",\n        \"uml\":\"\\u00A8\",\n        \"UnderBar\":\"\\u005F\",\n        \"UnderBrace\":\"\\u23DF\",\n        \"UnderBracket\":\"\\u23B5\",\n        \"UnderParenthesis\":\"\\u23DD\",\n        \"Union\":\"\\u22C3\",\n        \"UnionPlus\":\"\\u228E\",\n        \"Uogon\":\"\\u0172\",\n        \"uogon\":\"\\u0173\",\n        \"Uopf\":\"\\uD835\\uDD4C\",\n        \"uopf\":\"\\uD835\\uDD66\",\n        \"UpArrow\":\"\\u2191\",\n        \"Uparrow\":\"\\u21D1\",\n        \"uparrow\":\"\\u2191\",\n        \"UpArrowBar\":\"\\u2912\",\n        \"UpArrowDownArrow\":\"\\u21C5\",\n        \"UpDownArrow\":\"\\u2195\",\n        \"Updownarrow\":\"\\u21D5\",\n        \"updownarrow\":\"\\u2195\",\n        \"UpEquilibrium\":\"\\u296E\",\n        \"upharpoonleft\":\"\\u21BF\",\n        \"upharpoonright\":\"\\u21BE\",\n        \"uplus\":\"\\u228E\",\n        \"UpperLeftArrow\":\"\\u2196\",\n        \"UpperRightArrow\":\"\\u2197\",\n        \"Upsi\":\"\\u03D2\",\n        \"upsi\":\"\\u03C5\",\n        \"upsih\":\"\\u03D2\",\n        \"Upsilon\":\"\\u03A5\",\n        \"upsilon\":\"\\u03C5\",\n        \"UpTee\":\"\\u22A5\",\n        \"UpTeeArrow\":\"\\u21A5\",\n        \"upuparrows\":\"\\u21C8\",\n        \"urcorn\":\"\\u231D\",\n        \"urcorner\":\"\\u231D\",\n        \"urcrop\":\"\\u230E\",\n        \"Uring\":\"\\u016E\",\n        \"uring\":\"\\u016F\",\n        \"urtri\":\"\\u25F9\",\n        \"Uscr\":\"\\uD835\\uDCB0\",\n        \"uscr\":\"\\uD835\\uDCCA\",\n        \"utdot\":\"\\u22F0\",\n        \"Utilde\":\"\\u0168\",\n        \"utilde\":\"\\u0169\",\n        \"utri\":\"\\u25B5\",\n        \"utrif\":\"\\u25B4\",\n        \"uuarr\":\"\\u21C8\",\n        \"Uuml\":\"\\u00DC\",\n        \"uuml\":\"\\u00FC\",\n        \"uwangle\":\"\\u29A7\",\n        \"vangrt\":\"\\u299C\",\n        \"varepsilon\":\"\\u03F5\",\n        \"varkappa\":\"\\u03F0\",\n        \"varnothing\":\"\\u2205\",\n        \"varphi\":\"\\u03D5\",\n        \"varpi\":\"\\u03D6\",\n        \"varpropto\":\"\\u221D\",\n        \"vArr\":\"\\u21D5\",\n        \"varr\":\"\\u2195\",\n        \"varrho\":\"\\u03F1\",\n        \"varsigma\":\"\\u03C2\",\n        \"varsubsetneq\":\"\\u228A\\uFE00\",\n        \"varsubsetneqq\":\"\\u2ACB\\uFE00\",\n        \"varsupsetneq\":\"\\u228B\\uFE00\",\n        \"varsupsetneqq\":\"\\u2ACC\\uFE00\",\n        \"vartheta\":\"\\u03D1\",\n        \"vartriangleleft\":\"\\u22B2\",\n        \"vartriangleright\":\"\\u22B3\",\n        \"Vbar\":\"\\u2AEB\",\n        \"vBar\":\"\\u2AE8\",\n        \"vBarv\":\"\\u2AE9\",\n        \"Vcy\":\"\\u0412\",\n        \"vcy\":\"\\u0432\",\n        \"VDash\":\"\\u22AB\",\n        \"Vdash\":\"\\u22A9\",\n        \"vDash\":\"\\u22A8\",\n        \"vdash\":\"\\u22A2\",\n        \"Vdashl\":\"\\u2AE6\",\n        \"Vee\":\"\\u22C1\",\n        \"vee\":\"\\u2228\",\n        \"veebar\":\"\\u22BB\",\n        \"veeeq\":\"\\u225A\",\n        \"vellip\":\"\\u22EE\",\n        \"Verbar\":\"\\u2016\",\n        \"verbar\":\"\\u007C\",\n        \"Vert\":\"\\u2016\",\n        \"vert\":\"\\u007C\",\n        \"VerticalBar\":\"\\u2223\",\n        \"VerticalLine\":\"\\u007C\",\n        \"VerticalSeparator\":\"\\u2758\",\n        \"VerticalTilde\":\"\\u2240\",\n        \"VeryThinSpace\":\"\\u200A\",\n        \"Vfr\":\"\\uD835\\uDD19\",\n        \"vfr\":\"\\uD835\\uDD33\",\n        \"vltri\":\"\\u22B2\",\n        \"vnsub\":\"\\u2282\\u20D2\",\n        \"vnsup\":\"\\u2283\\u20D2\",\n        \"Vopf\":\"\\uD835\\uDD4D\",\n        \"vopf\":\"\\uD835\\uDD67\",\n        \"vprop\":\"\\u221D\",\n        \"vrtri\":\"\\u22B3\",\n        \"Vscr\":\"\\uD835\\uDCB1\",\n        \"vscr\":\"\\uD835\\uDCCB\",\n        \"vsubnE\":\"\\u2ACB\\uFE00\",\n        \"vsubne\":\"\\u228A\\uFE00\",\n        \"vsupnE\":\"\\u2ACC\\uFE00\",\n        \"vsupne\":\"\\u228B\\uFE00\",\n        \"Vvdash\":\"\\u22AA\",\n        \"vzigzag\":\"\\u299A\",\n        \"Wcirc\":\"\\u0174\",\n        \"wcirc\":\"\\u0175\",\n        \"wedbar\":\"\\u2A5F\",\n        \"Wedge\":\"\\u22C0\",\n        \"wedge\":\"\\u2227\",\n        \"wedgeq\":\"\\u2259\",\n        \"weierp\":\"\\u2118\",\n        \"Wfr\":\"\\uD835\\uDD1A\",\n        \"wfr\":\"\\uD835\\uDD34\",\n        \"Wopf\":\"\\uD835\\uDD4E\",\n        \"wopf\":\"\\uD835\\uDD68\",\n        \"wp\":\"\\u2118\",\n        \"wr\":\"\\u2240\",\n        \"wreath\":\"\\u2240\",\n        \"Wscr\":\"\\uD835\\uDCB2\",\n        \"wscr\":\"\\uD835\\uDCCC\",\n        \"xcap\":\"\\u22C2\",\n        \"xcirc\":\"\\u25EF\",\n        \"xcup\":\"\\u22C3\",\n        \"xdtri\":\"\\u25BD\",\n        \"Xfr\":\"\\uD835\\uDD1B\",\n        \"xfr\":\"\\uD835\\uDD35\",\n        \"xhArr\":\"\\u27FA\",\n        \"xharr\":\"\\u27F7\",\n        \"Xi\":\"\\u039E\",\n        \"xi\":\"\\u03BE\",\n        \"xlArr\":\"\\u27F8\",\n        \"xlarr\":\"\\u27F5\",\n        \"xmap\":\"\\u27FC\",\n        \"xnis\":\"\\u22FB\",\n        \"xodot\":\"\\u2A00\",\n        \"Xopf\":\"\\uD835\\uDD4F\",\n        \"xopf\":\"\\uD835\\uDD69\",\n        \"xoplus\":\"\\u2A01\",\n        \"xotime\":\"\\u2A02\",\n        \"xrArr\":\"\\u27F9\",\n        \"xrarr\":\"\\u27F6\",\n        \"Xscr\":\"\\uD835\\uDCB3\",\n        \"xscr\":\"\\uD835\\uDCCD\",\n        \"xsqcup\":\"\\u2A06\",\n        \"xuplus\":\"\\u2A04\",\n        \"xutri\":\"\\u25B3\",\n        \"xvee\":\"\\u22C1\",\n        \"xwedge\":\"\\u22C0\",\n        \"Yacute\":\"\\u00DD\",\n        \"yacute\":\"\\u00FD\",\n        \"YAcy\":\"\\u042F\",\n        \"yacy\":\"\\u044F\",\n        \"Ycirc\":\"\\u0176\",\n        \"ycirc\":\"\\u0177\",\n        \"Ycy\":\"\\u042B\",\n        \"ycy\":\"\\u044B\",\n        \"yen\":\"\\u00A5\",\n        \"Yfr\":\"\\uD835\\uDD1C\",\n        \"yfr\":\"\\uD835\\uDD36\",\n        \"YIcy\":\"\\u0407\",\n        \"yicy\":\"\\u0457\",\n        \"Yopf\":\"\\uD835\\uDD50\",\n        \"yopf\":\"\\uD835\\uDD6A\",\n        \"Yscr\":\"\\uD835\\uDCB4\",\n        \"yscr\":\"\\uD835\\uDCCE\",\n        \"YUcy\":\"\\u042E\",\n        \"yucy\":\"\\u044E\",\n        \"Yuml\":\"\\u0178\",\n        \"yuml\":\"\\u00FF\",\n        \"Zacute\":\"\\u0179\",\n        \"zacute\":\"\\u017A\",\n        \"Zcaron\":\"\\u017D\",\n        \"zcaron\":\"\\u017E\",\n        \"Zcy\":\"\\u0417\",\n        \"zcy\":\"\\u0437\",\n        \"Zdot\":\"\\u017B\",\n        \"zdot\":\"\\u017C\",\n        \"zeetrf\":\"\\u2128\",\n        \"ZeroWidthSpace\":\"\\u200B\",\n        \"Zeta\":\"\\u0396\",\n        \"zeta\":\"\\u03B6\",\n        \"Zfr\":\"\\u2128\",\n        \"zfr\":\"\\uD835\\uDD37\",\n        \"ZHcy\":\"\\u0416\",\n        \"zhcy\":\"\\u0436\",\n        \"zigrarr\":\"\\u21DD\",\n        \"Zopf\":\"\\u2124\",\n        \"zopf\":\"\\uD835\\uDD6B\",\n        \"Zscr\":\"\\uD835\\uDCB5\",\n        \"zscr\":\"\\uD835\\uDCCF\",\n        \"zwj\":\"\\u200D\",\n        \"zwnj\":\"\\u200C\"\n    };\n\n},{}],2:[function(require,module,exports){\n// List of valid html blocks names, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\n    'use strict';\n\n    var html_blocks = {};\n\n    [\n        'article',\n        'aside',\n        'button',\n        'blockquote',\n        'body',\n        'canvas',\n        'caption',\n        'col',\n        'colgroup',\n        'dd',\n        'div',\n        'dl',\n        'dt',\n        'embed',\n        'fieldset',\n        'figcaption',\n        'figure',\n        'footer',\n        'form',\n        'h1',\n        'h2',\n        'h3',\n        'h4',\n        'h5',\n        'h6',\n        'header',\n        'hgroup',\n        'hr',\n        'iframe',\n        'li',\n        'map',\n        'object',\n        'ol',\n        'output',\n        'p',\n        'pre',\n        'progress',\n        'script',\n        'section',\n        'style',\n        'table',\n        'tbody',\n        'td',\n        'textarea',\n        'tfoot',\n        'th',\n        'tr',\n        'thead',\n        'ul',\n        'video'\n    ].forEach(function (name) { html_blocks[name] = true; });\n\n\n    module.exports = html_blocks;\n\n},{}],3:[function(require,module,exports){\n// Regexps to match html elements\n\n    'use strict';\n\n\n    function replace(regex, options) {\n        regex = regex.source;\n        options = options || '';\n\n        return function self(name, val) {\n            if (!name) {\n                return new RegExp(regex, options);\n            }\n            val = val.source || val;\n            regex = regex.replace(name, val);\n            return self;\n        };\n    }\n\n\n    var attr_name     = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;\n\n    var unquoted      = /[^\"'=<>`\\x00-\\x20]+/;\n    var single_quoted = /'[^']*'/;\n    var double_quoted = /\"[^\"]*\"/;\n\n    /*eslint no-spaced-func:0*/\n    var attr_value  = replace(/(?:unquoted|single_quoted|double_quoted)/)\n    ('unquoted', unquoted)\n    ('single_quoted', single_quoted)\n    ('double_quoted', double_quoted)\n    ();\n\n    var attribute   = replace(/(?:\\s+attr_name(?:\\s*=\\s*attr_value)?)/)\n    ('attr_name', attr_name)\n    ('attr_value', attr_value)\n    ();\n\n    var open_tag    = replace(/<[A-Za-z][A-Za-z0-9]*attribute*\\s*\\/?>/)\n    ('attribute', attribute)\n    ();\n\n    var close_tag   = /<\\/[A-Za-z][A-Za-z0-9]*\\s*>/;\n    var comment     = /<!--([^-]+|[-][^-]+)*-->/;\n    var processing  = /<[?].*?[?]>/;\n    var declaration = /<![A-Z]+\\s+[^>]*>/;\n    var cdata       = /<!\\[CDATA\\[([^\\]]+|\\][^\\]]|\\]\\][^>])*\\]\\]>/;\n\n    var HTML_TAG_RE = replace(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)\n    ('open_tag', open_tag)\n    ('close_tag', close_tag)\n    ('comment', comment)\n    ('processing', processing)\n    ('declaration', declaration)\n    ('cdata', cdata)\n    ();\n\n\n    module.exports.HTML_TAG_RE = HTML_TAG_RE;\n\n},{}],4:[function(require,module,exports){\n// List of valid url schemas, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#autolinks\n\n    'use strict';\n\n\n    module.exports = [\n        'coap',\n        'doi',\n        'javascript',\n        'aaa',\n        'aaas',\n        'about',\n        'acap',\n        'cap',\n        'cid',\n        'crid',\n        'data',\n        'dav',\n        'dict',\n        'dns',\n        'file',\n        'ftp',\n        'geo',\n        'go',\n        'gopher',\n        'h323',\n        'http',\n        'https',\n        'iax',\n        'icap',\n        'im',\n        'imap',\n        'info',\n        'ipp',\n        'iris',\n        'iris.beep',\n        'iris.xpc',\n        'iris.xpcs',\n        'iris.lwz',\n        'ldap',\n        'mailto',\n        'mid',\n        'msrp',\n        'msrps',\n        'mtqp',\n        'mupdate',\n        'news',\n        'nfs',\n        'ni',\n        'nih',\n        'nntp',\n        'opaquelocktoken',\n        'pop',\n        'pres',\n        'rtsp',\n        'service',\n        'session',\n        'shttp',\n        'sieve',\n        'sip',\n        'sips',\n        'sms',\n        'snmp',\n        'soap.beep',\n        'soap.beeps',\n        'tag',\n        'tel',\n        'telnet',\n        'tftp',\n        'thismessage',\n        'tn3270',\n        'tip',\n        'tv',\n        'urn',\n        'vemmi',\n        'ws',\n        'wss',\n        'xcon',\n        'xcon-userid',\n        'xmlrpc.beep',\n        'xmlrpc.beeps',\n        'xmpp',\n        'z39.50r',\n        'z39.50s',\n        'adiumxtra',\n        'afp',\n        'afs',\n        'aim',\n        'apt',\n        'attachment',\n        'aw',\n        'beshare',\n        'bitcoin',\n        'bolo',\n        'callto',\n        'chrome',\n        'chrome-extension',\n        'com-eventbrite-attendee',\n        'content',\n        'cvs',\n        'dlna-playsingle',\n        'dlna-playcontainer',\n        'dtn',\n        'dvb',\n        'ed2k',\n        'facetime',\n        'feed',\n        'finger',\n        'fish',\n        'gg',\n        'git',\n        'gizmoproject',\n        'gtalk',\n        'hcp',\n        'icon',\n        'ipn',\n        'irc',\n        'irc6',\n        'ircs',\n        'itms',\n        'jar',\n        'jms',\n        'keyparc',\n        'lastfm',\n        'ldaps',\n        'magnet',\n        'maps',\n        'market',\n        'message',\n        'mms',\n        'ms-help',\n        'msnim',\n        'mumble',\n        'mvn',\n        'notes',\n        'oid',\n        'palm',\n        'paparazzi',\n        'platform',\n        'proxy',\n        'psyc',\n        'query',\n        'res',\n        'resource',\n        'rmi',\n        'rsync',\n        'rtmp',\n        'secondlife',\n        'sftp',\n        'sgn',\n        'skype',\n        'smb',\n        'soldat',\n        'spotify',\n        'ssh',\n        'steam',\n        'svn',\n        'teamspeak',\n        'things',\n        'udp',\n        'unreal',\n        'ut2004',\n        'ventrilo',\n        'view-source',\n        'webcal',\n        'wtai',\n        'wyciwyg',\n        'xfire',\n        'xri',\n        'ymsgr'\n    ];\n\n},{}],5:[function(require,module,exports){\n    'use strict';\n\n    /**\n     * Utility functions\n     */\n\n    function typeOf(obj) {\n        return Object.prototype.toString.call(obj);\n    }\n\n    function isString(obj) {\n        return typeOf(obj) === '[object String]';\n    }\n\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    function has(object, key) {\n        return object\n            ? hasOwn.call(object, key)\n            : false;\n    }\n\n// Extend objects\n//\n    function assign(obj /*from1, from2, from3, ...*/) {\n        var sources = [].slice.call(arguments, 1);\n\n        sources.forEach(function (source) {\n            if (!source) { return; }\n\n            if (typeof source !== 'object') {\n                throw new TypeError(source + 'must be object');\n            }\n\n            Object.keys(source).forEach(function (key) {\n                obj[key] = source[key];\n            });\n        });\n\n        return obj;\n    }\n\n////////////////////////////////////////////////////////////////////////////////\n\n    var UNESCAPE_MD_RE = /\\\\([\\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\n    function unescapeMd(str) {\n        if (str.indexOf('\\\\') < 0) { return str; }\n        return str.replace(UNESCAPE_MD_RE, '$1');\n    }\n\n////////////////////////////////////////////////////////////////////////////////\n\n    function isValidEntityCode(c) {\n        /*eslint no-bitwise:0*/\n        // broken sequence\n        if (c >= 0xD800 && c <= 0xDFFF) { return false; }\n        // never used\n        if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }\n        if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }\n        // control codes\n        if (c >= 0x00 && c <= 0x08) { return false; }\n        if (c === 0x0B) { return false; }\n        if (c >= 0x0E && c <= 0x1F) { return false; }\n        if (c >= 0x7F && c <= 0x9F) { return false; }\n        // out of range\n        if (c > 0x10FFFF) { return false; }\n        return true;\n    }\n\n    function fromCodePoint(c) {\n        /*eslint no-bitwise:0*/\n        if (c > 0xffff) {\n            c -= 0x10000;\n            var surrogate1 = 0xd800 + (c >> 10),\n                surrogate2 = 0xdc00 + (c & 0x3ff);\n\n            return String.fromCharCode(surrogate1, surrogate2);\n        }\n        return String.fromCharCode(c);\n    }\n\n    var NAMED_ENTITY_RE   = /&([a-z#][a-z0-9]{1,31});/gi;\n    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n    var entities = require('./entities');\n\n    function replaceEntityPattern(match, name) {\n        var code = 0;\n\n        if (has(entities, name)) {\n            return entities[name];\n        } else if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n            code = name[1].toLowerCase() === 'x' ?\n                parseInt(name.slice(2), 16)\n                :\n                parseInt(name.slice(1), 10);\n            if (isValidEntityCode(code)) {\n                return fromCodePoint(code);\n            }\n        }\n        return match;\n    }\n\n    function replaceEntities(str) {\n        if (str.indexOf('&') < 0) { return str; }\n\n        return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);\n    }\n\n////////////////////////////////////////////////////////////////////////////////\n\n    var HTML_ESCAPE_TEST_RE = /[&<>\"]/;\n    var HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\n    var HTML_REPLACEMENTS = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;'\n    };\n\n    function replaceUnsafeChar(ch) {\n        return HTML_REPLACEMENTS[ch];\n    }\n\n    function escapeHtml(str) {\n        if (HTML_ESCAPE_TEST_RE.test(str)) {\n            return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n        }\n        return str;\n    }\n\n////////////////////////////////////////////////////////////////////////////////\n\n    exports.assign            = assign;\n    exports.isString          = isString;\n    exports.has               = has;\n    exports.unescapeMd        = unescapeMd;\n    exports.isValidEntityCode = isValidEntityCode;\n    exports.fromCodePoint     = fromCodePoint;\n    exports.replaceEntities   = replaceEntities;\n    exports.escapeHtml        = escapeHtml;\n\n},{\"./entities\":1}],6:[function(require,module,exports){\n// Commonmark default options\n\n    'use strict';\n\n\n    module.exports = {\n        options: {\n            html:         true,         // Enable HTML tags in source\n            xhtmlOut:     true,         // Use '/' to close single tags (<br />)\n            breaks:       false,        // Convert '\\n' in paragraphs into <br>\n            langPrefix:   'language-',  // CSS language prefix for fenced blocks\n            linkify:      false,        // autoconvert URL-like texts to links\n            linkTarget:   '',           // set target to open link in\n\n            // Enable some language-neutral replacements + quotes beautification\n            typographer:  false,\n\n            // Double + single quotes replacement pairs, when typographer enabled,\n            // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n            quotes: '“”‘’',\n\n            // Highlighter function. Should return escaped HTML,\n            // or '' if input not changed\n            //\n            // function (/*str, lang*/) { return ''; }\n            //\n            highlight: null,\n\n            maxNesting:   20            // Internal protection, recursion limit\n        },\n\n        components: {\n\n            core: {\n                rules: [\n                    'block',\n                    'inline',\n                    'references',\n                    'abbr2'\n                ]\n            },\n\n            block: {\n                rules: [\n                    'blockquote',\n                    'code',\n                    'fences',\n                    'heading',\n                    'hr',\n                    'htmlblock',\n                    'lheading',\n                    'list',\n                    'paragraph'\n                ]\n            },\n\n            inline: {\n                rules: [\n                    'autolink',\n                    'backticks',\n                    'emphasis',\n                    'entity',\n                    'escape',\n                    'htmltag',\n                    'links',\n                    'newline',\n                    'text'\n                ]\n            }\n        }\n    };\n\n},{}],7:[function(require,module,exports){\n// Remarkable default options\n\n    'use strict';\n\n\n    module.exports = {\n        options: {\n            html:         false,        // Enable HTML tags in source\n            xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n            breaks:       false,        // Convert '\\n' in paragraphs into <br>\n            langPrefix:   'language-',  // CSS language prefix for fenced blocks\n            linkify:      false,        // autoconvert URL-like texts to links\n            linkTarget:   '',           // set target to open link in\n\n            // Enable some language-neutral replacements + quotes beautification\n            typographer:  false,\n\n            // Double + single quotes replacement pairs, when typographer enabled,\n            // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n            quotes: '“”‘’',\n\n            // Highlighter function. Should return escaped HTML,\n            // or '' if input not changed\n            //\n            // function (/*str, lang*/) { return ''; }\n            //\n            highlight: null,\n\n            maxNesting:   20            // Internal protection, recursion limit\n        },\n\n        components: {\n\n            core: {\n                rules: [\n                    'block',\n                    'inline',\n                    'references',\n                    'replacements',\n                    'linkify',\n                    'smartquotes',\n                    'references',\n                    'abbr2',\n                    'footnote_tail'\n                ]\n            },\n\n            block: {\n                rules: [\n                    'blockquote',\n                    'code',\n                    'fences',\n                    'heading',\n                    'hr',\n                    'htmlblock',\n                    'lheading',\n                    'list',\n                    'paragraph',\n                    'table'\n                ]\n            },\n\n            inline: {\n                rules: [\n                    'autolink',\n                    'backticks',\n                    'del',\n                    'emphasis',\n                    'entity',\n                    'escape',\n                    'footnote_ref',\n                    'htmltag',\n                    'links',\n                    'newline',\n                    'text'\n                ]\n            }\n        }\n    };\n\n},{}],8:[function(require,module,exports){\n// Remarkable default options\n\n    'use strict';\n\n\n    module.exports = {\n        options: {\n            html:         false,        // Enable HTML tags in source\n            xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n            breaks:       false,        // Convert '\\n' in paragraphs into <br>\n            langPrefix:   'language-',  // CSS language prefix for fenced blocks\n            linkify:      false,        // autoconvert URL-like texts to links\n            linkTarget:   '',           // set target to open link in\n\n            // Enable some language-neutral replacements + quotes beautification\n            typographer:  false,\n\n            // Double + single quotes replacement pairs, when typographer enabled,\n            // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n            quotes:       '“”‘’',\n\n            // Highlighter function. Should return escaped HTML,\n            // or '' if input not changed\n            //\n            // function (/*str, lang*/) { return ''; }\n            //\n            highlight:     null,\n\n            maxNesting:    20            // Internal protection, recursion limit\n        },\n\n        components: {\n            // Don't restrict core/block/inline rules\n            core: {},\n            block: {},\n            inline: {}\n        }\n    };\n\n},{}],9:[function(require,module,exports){\n    'use strict';\n\n    var replaceEntities = require('../common/utils').replaceEntities;\n\n    module.exports = function normalizeLink(url) {\n        var normalized = replaceEntities(url);\n        // We shouldn't care about the result of malformed URIs,\n        // and should not throw an exception.\n        try {\n            normalized = decodeURI(normalized);\n        } catch (err) {}\n        return encodeURI(normalized);\n    };\n\n},{\"../common/utils\":5}],10:[function(require,module,exports){\n    'use strict';\n\n    module.exports = function normalizeReference(str) {\n        // use .toUpperCase() instead of .toLowerCase()\n        // here to avoid a conflict with Object.prototype\n        // members (most notably, `__proto__`)\n        return str.trim().replace(/\\s+/g, ' ').toUpperCase();\n    };\n\n},{}],11:[function(require,module,exports){\n    'use strict';\n\n\n    var normalizeLink = require('./normalize_link');\n    var unescapeMd    = require('../common/utils').unescapeMd;\n\n    /**\n     * Parse link destination\n     *\n     *   - on success it returns a string and updates state.pos;\n     *   - on failure it returns null\n     *\n     * @param  {Object} state\n     * @param  {Number} pos\n     * @api private\n     */\n\n    module.exports = function parseLinkDestination(state, pos) {\n        var code, level, link,\n            start = pos,\n            max = state.posMax;\n\n        if (state.src.charCodeAt(pos) === 0x3C /* < */) {\n            pos++;\n            while (pos < max) {\n                code = state.src.charCodeAt(pos);\n                if (code === 0x0A /* \\n */) { return false; }\n                if (code === 0x3E /* > */) {\n                    link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));\n                    if (!state.parser.validateLink(link)) { return false; }\n                    state.pos = pos + 1;\n                    state.linkContent = link;\n                    return true;\n                }\n                if (code === 0x5C /* \\ */ && pos + 1 < max) {\n                    pos += 2;\n                    continue;\n                }\n\n                pos++;\n            }\n\n            // no closing '>'\n            return false;\n        }\n\n        // this should be ... } else { ... branch\n\n        level = 0;\n        while (pos < max) {\n            code = state.src.charCodeAt(pos);\n\n            if (code === 0x20) { break; }\n\n            if (code > 0x08 && code < 0x0e) { break; }\n\n            if (code === 0x5C /* \\ */ && pos + 1 < max) {\n                pos += 2;\n                continue;\n            }\n\n            if (code === 0x28 /* ( */) {\n                level++;\n                if (level > 1) { break; }\n            }\n\n            if (code === 0x29 /* ) */) {\n                level--;\n                if (level < 0) { break; }\n            }\n\n            pos++;\n        }\n\n        if (start === pos) { return false; }\n\n        link = unescapeMd(state.src.slice(start, pos));\n        if (!state.parser.validateLink(link)) { return false; }\n\n        state.linkContent = link;\n        state.pos = pos;\n        return true;\n    };\n\n},{\"../common/utils\":5,\"./normalize_link\":9}],12:[function(require,module,exports){\n    'use strict';\n\n    /**\n     * Parse link labels\n     *\n     * This function assumes that first character (`[`) already matches;\n     * returns the end of the label.\n     *\n     * @param  {Object} state\n     * @param  {Number} start\n     * @api private\n     */\n\n    module.exports = function parseLinkLabel(state, start) {\n        var level, found, marker,\n            labelEnd = -1,\n            max = state.posMax,\n            oldPos = state.pos,\n            oldFlag = state.isInLabel;\n\n        if (state.isInLabel) { return -1; }\n\n        if (state.labelUnmatchedScopes) {\n            state.labelUnmatchedScopes--;\n            return -1;\n        }\n\n        state.pos = start + 1;\n        state.isInLabel = true;\n        level = 1;\n\n        while (state.pos < max) {\n            marker = state.src.charCodeAt(state.pos);\n            if (marker === 0x5B /* [ */) {\n                level++;\n            } else if (marker === 0x5D /* ] */) {\n                level--;\n                if (level === 0) {\n                    found = true;\n                    break;\n                }\n            }\n\n            state.parser.skipToken(state);\n        }\n\n        if (found) {\n            labelEnd = state.pos;\n            state.labelUnmatchedScopes = 0;\n        } else {\n            state.labelUnmatchedScopes = level - 1;\n        }\n\n        // restore old state\n        state.pos = oldPos;\n        state.isInLabel = oldFlag;\n\n        return labelEnd;\n    };\n\n},{}],13:[function(require,module,exports){\n    'use strict';\n\n\n    var unescapeMd = require('../common/utils').unescapeMd;\n\n    /**\n     * Parse link title\n     *\n     *   - on success it returns a string and updates state.pos;\n     *   - on failure it returns null\n     *\n     * @param  {Object} state\n     * @param  {Number} pos\n     * @api private\n     */\n\n    module.exports = function parseLinkTitle(state, pos) {\n        var code,\n            start = pos,\n            max = state.posMax,\n            marker = state.src.charCodeAt(pos);\n\n        if (marker !== 0x22 /* \" */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return false; }\n\n        pos++;\n\n        // if opening marker is \"(\", switch it to closing marker \")\"\n        if (marker === 0x28) { marker = 0x29; }\n\n        while (pos < max) {\n            code = state.src.charCodeAt(pos);\n            if (code === marker) {\n                state.pos = pos + 1;\n                state.linkContent = unescapeMd(state.src.slice(start + 1, pos));\n                return true;\n            }\n            if (code === 0x5C /* \\ */ && pos + 1 < max) {\n                pos += 2;\n                continue;\n            }\n\n            pos++;\n        }\n\n        return false;\n    };\n\n},{\"../common/utils\":5}],14:[function(require,module,exports){\n    'use strict';\n\n    /**\n     * Local dependencies\n     */\n\n    var assign       = require('./common/utils').assign;\n    var Renderer     = require('./renderer');\n    var ParserCore   = require('./parser_core');\n    var ParserBlock  = require('./parser_block');\n    var ParserInline = require('./parser_inline');\n    var Ruler        = require('./ruler');\n\n    /**\n     * Preset configs\n     */\n\n    var config = {\n        'default':    require('./configs/default'),\n        'full':       require('./configs/full'),\n        'commonmark': require('./configs/commonmark')\n    };\n\n    /**\n     * The `StateCore` class manages state.\n     *\n     * @param {Object} `instance` Remarkable instance\n     * @param {String} `str` Markdown string\n     * @param {Object} `env`\n     */\n\n    function StateCore(instance, str, env) {\n        this.src = str;\n        this.env = env;\n        this.options = instance.options;\n        this.tokens = [];\n        this.inlineMode = false;\n\n        this.inline = instance.inline;\n        this.block = instance.block;\n        this.renderer = instance.renderer;\n        this.typographer = instance.typographer;\n    }\n\n    /**\n     * The main `Remarkable` class. Create an instance of\n     * `Remarkable` with a `preset` and/or `options`.\n     *\n     * @param {String} `preset` If no preset is given, `default` is used.\n     * @param {Object} `options`\n     */\n\n    function Remarkable(preset, options) {\n        if (typeof preset !== 'string') {\n            options = preset;\n            preset = 'default';\n        }\n\n        this.inline   = new ParserInline();\n        this.block    = new ParserBlock();\n        this.core     = new ParserCore();\n        this.renderer = new Renderer();\n        this.ruler    = new Ruler();\n\n        this.options  = {};\n        this.configure(config[preset]);\n        this.set(options || {});\n    }\n\n    /**\n     * Set options as an alternative to passing them\n     * to the constructor.\n     *\n     * ```js\n     * md.set({typographer: true});\n     * ```\n     * @param {Object} `options`\n     * @api public\n     */\n\n    Remarkable.prototype.set = function (options) {\n        assign(this.options, options);\n    };\n\n    /**\n     * Batch loader for components rules states, and options\n     *\n     * @param  {Object} `presets`\n     */\n\n    Remarkable.prototype.configure = function (presets) {\n        var self = this;\n\n        if (!presets) { throw new Error('Wrong `remarkable` preset, check name/content'); }\n        if (presets.options) { self.set(presets.options); }\n        if (presets.components) {\n            Object.keys(presets.components).forEach(function (name) {\n                if (presets.components[name].rules) {\n                    self[name].ruler.enable(presets.components[name].rules, true);\n                }\n            });\n        }\n    };\n\n    /**\n     * Use a plugin.\n     *\n     * ```js\n     * var md = new Remarkable();\n     *\n     * md.use(plugin1)\n     *   .use(plugin2, opts)\n     *   .use(plugin3);\n     * ```\n     *\n     * @param  {Function} `plugin`\n     * @param  {Object} `options`\n     * @return {Object} `Remarkable` for chaining\n     */\n\n    Remarkable.prototype.use = function (plugin, options) {\n        plugin(this, options);\n        return this;\n    };\n\n\n    /**\n     * Parse the input `string` and return a tokens array.\n     * Modifies `env` with definitions data.\n     *\n     * @param  {String} `string`\n     * @param  {Object} `env`\n     * @return {Array} Array of tokens\n     */\n\n    Remarkable.prototype.parse = function (str, env) {\n        var state = new StateCore(this, str, env);\n        this.core.process(state);\n        return state.tokens;\n    };\n\n    /**\n     * The main `.render()` method that does all the magic :)\n     *\n     * @param  {String} `string`\n     * @param  {Object} `env`\n     * @return {String} Rendered HTML.\n     */\n\n    Remarkable.prototype.render = function (str, env) {\n        env = env || {};\n        return this.renderer.render(this.parse(str, env), this.options, env);\n    };\n\n    /**\n     * Parse the given content `string` as a single string.\n     *\n     * @param  {String} `string`\n     * @param  {Object} `env`\n     * @return {Array} Array of tokens\n     */\n\n    Remarkable.prototype.parseInline = function (str, env) {\n        var state = new StateCore(this, str, env);\n        state.inlineMode = true;\n        this.core.process(state);\n        return state.tokens;\n    };\n\n    /**\n     * Render a single content `string`, without wrapping it\n     * to paragraphs\n     *\n     * @param  {String} `str`\n     * @param  {Object} `env`\n     * @return {String}\n     */\n\n    Remarkable.prototype.renderInline = function (str, env) {\n        env = env || {};\n        return this.renderer.render(this.parseInline(str, env), this.options, env);\n    };\n\n    /**\n     * Expose `Remarkable`\n     */\n\n    module.exports = Remarkable;\n\n    /**\n     * Expose `utils`, Useful helper functions for custom\n     * rendering.\n     */\n\n    module.exports.utils = require('./common/utils');\n\n},{\"./common/utils\":5,\"./configs/commonmark\":6,\"./configs/default\":7,\"./configs/full\":8,\"./parser_block\":15,\"./parser_core\":16,\"./parser_inline\":17,\"./renderer\":18,\"./ruler\":19}],15:[function(require,module,exports){\n    'use strict';\n\n    /**\n     * Local dependencies\n     */\n\n    var Ruler      = require('./ruler');\n    var StateBlock = require('./rules_block/state_block');\n\n    /**\n     * Parser rules\n     */\n\n    var _rules = [\n        [ 'code',       require('./rules_block/code') ],\n        [ 'fences',     require('./rules_block/fences'),     [ 'paragraph', 'blockquote', 'list' ] ],\n        [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'blockquote', 'list' ] ],\n        [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'blockquote', 'list' ] ],\n        [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'blockquote' ] ],\n        [ 'footnote',   require('./rules_block/footnote'),   [ 'paragraph' ] ],\n        [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'blockquote' ] ],\n        [ 'lheading',   require('./rules_block/lheading') ],\n        [ 'htmlblock',  require('./rules_block/htmlblock'),  [ 'paragraph', 'blockquote' ] ],\n        [ 'table',      require('./rules_block/table'),      [ 'paragraph' ] ],\n        [ 'deflist',    require('./rules_block/deflist'),    [ 'paragraph' ] ],\n        [ 'paragraph',  require('./rules_block/paragraph') ]\n    ];\n\n    /**\n     * Block Parser class\n     *\n     * @api private\n     */\n\n    function ParserBlock() {\n        this.ruler = new Ruler();\n        for (var i = 0; i < _rules.length; i++) {\n            this.ruler.push(_rules[i][0], _rules[i][1], {\n                alt: (_rules[i][2] || []).slice()\n            });\n        }\n    }\n\n    /**\n     * Generate tokens for the given input range.\n     *\n     * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc\n     * @param  {Number} `startLine`\n     * @param  {Number} `endLine`\n     * @api private\n     */\n\n    ParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n        var rules = this.ruler.getRules('');\n        var len = rules.length;\n        var line = startLine;\n        var hasEmptyLines = false;\n        var ok, i;\n\n        while (line < endLine) {\n            state.line = line = state.skipEmptyLines(line);\n            if (line >= endLine) {\n                break;\n            }\n\n            // Termination condition for nested calls.\n            // Nested calls currently used for blockquotes & lists\n            if (state.tShift[line] < state.blkIndent) {\n                break;\n            }\n\n            // Try all possible rules.\n            // On success, rule should:\n            //\n            // - update `state.line`\n            // - update `state.tokens`\n            // - return true\n\n            for (i = 0; i < len; i++) {\n                ok = rules[i](state, line, endLine, false);\n                if (ok) {\n                    break;\n                }\n            }\n\n            // set state.tight iff we had an empty line before current tag\n            // i.e. latest empty line should not count\n            state.tight = !hasEmptyLines;\n\n            // paragraph might \"eat\" one newline after it in nested lists\n            if (state.isEmpty(state.line - 1)) {\n                hasEmptyLines = true;\n            }\n\n            line = state.line;\n\n            if (line < endLine && state.isEmpty(line)) {\n                hasEmptyLines = true;\n                line++;\n\n                // two empty lines should stop the parser in list mode\n                if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }\n                state.line = line;\n            }\n        }\n    };\n\n    var TABS_SCAN_RE = /[\\n\\t]/g;\n    var NEWLINES_RE  = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\n    var SPACES_RE    = /\\u00a0/g;\n\n    /**\n     * Tokenize the given `str`.\n     *\n     * @param  {String} `str` Source string\n     * @param  {Object} `options`\n     * @param  {Object} `env`\n     * @param  {Array} `outTokens`\n     * @api private\n     */\n\n    ParserBlock.prototype.parse = function (str, options, env, outTokens) {\n        var state, lineStart = 0, lastTabPos = 0;\n        if (!str) { return []; }\n\n        // Normalize spaces\n        str = str.replace(SPACES_RE, ' ');\n\n        // Normalize newlines\n        str = str.replace(NEWLINES_RE, '\\n');\n\n        // Replace tabs with proper number of spaces (1..4)\n        if (str.indexOf('\\t') >= 0) {\n            str = str.replace(TABS_SCAN_RE, function (match, offset) {\n                var result;\n                if (str.charCodeAt(offset) === 0x0A) {\n                    lineStart = offset + 1;\n                    lastTabPos = 0;\n                    return match;\n                }\n                result = '    '.slice((offset - lineStart - lastTabPos) % 4);\n                lastTabPos = offset - lineStart + 1;\n                return result;\n            });\n        }\n\n        state = new StateBlock(str, this, options, env, outTokens);\n        this.tokenize(state, state.line, state.lineMax);\n    };\n\n    /**\n     * Expose `ParserBlock`\n     */\n\n    module.exports = ParserBlock;\n\n},{\"./ruler\":19,\"./rules_block/blockquote\":21,\"./rules_block/code\":22,\"./rules_block/deflist\":23,\"./rules_block/fences\":24,\"./rules_block/footnote\":25,\"./rules_block/heading\":26,\"./rules_block/hr\":27,\"./rules_block/htmlblock\":28,\"./rules_block/lheading\":29,\"./rules_block/list\":30,\"./rules_block/paragraph\":31,\"./rules_block/state_block\":32,\"./rules_block/table\":33}],16:[function(require,module,exports){\n    'use strict';\n\n    /**\n     * Local dependencies\n     */\n\n    var Ruler = require('./ruler');\n\n    /**\n     * Core parser `rules`\n     */\n\n    var _rules = [\n        [ 'block',          require('./rules_core/block')          ],\n        [ 'abbr',           require('./rules_core/abbr')           ],\n        [ 'references',     require('./rules_core/references')     ],\n        [ 'inline',         require('./rules_core/inline')         ],\n        [ 'footnote_tail',  require('./rules_core/footnote_tail')  ],\n        [ 'abbr2',          require('./rules_core/abbr2')          ],\n        [ 'replacements',   require('./rules_core/replacements')   ],\n        [ 'smartquotes',    require('./rules_core/smartquotes')    ],\n        [ 'linkify',        require('./rules_core/linkify')        ]\n    ];\n\n    /**\n     * Class for top level (`core`) parser rules\n     *\n     * @api private\n     */\n\n    function Core() {\n        this.options = {};\n        this.ruler = new Ruler();\n        for (var i = 0; i < _rules.length; i++) {\n            this.ruler.push(_rules[i][0], _rules[i][1]);\n        }\n    }\n\n    /**\n     * Process rules with the given `state`\n     *\n     * @param  {Object} `state`\n     * @api private\n     */\n\n    Core.prototype.process = function (state) {\n        var i, l, rules;\n        rules = this.ruler.getRules('');\n        for (i = 0, l = rules.length; i < l; i++) {\n            rules[i](state);\n        }\n    };\n\n    /**\n     * Expose `Core`\n     */\n\n    module.exports = Core;\n\n},{\"./ruler\":19,\"./rules_core/abbr\":34,\"./rules_core/abbr2\":35,\"./rules_core/block\":36,\"./rules_core/footnote_tail\":37,\"./rules_core/inline\":38,\"./rules_core/linkify\":39,\"./rules_core/references\":40,\"./rules_core/replacements\":41,\"./rules_core/smartquotes\":42}],17:[function(require,module,exports){\n    'use strict';\n\n    /**\n     * Local dependencies\n     */\n\n    var Ruler       = require('./ruler');\n    var StateInline = require('./rules_inline/state_inline');\n    var utils       = require('./common/utils');\n\n    /**\n     * Inline Parser `rules`\n     */\n\n    var _rules = [\n        [ 'text',            require('./rules_inline/text') ],\n        [ 'newline',         require('./rules_inline/newline') ],\n        [ 'escape',          require('./rules_inline/escape') ],\n        [ 'backticks',       require('./rules_inline/backticks') ],\n        [ 'del',             require('./rules_inline/del') ],\n        [ 'ins',             require('./rules_inline/ins') ],\n        [ 'mark',            require('./rules_inline/mark') ],\n        [ 'emphasis',        require('./rules_inline/emphasis') ],\n        [ 'sub',             require('./rules_inline/sub') ],\n        [ 'sup',             require('./rules_inline/sup') ],\n        [ 'links',           require('./rules_inline/links') ],\n        [ 'footnote_inline', require('./rules_inline/footnote_inline') ],\n        [ 'footnote_ref',    require('./rules_inline/footnote_ref') ],\n        [ 'autolink',        require('./rules_inline/autolink') ],\n        [ 'htmltag',         require('./rules_inline/htmltag') ],\n        [ 'entity',          require('./rules_inline/entity') ]\n    ];\n\n    /**\n     * Inline Parser class. Note that link validation is stricter\n     * in Remarkable than what is specified by CommonMark. If you\n     * want to change this you can use a custom validator.\n     *\n     * @api private\n     */\n\n    function ParserInline() {\n        this.ruler = new Ruler();\n        for (var i = 0; i < _rules.length; i++) {\n            this.ruler.push(_rules[i][0], _rules[i][1]);\n        }\n\n        // Can be overridden with a custom validator\n        this.validateLink = validateLink;\n    }\n\n    /**\n     * Skip a single token by running all rules in validation mode.\n     * Returns `true` if any rule reports success.\n     *\n     * @param  {Object} `state`\n     * @api privage\n     */\n\n    ParserInline.prototype.skipToken = function (state) {\n        var rules = this.ruler.getRules('');\n        var len = rules.length;\n        var pos = state.pos;\n        var i, cached_pos;\n\n        if ((cached_pos = state.cacheGet(pos)) > 0) {\n            state.pos = cached_pos;\n            return;\n        }\n\n        for (i = 0; i < len; i++) {\n            if (rules[i](state, true)) {\n                state.cacheSet(pos, state.pos);\n                return;\n            }\n        }\n\n        state.pos++;\n        state.cacheSet(pos, state.pos);\n    };\n\n    /**\n     * Generate tokens for the given input range.\n     *\n     * @param  {Object} `state`\n     * @api private\n     */\n\n    ParserInline.prototype.tokenize = function (state) {\n        var rules = this.ruler.getRules('');\n        var len = rules.length;\n        var end = state.posMax;\n        var ok, i;\n\n        while (state.pos < end) {\n\n            // Try all possible rules.\n            // On success, the rule should:\n            //\n            // - update `state.pos`\n            // - update `state.tokens`\n            // - return true\n            for (i = 0; i < len; i++) {\n                ok = rules[i](state, false);\n\n                if (ok) {\n                    break;\n                }\n            }\n\n            if (ok) {\n                if (state.pos >= end) { break; }\n                continue;\n            }\n\n            state.pending += state.src[state.pos++];\n        }\n\n        if (state.pending) {\n            state.pushPending();\n        }\n    };\n\n    /**\n     * Parse the given input string.\n     *\n     * @param  {String} `str`\n     * @param  {Object} `options`\n     * @param  {Object} `env`\n     * @param  {Array} `outTokens`\n     * @api private\n     */\n\n    ParserInline.prototype.parse = function (str, options, env, outTokens) {\n        var state = new StateInline(str, this, options, env, outTokens);\n        this.tokenize(state);\n    };\n\n    /**\n     * Validate the given `url` by checking for bad protocols.\n     *\n     * @param  {String} `url`\n     * @return {Boolean}\n     */\n\n    function validateLink(url) {\n        var BAD_PROTOCOLS = [ 'vbscript', 'javascript', 'file' ];\n        var str = url.trim().toLowerCase();\n        // Care about digital entities \"javascript&#x3A;alert(1)\"\n        str = utils.replaceEntities(str);\n        if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Expose `ParserInline`\n     */\n\n    module.exports = ParserInline;\n\n},{\"./common/utils\":5,\"./ruler\":19,\"./rules_inline/autolink\":43,\"./rules_inline/backticks\":44,\"./rules_inline/del\":45,\"./rules_inline/emphasis\":46,\"./rules_inline/entity\":47,\"./rules_inline/escape\":48,\"./rules_inline/footnote_inline\":49,\"./rules_inline/footnote_ref\":50,\"./rules_inline/htmltag\":51,\"./rules_inline/ins\":52,\"./rules_inline/links\":53,\"./rules_inline/mark\":54,\"./rules_inline/newline\":55,\"./rules_inline/state_inline\":56,\"./rules_inline/sub\":57,\"./rules_inline/sup\":58,\"./rules_inline/text\":59}],18:[function(require,module,exports){\n    'use strict';\n\n    /**\n     * Local dependencies\n     */\n\n    var utils = require('./common/utils');\n    var rules = require('./rules');\n\n    /**\n     * Expose `Renderer`\n     */\n\n    module.exports = Renderer;\n\n    /**\n     * Renderer class. Renders HTML and exposes `rules` to allow\n     * local modifications.\n     */\n\n    function Renderer() {\n        this.rules = utils.assign({}, rules);\n\n        // exported helper, for custom rules only\n        this.getBreak = rules.getBreak;\n    }\n\n    /**\n     * Render a string of inline HTML with the given `tokens` and\n     * `options`.\n     *\n     * @param  {Array} `tokens`\n     * @param  {Object} `options`\n     * @param  {Object} `env`\n     * @return {String}\n     * @api public\n     */\n\n    Renderer.prototype.renderInline = function (tokens, options, env) {\n        var _rules = this.rules;\n        var len = tokens.length, i = 0;\n        var result = '';\n\n        while (len--) {\n            result += _rules[tokens[i].type](tokens, i++, options, env, this);\n        }\n\n        return result;\n    };\n\n    /**\n     * Render a string of HTML with the given `tokens` and\n     * `options`.\n     *\n     * @param  {Array} `tokens`\n     * @param  {Object} `options`\n     * @param  {Object} `env`\n     * @return {String}\n     * @api public\n     */\n\n    Renderer.prototype.render = function (tokens, options, env) {\n        var _rules = this.rules;\n        var len = tokens.length, i = -1;\n        var result = '';\n\n        while (++i < len) {\n            if (tokens[i].type === 'inline') {\n                result += this.renderInline(tokens[i].children, options, env);\n            } else {\n                result += _rules[tokens[i].type](tokens, i, options, env, this);\n            }\n        }\n        return result;\n    };\n\n},{\"./common/utils\":5,\"./rules\":20}],19:[function(require,module,exports){\n    'use strict';\n\n    /**\n     * Ruler is a helper class for building responsibility chains from\n     * parse rules. It allows:\n     *\n     *   - easy stack rules chains\n     *   - getting main chain and named chains content (as arrays of functions)\n     *\n     * Helper methods, should not be used directly.\n     * @api private\n     */\n\n    function Ruler() {\n        // List of added rules. Each element is:\n        //\n        // { name: XXX,\n        //   enabled: Boolean,\n        //   fn: Function(),\n        //   alt: [ name2, name3 ] }\n        //\n        this.__rules__ = [];\n\n        // Cached rule chains.\n        //\n        // First level - chain name, '' for default.\n        // Second level - digital anchor for fast filtering by charcodes.\n        //\n        this.__cache__ = null;\n    }\n\n    /**\n     * Find the index of a rule by `name`.\n     *\n     * @param  {String} `name`\n     * @return {Number} Index of the given `name`\n     * @api private\n     */\n\n    Ruler.prototype.__find__ = function (name) {\n        var len = this.__rules__.length;\n        var i = -1;\n\n        while (len--) {\n            if (this.__rules__[++i].name === name) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Build the rules lookup cache\n     *\n     * @api private\n     */\n\n    Ruler.prototype.__compile__ = function () {\n        var self = this;\n        var chains = [ '' ];\n\n        // collect unique names\n        self.__rules__.forEach(function (rule) {\n            if (!rule.enabled) {\n                return;\n            }\n\n            rule.alt.forEach(function (altName) {\n                if (chains.indexOf(altName) < 0) {\n                    chains.push(altName);\n                }\n            });\n        });\n\n        self.__cache__ = {};\n\n        chains.forEach(function (chain) {\n            self.__cache__[chain] = [];\n            self.__rules__.forEach(function (rule) {\n                if (!rule.enabled) {\n                    return;\n                }\n\n                if (chain && rule.alt.indexOf(chain) < 0) {\n                    return;\n                }\n                self.__cache__[chain].push(rule.fn);\n            });\n        });\n    };\n\n    /**\n     * Ruler public methods\n     * ------------------------------------------------\n     */\n\n    /**\n     * Replace rule function\n     *\n     * @param  {String} `name` Rule name\n     * @param  {Function `fn`\n     * @param  {Object} `options`\n     * @api private\n     */\n\n    Ruler.prototype.at = function (name, fn, options) {\n        var idx = this.__find__(name);\n        var opt = options || {};\n\n        if (idx === -1) {\n            throw new Error('Parser rule not found: ' + name);\n        }\n\n        this.__rules__[idx].fn = fn;\n        this.__rules__[idx].alt = opt.alt || [];\n        this.__cache__ = null;\n    };\n\n    /**\n     * Add a rule to the chain before given the `ruleName`.\n     *\n     * @param  {String}   `beforeName`\n     * @param  {String}   `ruleName`\n     * @param  {Function} `fn`\n     * @param  {Object}   `options`\n     * @api private\n     */\n\n    Ruler.prototype.before = function (beforeName, ruleName, fn, options) {\n        var idx = this.__find__(beforeName);\n        var opt = options || {};\n\n        if (idx === -1) {\n            throw new Error('Parser rule not found: ' + beforeName);\n        }\n\n        this.__rules__.splice(idx, 0, {\n            name: ruleName,\n            enabled: true,\n            fn: fn,\n            alt: opt.alt || []\n        });\n\n        this.__cache__ = null;\n    };\n\n    /**\n     * Add a rule to the chain after the given `ruleName`.\n     *\n     * @param  {String}   `afterName`\n     * @param  {String}   `ruleName`\n     * @param  {Function} `fn`\n     * @param  {Object}   `options`\n     * @api private\n     */\n\n    Ruler.prototype.after = function (afterName, ruleName, fn, options) {\n        var idx = this.__find__(afterName);\n        var opt = options || {};\n\n        if (idx === -1) {\n            throw new Error('Parser rule not found: ' + afterName);\n        }\n\n        this.__rules__.splice(idx + 1, 0, {\n            name: ruleName,\n            enabled: true,\n            fn: fn,\n            alt: opt.alt || []\n        });\n\n        this.__cache__ = null;\n    };\n\n    /**\n     * Add a rule to the end of chain.\n     *\n     * @param  {String}   `ruleName`\n     * @param  {Function} `fn`\n     * @param  {Object}   `options`\n     * @return {String}\n     */\n\n    Ruler.prototype.push = function (ruleName, fn, options) {\n        var opt = options || {};\n\n        this.__rules__.push({\n            name: ruleName,\n            enabled: true,\n            fn: fn,\n            alt: opt.alt || []\n        });\n\n        this.__cache__ = null;\n    };\n\n    /**\n     * Enable a rule or list of rules.\n     *\n     * @param  {String|Array} `list` Name or array of rule names to enable\n     * @param  {Boolean} `strict` If `true`, all non listed rules will be disabled.\n     * @api private\n     */\n\n    Ruler.prototype.enable = function (list, strict) {\n        list = !Array.isArray(list)\n            ? [ list ]\n            : list;\n\n        // In strict mode disable all existing rules first\n        if (strict) {\n            this.__rules__.forEach(function (rule) {\n                rule.enabled = false;\n            });\n        }\n\n        // Search by name and enable\n        list.forEach(function (name) {\n            var idx = this.__find__(name);\n            if (idx < 0) {\n                throw new Error('Rules manager: invalid rule name ' + name);\n            }\n            this.__rules__[idx].enabled = true;\n        }, this);\n\n        this.__cache__ = null;\n    };\n\n\n    /**\n     * Disable a rule or list of rules.\n     *\n     * @param  {String|Array} `list` Name or array of rule names to disable\n     * @api private\n     */\n\n    Ruler.prototype.disable = function (list) {\n        list = !Array.isArray(list)\n            ? [ list ]\n            : list;\n\n        // Search by name and disable\n        list.forEach(function (name) {\n            var idx = this.__find__(name);\n            if (idx < 0) {\n                throw new Error('Rules manager: invalid rule name ' + name);\n            }\n            this.__rules__[idx].enabled = false;\n        }, this);\n\n        this.__cache__ = null;\n    };\n\n    /**\n     * Get a rules list as an array of functions.\n     *\n     * @param  {String} `chainName`\n     * @return {Object}\n     * @api private\n     */\n\n    Ruler.prototype.getRules = function (chainName) {\n        if (this.__cache__ === null) {\n            this.__compile__();\n        }\n        return this.__cache__[chainName];\n    };\n\n    /**\n     * Expose `Ruler`\n     */\n\n    module.exports = Ruler;\n\n},{}],20:[function(require,module,exports){\n    'use strict';\n\n    /**\n     * Local dependencies\n     */\n\n    var has             = require('./common/utils').has;\n    var unescapeMd      = require('./common/utils').unescapeMd;\n    var replaceEntities = require('./common/utils').replaceEntities;\n    var escapeHtml      = require('./common/utils').escapeHtml;\n\n    /**\n     * Renderer rules cache\n     */\n\n    var rules = {};\n\n    /**\n     * Blockquotes\n     */\n\n    rules.blockquote_open = function (/* tokens, idx, options, env */) {\n        return '<blockquote>\\n';\n    };\n\n    rules.blockquote_close = function (tokens, idx /*, options, env */) {\n        return '</blockquote>' + getBreak(tokens, idx);\n    };\n\n    /**\n     * Code\n     */\n\n    rules.code = function (tokens, idx /*, options, env */) {\n        if (tokens[idx].block) {\n            return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>' + getBreak(tokens, idx);\n        }\n        return '<code>' + escapeHtml(tokens[idx].content) + '</code>';\n    };\n\n    /**\n     * Fenced code blocks\n     */\n\n    rules.fence = function (tokens, idx, options, env, instance) {\n        var token = tokens[idx];\n        var langClass = '';\n        var langPrefix = options.langPrefix;\n        var langName = '', fenceName;\n        var highlighted;\n\n        if (token.params) {\n\n            //\n            // ```foo bar\n            //\n            // Try custom renderer \"foo\" first. That will simplify overwrite\n            // for diagrams, latex, and any other fenced block with custom look\n            //\n\n            fenceName = token.params.split(/\\s+/g)[0];\n\n            if (has(instance.rules.fence_custom, fenceName)) {\n                return instance.rules.fence_custom[fenceName](tokens, idx, options, env, instance);\n            }\n\n            langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));\n            langClass = ' class=\"' + langPrefix + langName + '\"';\n        }\n\n        if (options.highlight) {\n            highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);\n        } else {\n            highlighted = escapeHtml(token.content);\n        }\n\n        return '<pre><code' + langClass + '>'\n            + highlighted\n            + '</code></pre>'\n            + getBreak(tokens, idx);\n    };\n\n    rules.fence_custom = {};\n\n    /**\n     * Headings\n     */\n\n    rules.heading_open = function (tokens, idx /*, options, env */) {\n        return '<h' + tokens[idx].hLevel + '>';\n    };\n    rules.heading_close = function (tokens, idx /*, options, env */) {\n        return '</h' + tokens[idx].hLevel + '>\\n';\n    };\n\n    /**\n     * Horizontal rules\n     */\n\n    rules.hr = function (tokens, idx, options /*, env */) {\n        return (options.xhtmlOut ? '<hr />' : '<hr>') + getBreak(tokens, idx);\n    };\n\n    /**\n     * Bullets\n     */\n\n    rules.bullet_list_open = function (/* tokens, idx, options, env */) {\n        return '<ul>\\n';\n    };\n    rules.bullet_list_close = function (tokens, idx /*, options, env */) {\n        return '</ul>' + getBreak(tokens, idx);\n    };\n\n    /**\n     * List items\n     */\n\n    rules.list_item_open = function (/* tokens, idx, options, env */) {\n        return '<li>';\n    };\n    rules.list_item_close = function (/* tokens, idx, options, env */) {\n        return '</li>\\n';\n    };\n\n    /**\n     * Ordered list items\n     */\n\n    rules.ordered_list_open = function (tokens, idx /*, options, env */) {\n        var token = tokens[idx];\n        var order = token.order > 1 ? ' start=\"' + token.order + '\"' : '';\n        return '<ol' + order + '>\\n';\n    };\n    rules.ordered_list_close = function (tokens, idx /*, options, env */) {\n        return '</ol>' + getBreak(tokens, idx);\n    };\n\n    /**\n     * Paragraphs\n     */\n\n    rules.paragraph_open = function (tokens, idx /*, options, env */) {\n        return tokens[idx].tight ? '' : '<p>';\n    };\n    rules.paragraph_close = function (tokens, idx /*, options, env */) {\n        var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === 'inline' && !tokens[idx - 1].content);\n        return (tokens[idx].tight ? '' : '</p>') + (addBreak ? getBreak(tokens, idx) : '');\n    };\n\n    /**\n     * Links\n     */\n\n    rules.link_open = function (tokens, idx, options /* env */) {\n        var title = tokens[idx].title ? (' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"') : '';\n        var target = options.linkTarget ? (' target=\"' + options.linkTarget + '\"') : '';\n        return '<a href=\"' + escapeHtml(tokens[idx].href) + '\"' + title + target + '>';\n    };\n    rules.link_close = function (/* tokens, idx, options, env */) {\n        return '</a>';\n    };\n\n    /**\n     * Images\n     */\n\n    rules.image = function (tokens, idx, options /*, env */) {\n        var src = ' src=\"' + escapeHtml(tokens[idx].src) + '\"';\n        var title = tokens[idx].title ? (' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"') : '';\n        var alt = ' alt=\"' + (tokens[idx].alt ? escapeHtml(replaceEntities(tokens[idx].alt)) : '') + '\"';\n        var suffix = options.xhtmlOut ? ' /' : '';\n        return '<img' + src + alt + title + suffix + '>';\n    };\n\n    /**\n     * Tables\n     */\n\n    rules.table_open = function (/* tokens, idx, options, env */) {\n        return '<table>\\n';\n    };\n    rules.table_close = function (/* tokens, idx, options, env */) {\n        return '</table>\\n';\n    };\n    rules.thead_open = function (/* tokens, idx, options, env */) {\n        return '<thead>\\n';\n    };\n    rules.thead_close = function (/* tokens, idx, options, env */) {\n        return '</thead>\\n';\n    };\n    rules.tbody_open = function (/* tokens, idx, options, env */) {\n        return '<tbody>\\n';\n    };\n    rules.tbody_close = function (/* tokens, idx, options, env */) {\n        return '</tbody>\\n';\n    };\n    rules.tr_open = function (/* tokens, idx, options, env */) {\n        return '<tr>';\n    };\n    rules.tr_close = function (/* tokens, idx, options, env */) {\n        return '</tr>\\n';\n    };\n    rules.th_open = function (tokens, idx /*, options, env */) {\n        var token = tokens[idx];\n        return '<th'\n            + (token.align ? ' style=\"text-align:' + token.align + '\"' : '')\n            + '>';\n    };\n    rules.th_close = function (/* tokens, idx, options, env */) {\n        return '</th>';\n    };\n    rules.td_open = function (tokens, idx /*, options, env */) {\n        var token = tokens[idx];\n        return '<td'\n            + (token.align ? ' style=\"text-align:' + token.align + '\"' : '')\n            + '>';\n    };\n    rules.td_close = function (/* tokens, idx, options, env */) {\n        return '</td>';\n    };\n\n    /**\n     * Bold\n     */\n\n    rules.strong_open = function (/* tokens, idx, options, env */) {\n        return '<strong>';\n    };\n    rules.strong_close = function (/* tokens, idx, options, env */) {\n        return '</strong>';\n    };\n\n    /**\n     * Italicize\n     */\n\n    rules.em_open = function (/* tokens, idx, options, env */) {\n        return '<em>';\n    };\n    rules.em_close = function (/* tokens, idx, options, env */) {\n        return '</em>';\n    };\n\n    /**\n     * Strikethrough\n     */\n\n    rules.del_open = function (/* tokens, idx, options, env */) {\n        return '<del>';\n    };\n    rules.del_close = function (/* tokens, idx, options, env */) {\n        return '</del>';\n    };\n\n    /**\n     * Insert\n     */\n\n    rules.ins_open = function (/* tokens, idx, options, env */) {\n        return '<ins>';\n    };\n    rules.ins_close = function (/* tokens, idx, options, env */) {\n        return '</ins>';\n    };\n\n    /**\n     * Highlight\n     */\n\n    rules.mark_open = function (/* tokens, idx, options, env */) {\n        return '<mark>';\n    };\n    rules.mark_close = function (/* tokens, idx, options, env */) {\n        return '</mark>';\n    };\n\n    /**\n     * Super- and sub-script\n     */\n\n    rules.sub = function (tokens, idx /*, options, env */) {\n        return '<sub>' + escapeHtml(tokens[idx].content) + '</sub>';\n    };\n    rules.sup = function (tokens, idx /*, options, env */) {\n        return '<sup>' + escapeHtml(tokens[idx].content) + '</sup>';\n    };\n\n    /**\n     * Breaks\n     */\n\n    rules.hardbreak = function (tokens, idx, options /*, env */) {\n        return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n    };\n    rules.softbreak = function (tokens, idx, options /*, env */) {\n        return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n';\n    };\n\n    /**\n     * Text\n     */\n\n    rules.text = function (tokens, idx /*, options, env */) {\n        return escapeHtml(tokens[idx].content);\n    };\n\n    /**\n     * Content\n     */\n\n    rules.htmlblock = function (tokens, idx /*, options, env */) {\n        return tokens[idx].content;\n    };\n    rules.htmltag = function (tokens, idx /*, options, env */) {\n        return tokens[idx].content;\n    };\n\n    /**\n     * Abbreviations, initialism\n     */\n\n    rules.abbr_open = function (tokens, idx /*, options, env */) {\n        return '<abbr title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\">';\n    };\n    rules.abbr_close = function (/* tokens, idx, options, env */) {\n        return '</abbr>';\n    };\n\n    /**\n     * Footnotes\n     */\n\n    rules.footnote_ref = function (tokens, idx) {\n        var n = Number(tokens[idx].id + 1).toString();\n        var id = 'fnref' + n;\n        if (tokens[idx].subId > 0) {\n            id += ':' + tokens[idx].subId;\n        }\n        return '<sup class=\"footnote-ref\"><a href=\"#fn' + n + '\" id=\"' + id + '\">[' + n + ']</a></sup>';\n    };\n    rules.footnote_block_open = function (tokens, idx, options) {\n        var hr = options.xhtmlOut\n            ? '<hr class=\"footnotes-sep\" />\\n'\n            : '<hr class=\"footnotes-sep\">\\n';\n        return  hr + '<section class=\"footnotes\">\\n<ol class=\"footnotes-list\">\\n';\n    };\n    rules.footnote_block_close = function () {\n        return '</ol>\\n</section>\\n';\n    };\n    rules.footnote_open = function (tokens, idx) {\n        var id = Number(tokens[idx].id + 1).toString();\n        return '<li id=\"fn' + id + '\"  class=\"footnote-item\">';\n    };\n    rules.footnote_close = function () {\n        return '</li>\\n';\n    };\n    rules.footnote_anchor = function (tokens, idx) {\n        var n = Number(tokens[idx].id + 1).toString();\n        var id = 'fnref' + n;\n        if (tokens[idx].subId > 0) {\n            id += ':' + tokens[idx].subId;\n        }\n        return ' <a href=\"#' + id + '\" class=\"footnote-backref\">↩</a>';\n    };\n\n    /**\n     * Definition lists\n     */\n\n    rules.dl_open = function() {\n        return '<dl>\\n';\n    };\n    rules.dt_open = function() {\n        return '<dt>';\n    };\n    rules.dd_open = function() {\n        return '<dd>';\n    };\n    rules.dl_close = function() {\n        return '</dl>\\n';\n    };\n    rules.dt_close = function() {\n        return '</dt>\\n';\n    };\n    rules.dd_close = function() {\n        return '</dd>\\n';\n    };\n\n    /**\n     * Helper functions\n     */\n\n    function nextToken(tokens, idx) {\n        if (++idx >= tokens.length - 2) {\n            return idx;\n        }\n        if ((tokens[idx].type === 'paragraph_open' && tokens[idx].tight) &&\n            (tokens[idx + 1].type === 'inline' && tokens[idx + 1].content.length === 0) &&\n            (tokens[idx + 2].type === 'paragraph_close' && tokens[idx + 2].tight)) {\n            return nextToken(tokens, idx + 2);\n        }\n        return idx;\n    }\n\n    /**\n     * Check to see if `\\n` is needed before the next token.\n     *\n     * @param  {Array} `tokens`\n     * @param  {Number} `idx`\n     * @return {String} Empty string or newline\n     * @api private\n     */\n\n    var getBreak = rules.getBreak = function getBreak(tokens, idx) {\n        idx = nextToken(tokens, idx);\n        if (idx < tokens.length && tokens[idx].type === 'list_item_close') {\n            return '';\n        }\n        return '\\n';\n    };\n\n    /**\n     * Expose `rules`\n     */\n\n    module.exports = rules;\n\n},{\"./common/utils\":5}],21:[function(require,module,exports){\n// Block quotes\n\n    'use strict';\n\n\n    module.exports = function blockquote(state, startLine, endLine, silent) {\n        var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,\n            terminatorRules,\n            i, l, terminate,\n            pos = state.bMarks[startLine] + state.tShift[startLine],\n            max = state.eMarks[startLine];\n\n        if (pos > max) { return false; }\n\n        // check the block quote marker\n        if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        // we know that it's going to be a valid blockquote,\n        // so no point trying to find the end of it in silent mode\n        if (silent) { return true; }\n\n        // skip one optional space after '>'\n        if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n        oldIndent = state.blkIndent;\n        state.blkIndent = 0;\n\n        oldBMarks = [ state.bMarks[startLine] ];\n        state.bMarks[startLine] = pos;\n\n        // check if we have an empty blockquote\n        pos = pos < max ? state.skipSpaces(pos) : pos;\n        lastLineEmpty = pos >= max;\n\n        oldTShift = [ state.tShift[startLine] ];\n        state.tShift[startLine] = pos - state.bMarks[startLine];\n\n        terminatorRules = state.parser.ruler.getRules('blockquote');\n\n        // Search the end of the block\n        //\n        // Block ends with either:\n        //  1. an empty line outside:\n        //     ```\n        //     > test\n        //\n        //     ```\n        //  2. an empty line inside:\n        //     ```\n        //     >\n        //     test\n        //     ```\n        //  3. another tag\n        //     ```\n        //     > test\n        //      - - -\n        //     ```\n        for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n            pos = state.bMarks[nextLine] + state.tShift[nextLine];\n            max = state.eMarks[nextLine];\n\n            if (pos >= max) {\n                // Case 1: line is not inside the blockquote, and this line is empty.\n                break;\n            }\n\n            if (state.src.charCodeAt(pos++) === 0x3E/* > */) {\n                // This line is inside the blockquote.\n\n                // skip one optional space after '>'\n                if (state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n                oldBMarks.push(state.bMarks[nextLine]);\n                state.bMarks[nextLine] = pos;\n\n                pos = pos < max ? state.skipSpaces(pos) : pos;\n                lastLineEmpty = pos >= max;\n\n                oldTShift.push(state.tShift[nextLine]);\n                state.tShift[nextLine] = pos - state.bMarks[nextLine];\n                continue;\n            }\n\n            // Case 2: line is not inside the blockquote, and the last line was empty.\n            if (lastLineEmpty) { break; }\n\n            // Case 3: another tag found.\n            terminate = false;\n            for (i = 0, l = terminatorRules.length; i < l; i++) {\n                if (terminatorRules[i](state, nextLine, endLine, true)) {\n                    terminate = true;\n                    break;\n                }\n            }\n            if (terminate) { break; }\n\n            oldBMarks.push(state.bMarks[nextLine]);\n            oldTShift.push(state.tShift[nextLine]);\n\n            // A negative number means that this is a paragraph continuation;\n            //\n            // Any negative number will do the job here, but it's better for it\n            // to be large enough to make any bugs obvious.\n            state.tShift[nextLine] = -1337;\n        }\n\n        oldParentType = state.parentType;\n        state.parentType = 'blockquote';\n        state.tokens.push({\n            type: 'blockquote_open',\n            lines: lines = [ startLine, 0 ],\n            level: state.level++\n        });\n        state.parser.tokenize(state, startLine, nextLine);\n        state.tokens.push({\n            type: 'blockquote_close',\n            level: --state.level\n        });\n        state.parentType = oldParentType;\n        lines[1] = state.line;\n\n        // Restore original tShift; this might not be necessary since the parser\n        // has already been here, but just to make sure we can do that.\n        for (i = 0; i < oldTShift.length; i++) {\n            state.bMarks[i + startLine] = oldBMarks[i];\n            state.tShift[i + startLine] = oldTShift[i];\n        }\n        state.blkIndent = oldIndent;\n\n        return true;\n    };\n\n},{}],22:[function(require,module,exports){\n// Code block (4 spaces padded)\n\n    'use strict';\n\n\n    module.exports = function code(state, startLine, endLine/*, silent*/) {\n        var nextLine, last;\n\n        if (state.tShift[startLine] - state.blkIndent < 4) { return false; }\n\n        last = nextLine = startLine + 1;\n\n        while (nextLine < endLine) {\n            if (state.isEmpty(nextLine)) {\n                nextLine++;\n                continue;\n            }\n            if (state.tShift[nextLine] - state.blkIndent >= 4) {\n                nextLine++;\n                last = nextLine;\n                continue;\n            }\n            break;\n        }\n\n        state.line = nextLine;\n        state.tokens.push({\n            type: 'code',\n            content: state.getLines(startLine, last, 4 + state.blkIndent, true),\n            block: true,\n            lines: [ startLine, state.line ],\n            level: state.level\n        });\n\n        return true;\n    };\n\n},{}],23:[function(require,module,exports){\n// Definition lists\n\n    'use strict';\n\n\n// Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\n    function skipMarker(state, line) {\n        var pos, marker,\n            start = state.bMarks[line] + state.tShift[line],\n            max = state.eMarks[line];\n\n        if (start >= max) { return -1; }\n\n        // Check bullet\n        marker = state.src.charCodeAt(start++);\n        if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }\n\n        pos = state.skipSpaces(start);\n\n        // require space after \":\"\n        if (start === pos) { return -1; }\n\n        // no empty definitions, e.g. \"  : \"\n        if (pos >= max) { return -1; }\n\n        return pos;\n    }\n\n    function markTightParagraphs(state, idx) {\n        var i, l,\n            level = state.level + 2;\n\n        for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n            if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n                state.tokens[i + 2].tight = true;\n                state.tokens[i].tight = true;\n                i += 2;\n            }\n        }\n    }\n\n    module.exports = function deflist(state, startLine, endLine, silent) {\n        var contentStart,\n            ddLine,\n            dtLine,\n            itemLines,\n            listLines,\n            listTokIdx,\n            nextLine,\n            oldIndent,\n            oldDDIndent,\n            oldParentType,\n            oldTShift,\n            oldTight,\n            prevEmptyEnd,\n            tight;\n\n        if (silent) {\n            // quirk: validation mode validates a dd block only, not a whole deflist\n            if (state.ddIndent < 0) { return false; }\n            return skipMarker(state, startLine) >= 0;\n        }\n\n        nextLine = startLine + 1;\n        if (state.isEmpty(nextLine)) {\n            if (++nextLine > endLine) { return false; }\n        }\n\n        if (state.tShift[nextLine] < state.blkIndent) { return false; }\n        contentStart = skipMarker(state, nextLine);\n        if (contentStart < 0) { return false; }\n\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        // Start list\n        listTokIdx = state.tokens.length;\n\n        state.tokens.push({\n            type: 'dl_open',\n            lines: listLines = [ startLine, 0 ],\n            level: state.level++\n        });\n\n        //\n        // Iterate list items\n        //\n\n        dtLine = startLine;\n        ddLine = nextLine;\n\n        // One definition list can contain multiple DTs,\n        // and one DT can be followed by multiple DDs.\n        //\n        // Thus, there is two loops here, and label is\n        // needed to break out of the second one\n        //\n        /*eslint no-labels:0,block-scoped-var:0*/\n        OUTER:\n            for (;;) {\n                tight = true;\n                prevEmptyEnd = false;\n\n                state.tokens.push({\n                    type: 'dt_open',\n                    lines: [ dtLine, dtLine ],\n                    level: state.level++\n                });\n                state.tokens.push({\n                    type: 'inline',\n                    content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\n                    level: state.level + 1,\n                    lines: [ dtLine, dtLine ],\n                    children: []\n                });\n                state.tokens.push({\n                    type: 'dt_close',\n                    level: --state.level\n                });\n\n                for (;;) {\n                    state.tokens.push({\n                        type: 'dd_open',\n                        lines: itemLines = [ nextLine, 0 ],\n                        level: state.level++\n                    });\n\n                    oldTight = state.tight;\n                    oldDDIndent = state.ddIndent;\n                    oldIndent = state.blkIndent;\n                    oldTShift = state.tShift[ddLine];\n                    oldParentType = state.parentType;\n                    state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\n                    state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n                    state.tight = true;\n                    state.parentType = 'deflist';\n\n                    state.parser.tokenize(state, ddLine, endLine, true);\n\n                    // If any of list item is tight, mark list as tight\n                    if (!state.tight || prevEmptyEnd) {\n                        tight = false;\n                    }\n                    // Item become loose if finish with empty line,\n                    // but we should filter last element, because it means list finish\n                    prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);\n\n                    state.tShift[ddLine] = oldTShift;\n                    state.tight = oldTight;\n                    state.parentType = oldParentType;\n                    state.blkIndent = oldIndent;\n                    state.ddIndent = oldDDIndent;\n\n                    state.tokens.push({\n                        type: 'dd_close',\n                        level: --state.level\n                    });\n\n                    itemLines[1] = nextLine = state.line;\n\n                    if (nextLine >= endLine) { break OUTER; }\n\n                    if (state.tShift[nextLine] < state.blkIndent) { break OUTER; }\n                    contentStart = skipMarker(state, nextLine);\n                    if (contentStart < 0) { break; }\n\n                    ddLine = nextLine;\n\n                    // go to the next loop iteration:\n                    // insert DD tag and repeat checking\n                }\n\n                if (nextLine >= endLine) { break; }\n                dtLine = nextLine;\n\n                if (state.isEmpty(dtLine)) { break; }\n                if (state.tShift[dtLine] < state.blkIndent) { break; }\n\n                ddLine = dtLine + 1;\n                if (ddLine >= endLine) { break; }\n                if (state.isEmpty(ddLine)) { ddLine++; }\n                if (ddLine >= endLine) { break; }\n\n                if (state.tShift[ddLine] < state.blkIndent) { break; }\n                contentStart = skipMarker(state, ddLine);\n                if (contentStart < 0) { break; }\n\n                // go to the next loop iteration:\n                // insert DT and DD tags and repeat checking\n            }\n\n        // Finilize list\n        state.tokens.push({\n            type: 'dl_close',\n            level: --state.level\n        });\n        listLines[1] = nextLine;\n\n        state.line = nextLine;\n\n        // mark paragraphs tight if needed\n        if (tight) {\n            markTightParagraphs(state, listTokIdx);\n        }\n\n        return true;\n    };\n\n},{}],24:[function(require,module,exports){\n// fences (``` lang, ~~~ lang)\n\n    'use strict';\n\n\n    module.exports = function fences(state, startLine, endLine, silent) {\n        var marker, len, params, nextLine, mem,\n            haveEndMarker = false,\n            pos = state.bMarks[startLine] + state.tShift[startLine],\n            max = state.eMarks[startLine];\n\n        if (pos + 3 > max) { return false; }\n\n        marker = state.src.charCodeAt(pos);\n\n        if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n            return false;\n        }\n\n        // scan marker length\n        mem = pos;\n        pos = state.skipChars(pos, marker);\n\n        len = pos - mem;\n\n        if (len < 3) { return false; }\n\n        params = state.src.slice(pos, max).trim();\n\n        if (params.indexOf('`') >= 0) { return false; }\n\n        // Since start is found, we can report success here in validation mode\n        if (silent) { return true; }\n\n        // search end of block\n        nextLine = startLine;\n\n        for (;;) {\n            nextLine++;\n            if (nextLine >= endLine) {\n                // unclosed block should be autoclosed by end of document.\n                // also block seems to be autoclosed by end of parent\n                break;\n            }\n\n            pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n            max = state.eMarks[nextLine];\n\n            if (pos < max && state.tShift[nextLine] < state.blkIndent) {\n                // non-empty line with negative indent should stop the list:\n                // - ```\n                //  test\n                break;\n            }\n\n            if (state.src.charCodeAt(pos) !== marker) { continue; }\n\n            if (state.tShift[nextLine] - state.blkIndent >= 4) {\n                // closing fence should be indented less than 4 spaces\n                continue;\n            }\n\n            pos = state.skipChars(pos, marker);\n\n            // closing code fence must be at least as long as the opening one\n            if (pos - mem < len) { continue; }\n\n            // make sure tail has spaces only\n            pos = state.skipSpaces(pos);\n\n            if (pos < max) { continue; }\n\n            haveEndMarker = true;\n            // found!\n            break;\n        }\n\n        // If a fence has heading spaces, they should be removed from its inner block\n        len = state.tShift[startLine];\n\n        state.line = nextLine + (haveEndMarker ? 1 : 0);\n        state.tokens.push({\n            type: 'fence',\n            params: params,\n            content: state.getLines(startLine + 1, nextLine, len, true),\n            lines: [ startLine, state.line ],\n            level: state.level\n        });\n\n        return true;\n    };\n\n},{}],25:[function(require,module,exports){\n// Process footnote reference list\n\n    'use strict';\n\n\n    module.exports = function footnote(state, startLine, endLine, silent) {\n        var oldBMark, oldTShift, oldParentType, pos, label,\n            start = state.bMarks[startLine] + state.tShift[startLine],\n            max = state.eMarks[startLine];\n\n        // line should be at least 5 chars - \"[^x]:\"\n        if (start + 4 > max) { return false; }\n\n        if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n        if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        for (pos = start + 2; pos < max; pos++) {\n            if (state.src.charCodeAt(pos) === 0x20) { return false; }\n            if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n                break;\n            }\n        }\n\n        if (pos === start + 2) { return false; } // no empty footnote labels\n        if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }\n        if (silent) { return true; }\n        pos++;\n\n        if (!state.env.footnotes) { state.env.footnotes = {}; }\n        if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }\n        label = state.src.slice(start + 2, pos - 2);\n        state.env.footnotes.refs[':' + label] = -1;\n\n        state.tokens.push({\n            type: 'footnote_reference_open',\n            label: label,\n            level: state.level++\n        });\n\n        oldBMark = state.bMarks[startLine];\n        oldTShift = state.tShift[startLine];\n        oldParentType = state.parentType;\n        state.tShift[startLine] = state.skipSpaces(pos) - pos;\n        state.bMarks[startLine] = pos;\n        state.blkIndent += 4;\n        state.parentType = 'footnote';\n\n        if (state.tShift[startLine] < state.blkIndent) {\n            state.tShift[startLine] += state.blkIndent;\n            state.bMarks[startLine] -= state.blkIndent;\n        }\n\n        state.parser.tokenize(state, startLine, endLine, true);\n\n        state.parentType = oldParentType;\n        state.blkIndent -= 4;\n        state.tShift[startLine] = oldTShift;\n        state.bMarks[startLine] = oldBMark;\n\n        state.tokens.push({\n            type: 'footnote_reference_close',\n            level: --state.level\n        });\n\n        return true;\n    };\n\n},{}],26:[function(require,module,exports){\n// heading (#, ##, ...)\n\n    'use strict';\n\n\n    module.exports = function heading(state, startLine, endLine, silent) {\n        var ch, level, tmp,\n            pos = state.bMarks[startLine] + state.tShift[startLine],\n            max = state.eMarks[startLine];\n\n        if (pos >= max) { return false; }\n\n        ch  = state.src.charCodeAt(pos);\n\n        if (ch !== 0x23/* # */ || pos >= max) { return false; }\n\n        // count heading level\n        level = 1;\n        ch = state.src.charCodeAt(++pos);\n        while (ch === 0x23/* # */ && pos < max && level <= 6) {\n            level++;\n            ch = state.src.charCodeAt(++pos);\n        }\n\n        if (level > 6 || (pos < max && ch !== 0x20/* space */)) { return false; }\n\n        if (silent) { return true; }\n\n        // Let's cut tails like '    ###  ' from the end of string\n\n        max = state.skipCharsBack(max, 0x20, pos); // space\n        tmp = state.skipCharsBack(max, 0x23, pos); // #\n        if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20/* space */) {\n            max = tmp;\n        }\n\n        state.line = startLine + 1;\n\n        state.tokens.push({ type: 'heading_open',\n            hLevel: level,\n            lines: [ startLine, state.line ],\n            level: state.level\n        });\n\n        // only if header is not empty\n        if (pos < max) {\n            state.tokens.push({\n                type: 'inline',\n                content: state.src.slice(pos, max).trim(),\n                level: state.level + 1,\n                lines: [ startLine, state.line ],\n                children: []\n            });\n        }\n        state.tokens.push({ type: 'heading_close', hLevel: level, level: state.level });\n\n        return true;\n    };\n\n},{}],27:[function(require,module,exports){\n// Horizontal rule\n\n    'use strict';\n\n\n    module.exports = function hr(state, startLine, endLine, silent) {\n        var marker, cnt, ch,\n            pos = state.bMarks[startLine],\n            max = state.eMarks[startLine];\n\n        pos += state.tShift[startLine];\n\n        if (pos > max) { return false; }\n\n        marker = state.src.charCodeAt(pos++);\n\n        // Check hr marker\n        if (marker !== 0x2A/* * */ &&\n            marker !== 0x2D/* - */ &&\n            marker !== 0x5F/* _ */) {\n            return false;\n        }\n\n        // markers can be mixed with spaces, but there should be at least 3 one\n\n        cnt = 1;\n        while (pos < max) {\n            ch = state.src.charCodeAt(pos++);\n            if (ch !== marker && ch !== 0x20/* space */) { return false; }\n            if (ch === marker) { cnt++; }\n        }\n\n        if (cnt < 3) { return false; }\n\n        if (silent) { return true; }\n\n        state.line = startLine + 1;\n        state.tokens.push({\n            type: 'hr',\n            lines: [ startLine, state.line ],\n            level: state.level\n        });\n\n        return true;\n    };\n\n},{}],28:[function(require,module,exports){\n// HTML block\n\n    'use strict';\n\n\n    var block_names = require('../common/html_blocks');\n\n\n    var HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\\s\\/>]/;\n    var HTML_TAG_CLOSE_RE = /^<\\/([a-zA-Z]{1,15})[\\s>]/;\n\n    function isLetter(ch) {\n        /*eslint no-bitwise:0*/\n        var lc = ch | 0x20; // to lower case\n        return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n    }\n\n    module.exports = function htmlblock(state, startLine, endLine, silent) {\n        var ch, match, nextLine,\n            pos = state.bMarks[startLine],\n            max = state.eMarks[startLine],\n            shift = state.tShift[startLine];\n\n        pos += shift;\n\n        if (!state.options.html) { return false; }\n\n        if (shift > 3 || pos + 2 >= max) { return false; }\n\n        if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n        ch = state.src.charCodeAt(pos + 1);\n\n        if (ch === 0x21/* ! */ || ch === 0x3F/* ? */) {\n            // Directive start / comment start / processing instruction start\n            if (silent) { return true; }\n\n        } else if (ch === 0x2F/* / */ || isLetter(ch)) {\n\n            // Probably start or end of tag\n            if (ch === 0x2F/* \\ */) {\n                // closing tag\n                match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);\n                if (!match) { return false; }\n            } else {\n                // opening tag\n                match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);\n                if (!match) { return false; }\n            }\n            // Make sure tag name is valid\n            if (block_names[match[1].toLowerCase()] !== true) { return false; }\n            if (silent) { return true; }\n\n        } else {\n            return false;\n        }\n\n        // If we are here - we detected HTML block.\n        // Let's roll down till empty line (block end).\n        nextLine = startLine + 1;\n        while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {\n            nextLine++;\n        }\n\n        state.line = nextLine;\n        state.tokens.push({\n            type: 'htmlblock',\n            level: state.level,\n            lines: [ startLine, state.line ],\n            content: state.getLines(startLine, nextLine, 0, true)\n        });\n\n        return true;\n    };\n\n},{\"../common/html_blocks\":2}],29:[function(require,module,exports){\n// lheading (---, ===)\n\n    'use strict';\n\n\n    module.exports = function lheading(state, startLine, endLine/*, silent*/) {\n        var marker, pos, max,\n            next = startLine + 1;\n\n        if (next >= endLine) { return false; }\n        if (state.tShift[next] < state.blkIndent) { return false; }\n\n        // Scan next line\n\n        if (state.tShift[next] - state.blkIndent > 3) { return false; }\n\n        pos = state.bMarks[next] + state.tShift[next];\n        max = state.eMarks[next];\n\n        if (pos >= max) { return false; }\n\n        marker = state.src.charCodeAt(pos);\n\n        if (marker !== 0x2D/* - */ && marker !== 0x3D/* = */) { return false; }\n\n        pos = state.skipChars(pos, marker);\n\n        pos = state.skipSpaces(pos);\n\n        if (pos < max) { return false; }\n\n        pos = state.bMarks[startLine] + state.tShift[startLine];\n\n        state.line = next + 1;\n        state.tokens.push({\n            type: 'heading_open',\n            hLevel: marker === 0x3D/* = */ ? 1 : 2,\n            lines: [ startLine, state.line ],\n            level: state.level\n        });\n        state.tokens.push({\n            type: 'inline',\n            content: state.src.slice(pos, state.eMarks[startLine]).trim(),\n            level: state.level + 1,\n            lines: [ startLine, state.line - 1 ],\n            children: []\n        });\n        state.tokens.push({\n            type: 'heading_close',\n            hLevel: marker === 0x3D/* = */ ? 1 : 2,\n            level: state.level\n        });\n\n        return true;\n    };\n\n},{}],30:[function(require,module,exports){\n// Lists\n\n    'use strict';\n\n\n// Search `[-+*][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\n    function skipBulletListMarker(state, startLine) {\n        var marker, pos, max;\n\n        pos = state.bMarks[startLine] + state.tShift[startLine];\n        max = state.eMarks[startLine];\n\n        if (pos >= max) { return -1; }\n\n        marker = state.src.charCodeAt(pos++);\n        // Check bullet\n        if (marker !== 0x2A/* * */ &&\n            marker !== 0x2D/* - */ &&\n            marker !== 0x2B/* + */) {\n            return -1;\n        }\n\n        if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\n            // \" 1.test \" - is not a list item\n            return -1;\n        }\n\n        return pos;\n    }\n\n// Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\n    function skipOrderedListMarker(state, startLine) {\n        var ch,\n            pos = state.bMarks[startLine] + state.tShift[startLine],\n            max = state.eMarks[startLine];\n\n        if (pos + 1 >= max) { return -1; }\n\n        ch = state.src.charCodeAt(pos++);\n\n        if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n        for (;;) {\n            // EOL -> fail\n            if (pos >= max) { return -1; }\n\n            ch = state.src.charCodeAt(pos++);\n\n            if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n                continue;\n            }\n\n            // found valid marker\n            if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n                break;\n            }\n\n            return -1;\n        }\n\n\n        if (pos < max && state.src.charCodeAt(pos) !== 0x20/* space */) {\n            // \" 1.test \" - is not a list item\n            return -1;\n        }\n        return pos;\n    }\n\n    function markTightParagraphs(state, idx) {\n        var i, l,\n            level = state.level + 2;\n\n        for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n            if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n                state.tokens[i + 2].tight = true;\n                state.tokens[i].tight = true;\n                i += 2;\n            }\n        }\n    }\n\n\n    module.exports = function list(state, startLine, endLine, silent) {\n        var nextLine,\n            indent,\n            oldTShift,\n            oldIndent,\n            oldTight,\n            oldParentType,\n            start,\n            posAfterMarker,\n            max,\n            indentAfterMarker,\n            markerValue,\n            markerCharCode,\n            isOrdered,\n            contentStart,\n            listTokIdx,\n            prevEmptyEnd,\n            listLines,\n            itemLines,\n            tight = true,\n            terminatorRules,\n            i, l, terminate;\n\n        // Detect list type and position after marker\n        if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n            isOrdered = true;\n        } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n            isOrdered = false;\n        } else {\n            return false;\n        }\n\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        // We should terminate list on style change. Remember first one to compare.\n        markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n        // For validation mode we can terminate immediately\n        if (silent) { return true; }\n\n        // Start list\n        listTokIdx = state.tokens.length;\n\n        if (isOrdered) {\n            start = state.bMarks[startLine] + state.tShift[startLine];\n            markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\n            state.tokens.push({\n                type: 'ordered_list_open',\n                order: markerValue,\n                lines: listLines = [ startLine, 0 ],\n                level: state.level++\n            });\n\n        } else {\n            state.tokens.push({\n                type: 'bullet_list_open',\n                lines: listLines = [ startLine, 0 ],\n                level: state.level++\n            });\n        }\n\n        //\n        // Iterate list items\n        //\n\n        nextLine = startLine;\n        prevEmptyEnd = false;\n        terminatorRules = state.parser.ruler.getRules('list');\n\n        while (nextLine < endLine) {\n            contentStart = state.skipSpaces(posAfterMarker);\n            max = state.eMarks[nextLine];\n\n            if (contentStart >= max) {\n                // trimming space in \"-    \\n  3\" case, indent is 1 here\n                indentAfterMarker = 1;\n            } else {\n                indentAfterMarker = contentStart - posAfterMarker;\n            }\n\n            // If we have more than 4 spaces, the indent is 1\n            // (the rest is just indented code block)\n            if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n            // If indent is less than 1, assume that it's one, example:\n            //  \"-\\n  test\"\n            if (indentAfterMarker < 1) { indentAfterMarker = 1; }\n\n            // \"  -  test\"\n            //  ^^^^^ - calculating total length of this thing\n            indent = (posAfterMarker - state.bMarks[nextLine]) + indentAfterMarker;\n\n            // Run subparser & write tokens\n            state.tokens.push({\n                type: 'list_item_open',\n                lines: itemLines = [ startLine, 0 ],\n                level: state.level++\n            });\n\n            oldIndent = state.blkIndent;\n            oldTight = state.tight;\n            oldTShift = state.tShift[startLine];\n            oldParentType = state.parentType;\n            state.tShift[startLine] = contentStart - state.bMarks[startLine];\n            state.blkIndent = indent;\n            state.tight = true;\n            state.parentType = 'list';\n\n            state.parser.tokenize(state, startLine, endLine, true);\n\n            // If any of list item is tight, mark list as tight\n            if (!state.tight || prevEmptyEnd) {\n                tight = false;\n            }\n            // Item become loose if finish with empty line,\n            // but we should filter last element, because it means list finish\n            prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n            state.blkIndent = oldIndent;\n            state.tShift[startLine] = oldTShift;\n            state.tight = oldTight;\n            state.parentType = oldParentType;\n\n            state.tokens.push({\n                type: 'list_item_close',\n                level: --state.level\n            });\n\n            nextLine = startLine = state.line;\n            itemLines[1] = nextLine;\n            contentStart = state.bMarks[startLine];\n\n            if (nextLine >= endLine) { break; }\n\n            if (state.isEmpty(nextLine)) {\n                break;\n            }\n\n            //\n            // Try to check if list is terminated or continued.\n            //\n            if (state.tShift[nextLine] < state.blkIndent) { break; }\n\n            // fail if terminating block found\n            terminate = false;\n            for (i = 0, l = terminatorRules.length; i < l; i++) {\n                if (terminatorRules[i](state, nextLine, endLine, true)) {\n                    terminate = true;\n                    break;\n                }\n            }\n            if (terminate) { break; }\n\n            // fail if list has another type\n            if (isOrdered) {\n                posAfterMarker = skipOrderedListMarker(state, nextLine);\n                if (posAfterMarker < 0) { break; }\n            } else {\n                posAfterMarker = skipBulletListMarker(state, nextLine);\n                if (posAfterMarker < 0) { break; }\n            }\n\n            if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n        }\n\n        // Finilize list\n        state.tokens.push({\n            type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',\n            level: --state.level\n        });\n        listLines[1] = nextLine;\n\n        state.line = nextLine;\n\n        // mark paragraphs tight if needed\n        if (tight) {\n            markTightParagraphs(state, listTokIdx);\n        }\n\n        return true;\n    };\n\n},{}],31:[function(require,module,exports){\n// Paragraph\n\n    'use strict';\n\n\n    module.exports = function paragraph(state, startLine/*, endLine*/) {\n        var endLine, content, terminate, i, l,\n            nextLine = startLine + 1,\n            terminatorRules;\n\n        endLine = state.lineMax;\n\n        // jump line-by-line until empty one or EOF\n        if (nextLine < endLine && !state.isEmpty(nextLine)) {\n            terminatorRules = state.parser.ruler.getRules('paragraph');\n\n            for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n                // this would be a code block normally, but after paragraph\n                // it's considered a lazy continuation regardless of what's there\n                if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }\n\n                // Some tags can terminate paragraph without empty line.\n                terminate = false;\n                for (i = 0, l = terminatorRules.length; i < l; i++) {\n                    if (terminatorRules[i](state, nextLine, endLine, true)) {\n                        terminate = true;\n                        break;\n                    }\n                }\n                if (terminate) { break; }\n            }\n        }\n\n        content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n        state.line = nextLine;\n        if (content.length) {\n            state.tokens.push({\n                type: 'paragraph_open',\n                tight: false,\n                lines: [ startLine, state.line ],\n                level: state.level\n            });\n            state.tokens.push({\n                type: 'inline',\n                content: content,\n                level: state.level + 1,\n                lines: [ startLine, state.line ],\n                children: []\n            });\n            state.tokens.push({\n                type: 'paragraph_close',\n                tight: false,\n                level: state.level\n            });\n        }\n\n        return true;\n    };\n\n},{}],32:[function(require,module,exports){\n// Parser state class\n\n    'use strict';\n\n\n    function StateBlock(src, parser, options, env, tokens) {\n        var ch, s, start, pos, len, indent, indent_found;\n\n        this.src = src;\n\n        // Shortcuts to simplify nested calls\n        this.parser = parser;\n\n        this.options = options;\n\n        this.env = env;\n\n        //\n        // Internal state vartiables\n        //\n\n        this.tokens = tokens;\n\n        this.bMarks = [];  // line begin offsets for fast jumps\n        this.eMarks = [];  // line end offsets for fast jumps\n        this.tShift = [];  // indent for each line\n\n        // block parser variables\n        this.blkIndent  = 0; // required block content indent\n                             // (for example, if we are in list)\n        this.line       = 0; // line index in src\n        this.lineMax    = 0; // lines count\n        this.tight      = false;  // loose/tight mode for lists\n        this.parentType = 'root'; // if `list`, block parser stops on two newlines\n        this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n\n        this.level = 0;\n\n        // renderer\n        this.result = '';\n\n        // Create caches\n        // Generate markers.\n        s = this.src;\n        indent = 0;\n        indent_found = false;\n\n        for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n            ch = s.charCodeAt(pos);\n\n            if (!indent_found) {\n                if (ch === 0x20/* space */) {\n                    indent++;\n                    continue;\n                } else {\n                    indent_found = true;\n                }\n            }\n\n            if (ch === 0x0A || pos === len - 1) {\n                if (ch !== 0x0A) { pos++; }\n                this.bMarks.push(start);\n                this.eMarks.push(pos);\n                this.tShift.push(indent);\n\n                indent_found = false;\n                indent = 0;\n                start = pos + 1;\n            }\n        }\n\n        // Push fake entry to simplify cache bounds checks\n        this.bMarks.push(s.length);\n        this.eMarks.push(s.length);\n        this.tShift.push(0);\n\n        this.lineMax = this.bMarks.length - 1; // don't count last fake line\n    }\n\n    StateBlock.prototype.isEmpty = function isEmpty(line) {\n        return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n    };\n\n    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n        for (var max = this.lineMax; from < max; from++) {\n            if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n                break;\n            }\n        }\n        return from;\n    };\n\n// Skip spaces from given position.\n    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n        for (var max = this.src.length; pos < max; pos++) {\n            if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }\n        }\n        return pos;\n    };\n\n// Skip char codes from given position\n    StateBlock.prototype.skipChars = function skipChars(pos, code) {\n        for (var max = this.src.length; pos < max; pos++) {\n            if (this.src.charCodeAt(pos) !== code) { break; }\n        }\n        return pos;\n    };\n\n// Skip char codes reverse from given position - 1\n    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n        if (pos <= min) { return pos; }\n\n        while (pos > min) {\n            if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n        }\n        return pos;\n    };\n\n// cut lines range from source.\n    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n        var i, first, last, queue, shift,\n            line = begin;\n\n        if (begin >= end) {\n            return '';\n        }\n\n        // Opt: don't use push queue for single line;\n        if (line + 1 === end) {\n            first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n            last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];\n            return this.src.slice(first, last);\n        }\n\n        queue = new Array(end - begin);\n\n        for (i = 0; line < end; line++, i++) {\n            shift = this.tShift[line];\n            if (shift > indent) { shift = indent; }\n            if (shift < 0) { shift = 0; }\n\n            first = this.bMarks[line] + shift;\n\n            if (line + 1 < end || keepLastLF) {\n                // No need for bounds check because we have fake entry on tail.\n                last = this.eMarks[line] + 1;\n            } else {\n                last = this.eMarks[line];\n            }\n\n            queue[i] = this.src.slice(first, last);\n        }\n\n        return queue.join('');\n    };\n\n\n    module.exports = StateBlock;\n\n},{}],33:[function(require,module,exports){\n// GFM table, non-standard\n\n    'use strict';\n\n\n    function getLine(state, line) {\n        var pos = state.bMarks[line] + state.blkIndent,\n            max = state.eMarks[line];\n\n        return state.src.substr(pos, max - pos);\n    }\n\n\n    module.exports = function table(state, startLine, endLine, silent) {\n        var ch, lineText, pos, i, nextLine, rows,\n            aligns, t, tableLines, tbodyLines;\n\n        // should have at least three lines\n        if (startLine + 2 > endLine) { return false; }\n\n        nextLine = startLine + 1;\n\n        if (state.tShift[nextLine] < state.blkIndent) { return false; }\n\n        // first character of the second line should be '|' or '-'\n\n        pos = state.bMarks[nextLine] + state.tShift[nextLine];\n        if (pos >= state.eMarks[nextLine]) { return false; }\n\n        ch = state.src.charCodeAt(pos);\n        if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }\n\n        lineText = getLine(state, startLine + 1);\n        if (!/^[-:| ]+$/.test(lineText)) { return false; }\n\n        rows = lineText.split('|');\n        if (rows <= 2) { return false; }\n        aligns = [];\n        for (i = 0; i < rows.length; i++) {\n            t = rows[i].trim();\n            if (!t) {\n                // allow empty columns before and after table, but not in between columns;\n                // e.g. allow ` |---| `, disallow ` ---||--- `\n                if (i === 0 || i === rows.length - 1) {\n                    continue;\n                } else {\n                    return false;\n                }\n            }\n\n            if (!/^:?-+:?$/.test(t)) { return false; }\n            if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n                aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');\n            } else if (t.charCodeAt(0) === 0x3A/* : */) {\n                aligns.push('left');\n            } else {\n                aligns.push('');\n            }\n        }\n\n        lineText = getLine(state, startLine).trim();\n        if (lineText.indexOf('|') === -1) { return false; }\n        rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n        if (aligns.length !== rows.length) { return false; }\n        if (silent) { return true; }\n\n        state.tokens.push({\n            type: 'table_open',\n            lines: tableLines = [ startLine, 0 ],\n            level: state.level++\n        });\n        state.tokens.push({\n            type: 'thead_open',\n            lines: [ startLine, startLine + 1 ],\n            level: state.level++\n        });\n\n        state.tokens.push({\n            type: 'tr_open',\n            lines: [ startLine, startLine + 1 ],\n            level: state.level++\n        });\n        for (i = 0; i < rows.length; i++) {\n            state.tokens.push({\n                type: 'th_open',\n                align: aligns[i],\n                lines: [ startLine, startLine + 1 ],\n                level: state.level++\n            });\n            state.tokens.push({\n                type: 'inline',\n                content: rows[i].trim(),\n                lines: [ startLine, startLine + 1 ],\n                level: state.level,\n                children: []\n            });\n            state.tokens.push({ type: 'th_close', level: --state.level });\n        }\n        state.tokens.push({ type: 'tr_close', level: --state.level });\n        state.tokens.push({ type: 'thead_close', level: --state.level });\n\n        state.tokens.push({\n            type: 'tbody_open',\n            lines: tbodyLines = [ startLine + 2, 0 ],\n            level: state.level++\n        });\n\n        for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n            if (state.tShift[nextLine] < state.blkIndent) { break; }\n\n            lineText = getLine(state, nextLine).trim();\n            if (lineText.indexOf('|') === -1) { break; }\n            rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n\n            state.tokens.push({ type: 'tr_open', level: state.level++ });\n            for (i = 0; i < rows.length; i++) {\n                state.tokens.push({ type: 'td_open', align: aligns[i], level: state.level++ });\n                state.tokens.push({\n                    type: 'inline',\n                    content: rows[i].replace(/^\\|? *| *\\|?$/g, ''),\n                    level: state.level,\n                    children: []\n                });\n                state.tokens.push({ type: 'td_close', level: --state.level });\n            }\n            state.tokens.push({ type: 'tr_close', level: --state.level });\n        }\n        state.tokens.push({ type: 'tbody_close', level: --state.level });\n        state.tokens.push({ type: 'table_close', level: --state.level });\n\n        tableLines[1] = tbodyLines[1] = nextLine;\n        state.line = nextLine;\n        return true;\n    };\n\n},{}],34:[function(require,module,exports){\n// Parse abbreviation definitions, i.e. `*[abbr]: description`\n//\n\n    'use strict';\n\n\n    var StateInline    = require('../rules_inline/state_inline');\n    var parseLinkLabel = require('../helpers/parse_link_label');\n\n\n    function parseAbbr(str, parserInline, options, env) {\n        var state, labelEnd, pos, max, label, title;\n\n        if (str.charCodeAt(0) !== 0x2A/* * */) { return -1; }\n        if (str.charCodeAt(1) !== 0x5B/* [ */) { return -1; }\n\n        if (str.indexOf(']:') === -1) { return -1; }\n\n        state = new StateInline(str, parserInline, options, env, []);\n        labelEnd = parseLinkLabel(state, 1);\n\n        if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }\n\n        max = state.posMax;\n\n        // abbr title is always one line, so looking for ending \"\\n\" here\n        for (pos = labelEnd + 2; pos < max; pos++) {\n            if (state.src.charCodeAt(pos) === 0x0A) { break; }\n        }\n\n        label = str.slice(2, labelEnd);\n        title = str.slice(labelEnd + 2, pos).trim();\n        if (title.length === 0) { return -1; }\n        if (!env.abbreviations) { env.abbreviations = {}; }\n        // prepend ':' to avoid conflict with Object.prototype members\n        if (typeof env.abbreviations[':' + label] === 'undefined') {\n            env.abbreviations[':' + label] = title;\n        }\n\n        return pos;\n    }\n\n    module.exports = function abbr(state) {\n        var tokens = state.tokens, i, l, content, pos;\n\n        if (state.inlineMode) {\n            return;\n        }\n\n        // Parse inlines\n        for (i = 1, l = tokens.length - 1; i < l; i++) {\n            if (tokens[i - 1].type === 'paragraph_open' &&\n                tokens[i].type === 'inline' &&\n                tokens[i + 1].type === 'paragraph_close') {\n\n                content = tokens[i].content;\n                while (content.length) {\n                    pos = parseAbbr(content, state.inline, state.options, state.env);\n                    if (pos < 0) { break; }\n                    content = content.slice(pos).trim();\n                }\n\n                tokens[i].content = content;\n                if (!content.length) {\n                    tokens[i - 1].tight = true;\n                    tokens[i + 1].tight = true;\n                }\n            }\n        }\n    };\n\n},{\"../helpers/parse_link_label\":12,\"../rules_inline/state_inline\":56}],35:[function(require,module,exports){\n// Enclose abbreviations in <abbr> tags\n//\n    'use strict';\n\n\n    var PUNCT_CHARS = ' \\n()[]\\'\".,!?-';\n\n\n// from Google closure library\n// http://closure-library.googlecode.com/git-history/docs/local_closure_goog_string_string.js.source.html#line1021\n    function regEscape(s) {\n        return s.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1');\n    }\n\n\n    module.exports = function abbr2(state) {\n        var i, j, l, tokens, token, text, nodes, pos, level, reg, m, regText,\n            blockTokens = state.tokens;\n\n        if (!state.env.abbreviations) { return; }\n        if (!state.env.abbrRegExp) {\n            regText = '(^|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])'\n                + '(' + Object.keys(state.env.abbreviations).map(function (x) {\n                    return x.substr(1);\n                }).sort(function (a, b) {\n                    return b.length - a.length;\n                }).map(regEscape).join('|') + ')'\n                + '($|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])';\n            state.env.abbrRegExp = new RegExp(regText, 'g');\n        }\n        reg = state.env.abbrRegExp;\n\n        for (j = 0, l = blockTokens.length; j < l; j++) {\n            if (blockTokens[j].type !== 'inline') { continue; }\n            tokens = blockTokens[j].children;\n\n            // We scan from the end, to keep position when new tags added.\n            for (i = tokens.length - 1; i >= 0; i--) {\n                token = tokens[i];\n                if (token.type !== 'text') { continue; }\n\n                pos = 0;\n                text = token.content;\n                reg.lastIndex = 0;\n                level = token.level;\n                nodes = [];\n\n                while ((m = reg.exec(text))) {\n                    if (reg.lastIndex > pos) {\n                        nodes.push({\n                            type: 'text',\n                            content: text.slice(pos, m.index + m[1].length),\n                            level: level\n                        });\n                    }\n\n                    nodes.push({\n                        type: 'abbr_open',\n                        title: state.env.abbreviations[':' + m[2]],\n                        level: level++\n                    });\n                    nodes.push({\n                        type: 'text',\n                        content: m[2],\n                        level: level\n                    });\n                    nodes.push({\n                        type: 'abbr_close',\n                        level: --level\n                    });\n                    pos = reg.lastIndex - m[3].length;\n                }\n\n                if (!nodes.length) { continue; }\n\n                if (pos < text.length) {\n                    nodes.push({\n                        type: 'text',\n                        content: text.slice(pos),\n                        level: level\n                    });\n                }\n\n                // replace current node\n                blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n            }\n        }\n    };\n\n},{}],36:[function(require,module,exports){\n    'use strict';\n\n    module.exports = function block(state) {\n\n        if (state.inlineMode) {\n            state.tokens.push({\n                type: 'inline',\n                content: state.src.replace(/\\n/g, ' ').trim(),\n                level: 0,\n                lines: [ 0, 1 ],\n                children: []\n            });\n\n        } else {\n            state.block.parse(state.src, state.options, state.env, state.tokens);\n        }\n    };\n\n},{}],37:[function(require,module,exports){\n    'use strict';\n\n\n    module.exports = function footnote_block(state) {\n        var i, l, j, t, lastParagraph, list, tokens, current, currentLabel,\n            level = 0,\n            insideRef = false,\n            refTokens = {};\n\n        if (!state.env.footnotes) { return; }\n\n        state.tokens = state.tokens.filter(function(tok) {\n            if (tok.type === 'footnote_reference_open') {\n                insideRef = true;\n                current = [];\n                currentLabel = tok.label;\n                return false;\n            }\n            if (tok.type === 'footnote_reference_close') {\n                insideRef = false;\n                // prepend ':' to avoid conflict with Object.prototype members\n                refTokens[':' + currentLabel] = current;\n                return false;\n            }\n            if (insideRef) { current.push(tok); }\n            return !insideRef;\n        });\n\n        if (!state.env.footnotes.list) { return; }\n        list = state.env.footnotes.list;\n\n        state.tokens.push({\n            type: 'footnote_block_open',\n            level: level++\n        });\n        for (i = 0, l = list.length; i < l; i++) {\n            state.tokens.push({\n                type: 'footnote_open',\n                id: i,\n                level: level++\n            });\n\n            if (list[i].tokens) {\n                tokens = [];\n                tokens.push({\n                    type: 'paragraph_open',\n                    tight: false,\n                    level: level++\n                });\n                tokens.push({\n                    type: 'inline',\n                    content: '',\n                    level: level,\n                    children: list[i].tokens\n                });\n                tokens.push({\n                    type: 'paragraph_close',\n                    tight: false,\n                    level: --level\n                });\n            } else if (list[i].label) {\n                tokens = refTokens[':' + list[i].label];\n            }\n\n            state.tokens = state.tokens.concat(tokens);\n            if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\n                lastParagraph = state.tokens.pop();\n            } else {\n                lastParagraph = null;\n            }\n\n            t = list[i].count > 0 ? list[i].count : 1;\n            for (j = 0; j < t; j++) {\n                state.tokens.push({\n                    type: 'footnote_anchor',\n                    id: i,\n                    subId: j,\n                    level: level\n                });\n            }\n\n            if (lastParagraph) {\n                state.tokens.push(lastParagraph);\n            }\n\n            state.tokens.push({\n                type: 'footnote_close',\n                level: --level\n            });\n        }\n        state.tokens.push({\n            type: 'footnote_block_close',\n            level: --level\n        });\n    };\n\n},{}],38:[function(require,module,exports){\n    'use strict';\n\n    module.exports = function inline(state) {\n        var tokens = state.tokens, tok, i, l;\n\n        // Parse inlines\n        for (i = 0, l = tokens.length; i < l; i++) {\n            tok = tokens[i];\n            if (tok.type === 'inline') {\n                state.inline.parse(tok.content, state.options, state.env, tok.children);\n            }\n        }\n    };\n\n},{}],39:[function(require,module,exports){\n// Replace link-like texts with link nodes.\n//\n// Currently restricted by `inline.validateLink()` to http/https/ftp\n//\n    'use strict';\n\n\n    var Autolinker = require('autolinker');\n\n\n    var LINK_SCAN_RE = /www|@|\\:\\/\\//;\n\n\n    function isLinkOpen(str) {\n        return /^<a[>\\s]/i.test(str);\n    }\n    function isLinkClose(str) {\n        return /^<\\/a\\s*>/i.test(str);\n    }\n\n// Stupid fabric to avoid singletons, for thread safety.\n// Required for engines like Nashorn.\n//\n    function createLinkifier() {\n        var links = [];\n        var autolinker = new Autolinker({\n            stripPrefix: false,\n            url: true,\n            email: true,\n            twitter: false,\n            replaceFn: function (linker, match) {\n                // Only collect matched strings but don't change anything.\n                switch (match.getType()) {\n                    /*eslint default-case:0*/\n                    case 'url':\n                        links.push({\n                            text: match.matchedText,\n                            url: match.getUrl()\n                        });\n                        break;\n                    case 'email':\n                        links.push({\n                            text: match.matchedText,\n                            // normalize email protocol\n                            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')\n                        });\n                        break;\n                }\n                return false;\n            }\n        });\n\n        return {\n            links: links,\n            autolinker: autolinker\n        };\n    }\n\n\n    module.exports = function linkify(state) {\n        var i, j, l, tokens, token, text, nodes, ln, pos, level, htmlLinkLevel,\n            blockTokens = state.tokens,\n            linkifier = null, links, autolinker;\n\n        if (!state.options.linkify) { return; }\n\n        for (j = 0, l = blockTokens.length; j < l; j++) {\n            if (blockTokens[j].type !== 'inline') { continue; }\n            tokens = blockTokens[j].children;\n\n            htmlLinkLevel = 0;\n\n            // We scan from the end, to keep position when new tags added.\n            // Use reversed logic in links start/end match\n            for (i = tokens.length - 1; i >= 0; i--) {\n                token = tokens[i];\n\n                // Skip content of markdown links\n                if (token.type === 'link_close') {\n                    i--;\n                    while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {\n                        i--;\n                    }\n                    continue;\n                }\n\n                // Skip content of html tag links\n                if (token.type === 'htmltag') {\n                    if (isLinkOpen(token.content) && htmlLinkLevel > 0) {\n                        htmlLinkLevel--;\n                    }\n                    if (isLinkClose(token.content)) {\n                        htmlLinkLevel++;\n                    }\n                }\n                if (htmlLinkLevel > 0) { continue; }\n\n                if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {\n\n                    // Init linkifier in lazy manner, only if required.\n                    if (!linkifier) {\n                        linkifier = createLinkifier();\n                        links = linkifier.links;\n                        autolinker = linkifier.autolinker;\n                    }\n\n                    text = token.content;\n                    links.length = 0;\n                    autolinker.link(text);\n\n                    if (!links.length) { continue; }\n\n                    // Now split string to nodes\n                    nodes = [];\n                    level = token.level;\n\n                    for (ln = 0; ln < links.length; ln++) {\n\n                        if (!state.inline.validateLink(links[ln].url)) { continue; }\n\n                        pos = text.indexOf(links[ln].text);\n\n                        if (pos) {\n                            level = level;\n                            nodes.push({\n                                type: 'text',\n                                content: text.slice(0, pos),\n                                level: level\n                            });\n                        }\n                        nodes.push({\n                            type: 'link_open',\n                            href: links[ln].url,\n                            title: '',\n                            level: level++\n                        });\n                        nodes.push({\n                            type: 'text',\n                            content: links[ln].text,\n                            level: level\n                        });\n                        nodes.push({\n                            type: 'link_close',\n                            level: --level\n                        });\n                        text = text.slice(pos + links[ln].text.length);\n                    }\n                    if (text.length) {\n                        nodes.push({\n                            type: 'text',\n                            content: text,\n                            level: level\n                        });\n                    }\n\n                    // replace current node\n                    blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n                }\n            }\n        }\n    };\n\n},{\"autolinker\":60}],40:[function(require,module,exports){\n    'use strict';\n\n\n    var StateInline          = require('../rules_inline/state_inline');\n    var parseLinkLabel       = require('../helpers/parse_link_label');\n    var parseLinkDestination = require('../helpers/parse_link_destination');\n    var parseLinkTitle       = require('../helpers/parse_link_title');\n    var normalizeReference   = require('../helpers/normalize_reference');\n\n\n    function parseReference(str, parser, options, env) {\n        var state, labelEnd, pos, max, code, start, href, title, label;\n\n        if (str.charCodeAt(0) !== 0x5B/* [ */) { return -1; }\n\n        if (str.indexOf(']:') === -1) { return -1; }\n\n        state = new StateInline(str, parser, options, env, []);\n        labelEnd = parseLinkLabel(state, 0);\n\n        if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }\n\n        max = state.posMax;\n\n        // [label]:   destination   'title'\n        //         ^^^ skip optional whitespace here\n        for (pos = labelEnd + 2; pos < max; pos++) {\n            code = state.src.charCodeAt(pos);\n            if (code !== 0x20 && code !== 0x0A) { break; }\n        }\n\n        // [label]:   destination   'title'\n        //            ^^^^^^^^^^^ parse this\n        if (!parseLinkDestination(state, pos)) { return -1; }\n        href = state.linkContent;\n        pos = state.pos;\n\n        // [label]:   destination   'title'\n        //                       ^^^ skipping those spaces\n        start = pos;\n        for (pos = pos + 1; pos < max; pos++) {\n            code = state.src.charCodeAt(pos);\n            if (code !== 0x20 && code !== 0x0A) { break; }\n        }\n\n        // [label]:   destination   'title'\n        //                          ^^^^^^^ parse this\n        if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n            title = state.linkContent;\n            pos = state.pos;\n        } else {\n            title = '';\n            pos = start;\n        }\n\n        // ensure that the end of the line is empty\n        while (pos < max && state.src.charCodeAt(pos) === 0x20/* space */) { pos++; }\n        if (pos < max && state.src.charCodeAt(pos) !== 0x0A) { return -1; }\n\n        label = normalizeReference(str.slice(1, labelEnd));\n        if (typeof env.references[label] === 'undefined') {\n            env.references[label] = { title: title, href: href };\n        }\n\n        return pos;\n    }\n\n\n    module.exports = function references(state) {\n        var tokens = state.tokens, i, l, content, pos;\n\n        state.env.references = state.env.references || {};\n\n        if (state.inlineMode) {\n            return;\n        }\n\n        // Scan definitions in paragraph inlines\n        for (i = 1, l = tokens.length - 1; i < l; i++) {\n            if (tokens[i].type === 'inline' &&\n                tokens[i - 1].type === 'paragraph_open' &&\n                tokens[i + 1].type === 'paragraph_close') {\n\n                content = tokens[i].content;\n                while (content.length) {\n                    pos = parseReference(content, state.inline, state.options, state.env);\n                    if (pos < 0) { break; }\n                    content = content.slice(pos).trim();\n                }\n\n                tokens[i].content = content;\n                if (!content.length) {\n                    tokens[i - 1].tight = true;\n                    tokens[i + 1].tight = true;\n                }\n            }\n        }\n    };\n\n},{\"../helpers/normalize_reference\":10,\"../helpers/parse_link_destination\":11,\"../helpers/parse_link_label\":12,\"../helpers/parse_link_title\":13,\"../rules_inline/state_inline\":56}],41:[function(require,module,exports){\n// Simple typographical replacements\n//\n    'use strict';\n\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾\n// - miltiplication 2 x 4 -> 2 × 4\n\n    var RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n\n    var SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\n    var SCOPED_ABBR = {\n        'c': '©',\n        'r': '®',\n        'p': '§',\n        'tm': '™'\n    };\n\n    function replaceScopedAbbr(str) {\n        if (str.indexOf('(') < 0) { return str; }\n\n        return str.replace(SCOPED_ABBR_RE, function(match, name) {\n            return SCOPED_ABBR[name.toLowerCase()];\n        });\n    }\n\n\n    module.exports = function replace(state) {\n        var i, token, text, inlineTokens, blkIdx;\n\n        if (!state.options.typographer) { return; }\n\n        for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n            if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n            inlineTokens = state.tokens[blkIdx].children;\n\n            for (i = inlineTokens.length - 1; i >= 0; i--) {\n                token = inlineTokens[i];\n                if (token.type === 'text') {\n                    text = token.content;\n\n                    text = replaceScopedAbbr(text);\n\n                    if (RARE_RE.test(text)) {\n                        text = text\n                            .replace(/\\+-/g, '±')\n                            // .., ..., ....... -> …\n                            // but ?..... & !..... -> ?.. & !..\n                            .replace(/\\.{2,}/g, '…').replace(/([?!])…/g, '$1..')\n                            .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\n                            // em-dash\n                            .replace(/(^|[^-])---([^-]|$)/mg, '$1\\u2014$2')\n                            // en-dash\n                            .replace(/(^|\\s)--(\\s|$)/mg, '$1\\u2013$2')\n                            .replace(/(^|[^-\\s])--([^-\\s]|$)/mg, '$1\\u2013$2');\n                    }\n\n                    token.content = text;\n                }\n            }\n        }\n    };\n\n},{}],42:[function(require,module,exports){\n// Convert straight quotation marks to typographic ones\n//\n    'use strict';\n\n\n    var QUOTE_TEST_RE = /['\"]/;\n    var QUOTE_RE = /['\"]/g;\n    var PUNCT_RE = /[-\\s()\\[\\]]/;\n    var APOSTROPHE = '’';\n\n// This function returns true if the character at `pos`\n// could be inside a word.\n    function isLetter(str, pos) {\n        if (pos < 0 || pos >= str.length) { return false; }\n        return !PUNCT_RE.test(str[pos]);\n    }\n\n\n    function replaceAt(str, index, ch) {\n        return str.substr(0, index) + ch + str.substr(index + 1);\n    }\n\n\n    module.exports = function smartquotes(state) {\n        /*eslint max-depth:0*/\n        var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item,\n            canOpen, canClose, j, isSingle, blkIdx, tokens,\n            stack;\n\n        if (!state.options.typographer) { return; }\n\n        stack = [];\n\n        for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n            if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n            tokens = state.tokens[blkIdx].children;\n            stack.length = 0;\n\n            for (i = 0; i < tokens.length; i++) {\n                token = tokens[i];\n\n                if (token.type !== 'text' || QUOTE_TEST_RE.test(token.text)) { continue; }\n\n                thisLevel = tokens[i].level;\n\n                for (j = stack.length - 1; j >= 0; j--) {\n                    if (stack[j].level <= thisLevel) { break; }\n                }\n                stack.length = j + 1;\n\n                text = token.content;\n                pos = 0;\n                max = text.length;\n\n                /*eslint no-labels:0,block-scoped-var:0*/\n                OUTER:\n                    while (pos < max) {\n                        QUOTE_RE.lastIndex = pos;\n                        t = QUOTE_RE.exec(text);\n                        if (!t) { break; }\n\n                        lastSpace = !isLetter(text, t.index - 1);\n                        pos = t.index + 1;\n                        isSingle = (t[0] === \"'\");\n                        nextSpace = !isLetter(text, pos);\n\n                        if (!nextSpace && !lastSpace) {\n                            // middle of word\n                            if (isSingle) {\n                                token.content = replaceAt(token.content, t.index, APOSTROPHE);\n                            }\n                            continue;\n                        }\n\n                        canOpen = !nextSpace;\n                        canClose = !lastSpace;\n\n                        if (canClose) {\n                            // this could be a closing quote, rewind the stack to get a match\n                            for (j = stack.length - 1; j >= 0; j--) {\n                                item = stack[j];\n                                if (stack[j].level < thisLevel) { break; }\n                                if (item.single === isSingle && stack[j].level === thisLevel) {\n                                    item = stack[j];\n                                    if (isSingle) {\n                                        tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);\n                                        token.content = replaceAt(token.content, t.index, state.options.quotes[3]);\n                                    } else {\n                                        tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);\n                                        token.content = replaceAt(token.content, t.index, state.options.quotes[1]);\n                                    }\n                                    stack.length = j;\n                                    continue OUTER;\n                                }\n                            }\n                        }\n\n                        if (canOpen) {\n                            stack.push({\n                                token: i,\n                                pos: t.index,\n                                single: isSingle,\n                                level: thisLevel\n                            });\n                        } else if (canClose && isSingle) {\n                            token.content = replaceAt(token.content, t.index, APOSTROPHE);\n                        }\n                    }\n            }\n        }\n    };\n\n},{}],43:[function(require,module,exports){\n// Process autolinks '<protocol:...>'\n\n    'use strict';\n\n    var url_schemas   = require('../common/url_schemas');\n    var normalizeLink = require('../helpers/normalize_link');\n\n\n    /*eslint max-len:0*/\n    var EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\n    var AUTOLINK_RE = /^<([a-zA-Z.\\-]{1,25}):([^<>\\x00-\\x20]*)>/;\n\n\n    module.exports = function autolink(state, silent) {\n        var tail, linkMatch, emailMatch, url, fullUrl, pos = state.pos;\n\n        if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n        tail = state.src.slice(pos);\n\n        if (tail.indexOf('>') < 0) { return false; }\n\n        linkMatch = tail.match(AUTOLINK_RE);\n\n        if (linkMatch) {\n            if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) { return false; }\n\n            url = linkMatch[0].slice(1, -1);\n            fullUrl = normalizeLink(url);\n            if (!state.parser.validateLink(url)) { return false; }\n\n            if (!silent) {\n                state.push({\n                    type: 'link_open',\n                    href: fullUrl,\n                    level: state.level\n                });\n                state.push({\n                    type: 'text',\n                    content: url,\n                    level: state.level + 1\n                });\n                state.push({ type: 'link_close', level: state.level });\n            }\n\n            state.pos += linkMatch[0].length;\n            return true;\n        }\n\n        emailMatch = tail.match(EMAIL_RE);\n\n        if (emailMatch) {\n\n            url = emailMatch[0].slice(1, -1);\n\n            fullUrl = normalizeLink('mailto:' + url);\n            if (!state.parser.validateLink(fullUrl)) { return false; }\n\n            if (!silent) {\n                state.push({\n                    type: 'link_open',\n                    href: fullUrl,\n                    level: state.level\n                });\n                state.push({\n                    type: 'text',\n                    content: url,\n                    level: state.level + 1\n                });\n                state.push({ type: 'link_close', level: state.level });\n            }\n\n            state.pos += emailMatch[0].length;\n            return true;\n        }\n\n        return false;\n    };\n\n},{\"../common/url_schemas\":4,\"../helpers/normalize_link\":9}],44:[function(require,module,exports){\n// Parse backticks\n\n    'use strict';\n\n    module.exports = function backticks(state, silent) {\n        var start, max, marker, matchStart, matchEnd,\n            pos = state.pos,\n            ch = state.src.charCodeAt(pos);\n\n        if (ch !== 0x60/* ` */) { return false; }\n\n        start = pos;\n        pos++;\n        max = state.posMax;\n\n        while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\n\n        marker = state.src.slice(start, pos);\n\n        matchStart = matchEnd = pos;\n\n        while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n            matchEnd = matchStart + 1;\n\n            while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\n\n            if (matchEnd - matchStart === marker.length) {\n                if (!silent) {\n                    state.push({\n                        type: 'code',\n                        content: state.src.slice(pos, matchStart)\n                            .replace(/[ \\n]+/g, ' ')\n                            .trim(),\n                        block: false,\n                        level: state.level\n                    });\n                }\n                state.pos = matchEnd;\n                return true;\n            }\n        }\n\n        if (!silent) { state.pending += marker; }\n        state.pos += marker.length;\n        return true;\n    };\n\n},{}],45:[function(require,module,exports){\n// Process ~~deleted text~~\n\n    'use strict';\n\n    module.exports = function del(state, silent) {\n        var found,\n            pos,\n            stack,\n            max = state.posMax,\n            start = state.pos,\n            lastChar,\n            nextChar;\n\n        if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }\n        if (silent) { return false; } // don't run any pairs in validation mode\n        if (start + 4 >= max) { return false; }\n        if (state.src.charCodeAt(start + 1) !== 0x7E/* ~ */) { return false; }\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n        nextChar = state.src.charCodeAt(start + 2);\n\n        if (lastChar === 0x7E/* ~ */) { return false; }\n        if (nextChar === 0x7E/* ~ */) { return false; }\n        if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n        pos = start + 2;\n        while (pos < max && state.src.charCodeAt(pos) === 0x7E/* ~ */) { pos++; }\n        if (pos > start + 3) {\n            // sequence of 4+ markers taking as literal, same as in a emphasis\n            state.pos += pos - start;\n            if (!silent) { state.pending += state.src.slice(start, pos); }\n            return true;\n        }\n\n        state.pos = start + 2;\n        stack = 1;\n\n        while (state.pos + 1 < max) {\n            if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {\n                if (state.src.charCodeAt(state.pos + 1) === 0x7E/* ~ */) {\n                    lastChar = state.src.charCodeAt(state.pos - 1);\n                    nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n                    if (nextChar !== 0x7E/* ~ */ && lastChar !== 0x7E/* ~ */) {\n                        if (lastChar !== 0x20 && lastChar !== 0x0A) {\n                            // closing '~~'\n                            stack--;\n                        } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n                            // opening '~~'\n                            stack++;\n                        } // else {\n                          //  // standalone ' ~~ ' indented with spaces\n                          // }\n                        if (stack <= 0) {\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            state.parser.skipToken(state);\n        }\n\n        if (!found) {\n            // parser failed to find ending tag, so it's not valid emphasis\n            state.pos = start;\n            return false;\n        }\n\n        // found!\n        state.posMax = state.pos;\n        state.pos = start + 2;\n\n        if (!silent) {\n            state.push({ type: 'del_open', level: state.level++ });\n            state.parser.tokenize(state);\n            state.push({ type: 'del_close', level: --state.level });\n        }\n\n        state.pos = state.posMax + 2;\n        state.posMax = max;\n        return true;\n    };\n\n},{}],46:[function(require,module,exports){\n// Process *this* and _that_\n\n    'use strict';\n\n\n    function isAlphaNum(code) {\n        return (code >= 0x30 /* 0 */ && code <= 0x39 /* 9 */) ||\n            (code >= 0x41 /* A */ && code <= 0x5A /* Z */) ||\n            (code >= 0x61 /* a */ && code <= 0x7A /* z */);\n    }\n\n// parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\n    function scanDelims(state, start) {\n        var pos = start, lastChar, nextChar, count,\n            can_open = true,\n            can_close = true,\n            max = state.posMax,\n            marker = state.src.charCodeAt(start);\n\n        lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n\n        while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }\n        if (pos >= max) { can_open = false; }\n        count = pos - start;\n\n        if (count >= 4) {\n            // sequence of four or more unescaped markers can't start/end an emphasis\n            can_open = can_close = false;\n        } else {\n            nextChar = pos < max ? state.src.charCodeAt(pos) : -1;\n\n            // check whitespace conditions\n            if (nextChar === 0x20 || nextChar === 0x0A) { can_open = false; }\n            if (lastChar === 0x20 || lastChar === 0x0A) { can_close = false; }\n\n            if (marker === 0x5F /* _ */) {\n                // check if we aren't inside the word\n                if (isAlphaNum(lastChar)) { can_open = false; }\n                if (isAlphaNum(nextChar)) { can_close = false; }\n            }\n        }\n\n        return {\n            can_open: can_open,\n            can_close: can_close,\n            delims: count\n        };\n    }\n\n    module.exports = function emphasis(state, silent) {\n        var startCount,\n            count,\n            found,\n            oldCount,\n            newCount,\n            stack,\n            res,\n            max = state.posMax,\n            start = state.pos,\n            marker = state.src.charCodeAt(start);\n\n        if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }\n        if (silent) { return false; } // don't run any pairs in validation mode\n\n        res = scanDelims(state, start);\n        startCount = res.delims;\n        if (!res.can_open) {\n            state.pos += startCount;\n            if (!silent) { state.pending += state.src.slice(start, state.pos); }\n            return true;\n        }\n\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        state.pos = start + startCount;\n        stack = [ startCount ];\n\n        while (state.pos < max) {\n            if (state.src.charCodeAt(state.pos) === marker) {\n                res = scanDelims(state, state.pos);\n                count = res.delims;\n                if (res.can_close) {\n                    oldCount = stack.pop();\n                    newCount = count;\n\n                    while (oldCount !== newCount) {\n                        if (newCount < oldCount) {\n                            stack.push(oldCount - newCount);\n                            break;\n                        }\n\n                        // assert(newCount > oldCount)\n                        newCount -= oldCount;\n\n                        if (stack.length === 0) { break; }\n                        state.pos += oldCount;\n                        oldCount = stack.pop();\n                    }\n\n                    if (stack.length === 0) {\n                        startCount = oldCount;\n                        found = true;\n                        break;\n                    }\n                    state.pos += count;\n                    continue;\n                }\n\n                if (res.can_open) { stack.push(count); }\n                state.pos += count;\n                continue;\n            }\n\n            state.parser.skipToken(state);\n        }\n\n        if (!found) {\n            // parser failed to find ending tag, so it's not valid emphasis\n            state.pos = start;\n            return false;\n        }\n\n        // found!\n        state.posMax = state.pos;\n        state.pos = start + startCount;\n\n        if (!silent) {\n            if (startCount === 2 || startCount === 3) {\n                state.push({ type: 'strong_open', level: state.level++ });\n            }\n            if (startCount === 1 || startCount === 3) {\n                state.push({ type: 'em_open', level: state.level++ });\n            }\n\n            state.parser.tokenize(state);\n\n            if (startCount === 1 || startCount === 3) {\n                state.push({ type: 'em_close', level: --state.level });\n            }\n            if (startCount === 2 || startCount === 3) {\n                state.push({ type: 'strong_close', level: --state.level });\n            }\n        }\n\n        state.pos = state.posMax + startCount;\n        state.posMax = max;\n        return true;\n    };\n\n},{}],47:[function(require,module,exports){\n// Process html entity - &#123;, &#xAF;, &quot;, ...\n\n    'use strict';\n\n    var entities          = require('../common/entities');\n    var has               = require('../common/utils').has;\n    var isValidEntityCode = require('../common/utils').isValidEntityCode;\n    var fromCodePoint     = require('../common/utils').fromCodePoint;\n\n\n    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;\n    var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;\n\n\n    module.exports = function entity(state, silent) {\n        var ch, code, match, pos = state.pos, max = state.posMax;\n\n        if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }\n\n        if (pos + 1 < max) {\n            ch = state.src.charCodeAt(pos + 1);\n\n            if (ch === 0x23 /* # */) {\n                match = state.src.slice(pos).match(DIGITAL_RE);\n                if (match) {\n                    if (!silent) {\n                        code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n                        state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n                    }\n                    state.pos += match[0].length;\n                    return true;\n                }\n            } else {\n                match = state.src.slice(pos).match(NAMED_RE);\n                if (match) {\n                    if (has(entities, match[1])) {\n                        if (!silent) { state.pending += entities[match[1]]; }\n                        state.pos += match[0].length;\n                        return true;\n                    }\n                }\n            }\n        }\n\n        if (!silent) { state.pending += '&'; }\n        state.pos++;\n        return true;\n    };\n\n},{\"../common/entities\":1,\"../common/utils\":5}],48:[function(require,module,exports){\n// Proceess escaped chars and hardbreaks\n\n    'use strict';\n\n    var ESCAPED = [];\n\n    for (var i = 0; i < 256; i++) { ESCAPED.push(0); }\n\n    '\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\n        .split('').forEach(function(ch) { ESCAPED[ch.charCodeAt(0)] = 1; });\n\n\n    module.exports = function escape(state, silent) {\n        var ch, pos = state.pos, max = state.posMax;\n\n        if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) { return false; }\n\n        pos++;\n\n        if (pos < max) {\n            ch = state.src.charCodeAt(pos);\n\n            if (ch < 256 && ESCAPED[ch] !== 0) {\n                if (!silent) { state.pending += state.src[pos]; }\n                state.pos += 2;\n                return true;\n            }\n\n            if (ch === 0x0A) {\n                if (!silent) {\n                    state.push({\n                        type: 'hardbreak',\n                        level: state.level\n                    });\n                }\n\n                pos++;\n                // skip leading whitespaces from next line\n                while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n                state.pos = pos;\n                return true;\n            }\n        }\n\n        if (!silent) { state.pending += '\\\\'; }\n        state.pos++;\n        return true;\n    };\n\n},{}],49:[function(require,module,exports){\n// Process inline footnotes (^[...])\n\n    'use strict';\n\n    var parseLinkLabel = require('../helpers/parse_link_label');\n\n\n    module.exports = function footnote_inline(state, silent) {\n        var labelStart,\n            labelEnd,\n            footnoteId,\n            oldLength,\n            max = state.posMax,\n            start = state.pos;\n\n        if (start + 2 >= max) { return false; }\n        if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n        if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        labelStart = start + 2;\n        labelEnd = parseLinkLabel(state, start + 1);\n\n        // parser failed to find ']', so it's not a valid note\n        if (labelEnd < 0) { return false; }\n\n        // We found the end of the link, and know for a fact it's a valid link;\n        // so all that's left to do is to call tokenizer.\n        //\n        if (!silent) {\n            if (!state.env.footnotes) { state.env.footnotes = {}; }\n            if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n            footnoteId = state.env.footnotes.list.length;\n\n            state.pos = labelStart;\n            state.posMax = labelEnd;\n\n            state.push({\n                type: 'footnote_ref',\n                id: footnoteId,\n                level: state.level\n            });\n            state.linkLevel++;\n            oldLength = state.tokens.length;\n            state.parser.tokenize(state);\n            state.env.footnotes.list[footnoteId] = { tokens: state.tokens.splice(oldLength) };\n            state.linkLevel--;\n        }\n\n        state.pos = labelEnd + 1;\n        state.posMax = max;\n        return true;\n    };\n\n},{\"../helpers/parse_link_label\":12}],50:[function(require,module,exports){\n// Process footnote references ([^...])\n\n    'use strict';\n\n\n    module.exports = function footnote_ref(state, silent) {\n        var label,\n            pos,\n            footnoteId,\n            footnoteSubId,\n            max = state.posMax,\n            start = state.pos;\n\n        // should be at least 4 chars - \"[^x]\"\n        if (start + 3 > max) { return false; }\n\n        if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }\n        if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }\n        if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        for (pos = start + 2; pos < max; pos++) {\n            if (state.src.charCodeAt(pos) === 0x20) { return false; }\n            if (state.src.charCodeAt(pos) === 0x0A) { return false; }\n            if (state.src.charCodeAt(pos) === 0x5D /* ] */) {\n                break;\n            }\n        }\n\n        if (pos === start + 2) { return false; } // no empty footnote labels\n        if (pos >= max) { return false; }\n        pos++;\n\n        label = state.src.slice(start + 2, pos - 1);\n        if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }\n\n        if (!silent) {\n            if (!state.env.footnotes.list) { state.env.footnotes.list = []; }\n\n            if (state.env.footnotes.refs[':' + label] < 0) {\n                footnoteId = state.env.footnotes.list.length;\n                state.env.footnotes.list[footnoteId] = { label: label, count: 0 };\n                state.env.footnotes.refs[':' + label] = footnoteId;\n            } else {\n                footnoteId = state.env.footnotes.refs[':' + label];\n            }\n\n            footnoteSubId = state.env.footnotes.list[footnoteId].count;\n            state.env.footnotes.list[footnoteId].count++;\n\n            state.push({\n                type: 'footnote_ref',\n                id: footnoteId,\n                subId: footnoteSubId,\n                level: state.level\n            });\n        }\n\n        state.pos = pos;\n        state.posMax = max;\n        return true;\n    };\n\n},{}],51:[function(require,module,exports){\n// Process html tags\n\n    'use strict';\n\n\n    var HTML_TAG_RE = require('../common/html_re').HTML_TAG_RE;\n\n\n    function isLetter(ch) {\n        /*eslint no-bitwise:0*/\n        var lc = ch | 0x20; // to lower case\n        return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n    }\n\n\n    module.exports = function htmltag(state, silent) {\n        var ch, match, max, pos = state.pos;\n\n        if (!state.options.html) { return false; }\n\n        // Check start\n        max = state.posMax;\n        if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||\n            pos + 2 >= max) {\n            return false;\n        }\n\n        // Quick fail on second char\n        ch = state.src.charCodeAt(pos + 1);\n        if (ch !== 0x21/* ! */ &&\n            ch !== 0x3F/* ? */ &&\n            ch !== 0x2F/* / */ &&\n            !isLetter(ch)) {\n            return false;\n        }\n\n        match = state.src.slice(pos).match(HTML_TAG_RE);\n        if (!match) { return false; }\n\n        if (!silent) {\n            state.push({\n                type: 'htmltag',\n                content: state.src.slice(pos, pos + match[0].length),\n                level: state.level\n            });\n        }\n        state.pos += match[0].length;\n        return true;\n    };\n\n},{\"../common/html_re\":3}],52:[function(require,module,exports){\n// Process ++inserted text++\n\n    'use strict';\n\n    module.exports = function ins(state, silent) {\n        var found,\n            pos,\n            stack,\n            max = state.posMax,\n            start = state.pos,\n            lastChar,\n            nextChar;\n\n        if (state.src.charCodeAt(start) !== 0x2B/* + */) { return false; }\n        if (silent) { return false; } // don't run any pairs in validation mode\n        if (start + 4 >= max) { return false; }\n        if (state.src.charCodeAt(start + 1) !== 0x2B/* + */) { return false; }\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n        nextChar = state.src.charCodeAt(start + 2);\n\n        if (lastChar === 0x2B/* + */) { return false; }\n        if (nextChar === 0x2B/* + */) { return false; }\n        if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n        pos = start + 2;\n        while (pos < max && state.src.charCodeAt(pos) === 0x2B/* + */) { pos++; }\n        if (pos !== start + 2) {\n            // sequence of 3+ markers taking as literal, same as in a emphasis\n            state.pos += pos - start;\n            if (!silent) { state.pending += state.src.slice(start, pos); }\n            return true;\n        }\n\n        state.pos = start + 2;\n        stack = 1;\n\n        while (state.pos + 1 < max) {\n            if (state.src.charCodeAt(state.pos) === 0x2B/* + */) {\n                if (state.src.charCodeAt(state.pos + 1) === 0x2B/* + */) {\n                    lastChar = state.src.charCodeAt(state.pos - 1);\n                    nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n                    if (nextChar !== 0x2B/* + */ && lastChar !== 0x2B/* + */) {\n                        if (lastChar !== 0x20 && lastChar !== 0x0A) {\n                            // closing '++'\n                            stack--;\n                        } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n                            // opening '++'\n                            stack++;\n                        } // else {\n                          //  // standalone ' ++ ' indented with spaces\n                          // }\n                        if (stack <= 0) {\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            state.parser.skipToken(state);\n        }\n\n        if (!found) {\n            // parser failed to find ending tag, so it's not valid emphasis\n            state.pos = start;\n            return false;\n        }\n\n        // found!\n        state.posMax = state.pos;\n        state.pos = start + 2;\n\n        if (!silent) {\n            state.push({ type: 'ins_open', level: state.level++ });\n            state.parser.tokenize(state);\n            state.push({ type: 'ins_close', level: --state.level });\n        }\n\n        state.pos = state.posMax + 2;\n        state.posMax = max;\n        return true;\n    };\n\n},{}],53:[function(require,module,exports){\n// Process [links](<to> \"stuff\")\n\n    'use strict';\n\n    var parseLinkLabel       = require('../helpers/parse_link_label');\n    var parseLinkDestination = require('../helpers/parse_link_destination');\n    var parseLinkTitle       = require('../helpers/parse_link_title');\n    var normalizeReference   = require('../helpers/normalize_reference');\n\n\n    module.exports = function links(state, silent) {\n        var labelStart,\n            labelEnd,\n            label,\n            href,\n            title,\n            pos,\n            ref,\n            code,\n            isImage = false,\n            oldPos = state.pos,\n            max = state.posMax,\n            start = state.pos,\n            marker = state.src.charCodeAt(start);\n\n        if (marker === 0x21/* ! */) {\n            isImage = true;\n            marker = state.src.charCodeAt(++start);\n        }\n\n        if (marker !== 0x5B/* [ */) { return false; }\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        labelStart = start + 1;\n        labelEnd = parseLinkLabel(state, start);\n\n        // parser failed to find ']', so it's not a valid link\n        if (labelEnd < 0) { return false; }\n\n        pos = labelEnd + 1;\n        if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n            //\n            // Inline link\n            //\n\n            // [link](  <href>  \"title\"  )\n            //        ^^ skipping these spaces\n            pos++;\n            for (; pos < max; pos++) {\n                code = state.src.charCodeAt(pos);\n                if (code !== 0x20 && code !== 0x0A) { break; }\n            }\n            if (pos >= max) { return false; }\n\n            // [link](  <href>  \"title\"  )\n            //          ^^^^^^ parsing link destination\n            start = pos;\n            if (parseLinkDestination(state, pos)) {\n                href = state.linkContent;\n                pos = state.pos;\n            } else {\n                href = '';\n            }\n\n            // [link](  <href>  \"title\"  )\n            //                ^^ skipping these spaces\n            start = pos;\n            for (; pos < max; pos++) {\n                code = state.src.charCodeAt(pos);\n                if (code !== 0x20 && code !== 0x0A) { break; }\n            }\n\n            // [link](  <href>  \"title\"  )\n            //                  ^^^^^^^ parsing link title\n            if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n                title = state.linkContent;\n                pos = state.pos;\n\n                // [link](  <href>  \"title\"  )\n                //                         ^^ skipping these spaces\n                for (; pos < max; pos++) {\n                    code = state.src.charCodeAt(pos);\n                    if (code !== 0x20 && code !== 0x0A) { break; }\n                }\n            } else {\n                title = '';\n            }\n\n            if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n                state.pos = oldPos;\n                return false;\n            }\n            pos++;\n        } else {\n            //\n            // Link reference\n            //\n\n            // do not allow nested reference links\n            if (state.linkLevel > 0) { return false; }\n\n            // [foo]  [bar]\n            //      ^^ optional whitespace (can include newlines)\n            for (; pos < max; pos++) {\n                code = state.src.charCodeAt(pos);\n                if (code !== 0x20 && code !== 0x0A) { break; }\n            }\n\n            if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n                start = pos + 1;\n                pos = parseLinkLabel(state, pos);\n                if (pos >= 0) {\n                    label = state.src.slice(start, pos++);\n                } else {\n                    pos = start - 1;\n                }\n            }\n\n            // covers label === '' and label === undefined\n            // (collapsed reference link and shortcut reference link respectively)\n            if (!label) {\n                if (typeof label === 'undefined') {\n                    pos = labelEnd + 1;\n                }\n                label = state.src.slice(labelStart, labelEnd);\n            }\n\n            ref = state.env.references[normalizeReference(label)];\n            if (!ref) {\n                state.pos = oldPos;\n                return false;\n            }\n            href = ref.href;\n            title = ref.title;\n        }\n\n        //\n        // We found the end of the link, and know for a fact it's a valid link;\n        // so all that's left to do is to call tokenizer.\n        //\n        if (!silent) {\n            state.pos = labelStart;\n            state.posMax = labelEnd;\n\n            if (isImage) {\n                state.push({\n                    type: 'image',\n                    src: href,\n                    title: title,\n                    alt: state.src.substr(labelStart, labelEnd - labelStart),\n                    level: state.level\n                });\n            } else {\n                state.push({\n                    type: 'link_open',\n                    href: href,\n                    title: title,\n                    level: state.level++\n                });\n                state.linkLevel++;\n                state.parser.tokenize(state);\n                state.linkLevel--;\n                state.push({ type: 'link_close', level: --state.level });\n            }\n        }\n\n        state.pos = pos;\n        state.posMax = max;\n        return true;\n    };\n\n},{\"../helpers/normalize_reference\":10,\"../helpers/parse_link_destination\":11,\"../helpers/parse_link_label\":12,\"../helpers/parse_link_title\":13}],54:[function(require,module,exports){\n// Process ==highlighted text==\n\n    'use strict';\n\n    module.exports = function del(state, silent) {\n        var found,\n            pos,\n            stack,\n            max = state.posMax,\n            start = state.pos,\n            lastChar,\n            nextChar;\n\n        if (state.src.charCodeAt(start) !== 0x3D/* = */) { return false; }\n        if (silent) { return false; } // don't run any pairs in validation mode\n        if (start + 4 >= max) { return false; }\n        if (state.src.charCodeAt(start + 1) !== 0x3D/* = */) { return false; }\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n        nextChar = state.src.charCodeAt(start + 2);\n\n        if (lastChar === 0x3D/* = */) { return false; }\n        if (nextChar === 0x3D/* = */) { return false; }\n        if (nextChar === 0x20 || nextChar === 0x0A) { return false; }\n\n        pos = start + 2;\n        while (pos < max && state.src.charCodeAt(pos) === 0x3D/* = */) { pos++; }\n        if (pos !== start + 2) {\n            // sequence of 3+ markers taking as literal, same as in a emphasis\n            state.pos += pos - start;\n            if (!silent) { state.pending += state.src.slice(start, pos); }\n            return true;\n        }\n\n        state.pos = start + 2;\n        stack = 1;\n\n        while (state.pos + 1 < max) {\n            if (state.src.charCodeAt(state.pos) === 0x3D/* = */) {\n                if (state.src.charCodeAt(state.pos + 1) === 0x3D/* = */) {\n                    lastChar = state.src.charCodeAt(state.pos - 1);\n                    nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n                    if (nextChar !== 0x3D/* = */ && lastChar !== 0x3D/* = */) {\n                        if (lastChar !== 0x20 && lastChar !== 0x0A) {\n                            // closing '=='\n                            stack--;\n                        } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n                            // opening '=='\n                            stack++;\n                        } // else {\n                          //  // standalone ' == ' indented with spaces\n                          // }\n                        if (stack <= 0) {\n                            found = true;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            state.parser.skipToken(state);\n        }\n\n        if (!found) {\n            // parser failed to find ending tag, so it's not valid emphasis\n            state.pos = start;\n            return false;\n        }\n\n        // found!\n        state.posMax = state.pos;\n        state.pos = start + 2;\n\n        if (!silent) {\n            state.push({ type: 'mark_open', level: state.level++ });\n            state.parser.tokenize(state);\n            state.push({ type: 'mark_close', level: --state.level });\n        }\n\n        state.pos = state.posMax + 2;\n        state.posMax = max;\n        return true;\n    };\n\n},{}],55:[function(require,module,exports){\n// Proceess '\\n'\n\n    'use strict';\n\n    module.exports = function newline(state, silent) {\n        var pmax, max, pos = state.pos;\n\n        if (state.src.charCodeAt(pos) !== 0x0A/* \\n */) { return false; }\n\n        pmax = state.pending.length - 1;\n        max = state.posMax;\n\n        // '  \\n' -> hardbreak\n        // Lookup in pending chars is bad practice! Don't copy to other rules!\n        // Pending string is stored in concat mode, indexed lookups will cause\n        // convertion to flat mode.\n        if (!silent) {\n            if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n                if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n                    state.pending = state.pending.replace(/ +$/, '');\n                    state.push({\n                        type: 'hardbreak',\n                        level: state.level\n                    });\n                } else {\n                    state.pending = state.pending.slice(0, -1);\n                    state.push({\n                        type: 'softbreak',\n                        level: state.level\n                    });\n                }\n\n            } else {\n                state.push({\n                    type: 'softbreak',\n                    level: state.level\n                });\n            }\n        }\n\n        pos++;\n\n        // skip heading spaces for next line\n        while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }\n\n        state.pos = pos;\n        return true;\n    };\n\n},{}],56:[function(require,module,exports){\n// Inline parser state\n\n    'use strict';\n\n\n    function StateInline(src, parserInline, options, env, outTokens) {\n        this.src = src;\n        this.env = env;\n        this.options = options;\n        this.parser = parserInline;\n        this.tokens = outTokens;\n        this.pos = 0;\n        this.posMax = this.src.length;\n        this.level = 0;\n        this.pending = '';\n        this.pendingLevel = 0;\n\n        this.cache = [];        // Stores { start: end } pairs. Useful for backtrack\n                                // optimization of pairs parse (emphasis, strikes).\n\n        // Link parser state vars\n\n        this.isInLabel = false; // Set true when seek link label - we should disable\n                                // \"paired\" rules (emphasis, strikes) to not skip\n                                // tailing `]`\n\n        this.linkLevel = 0;     // Increment for each nesting link. Used to prevent\n                                // nesting in definitions\n\n        this.linkContent = '';  // Temporary storage for link url\n\n        this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels\n                                       // (backtrack optimization)\n    }\n\n\n// Flush pending text\n//\n    StateInline.prototype.pushPending = function () {\n        this.tokens.push({\n            type: 'text',\n            content: this.pending,\n            level: this.pendingLevel\n        });\n        this.pending = '';\n    };\n\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\n    StateInline.prototype.push = function (token) {\n        if (this.pending) {\n            this.pushPending();\n        }\n\n        this.tokens.push(token);\n        this.pendingLevel = this.level;\n    };\n\n\n// Store value to cache.\n// !!! Implementation has parser-specific optimizations\n// !!! keys MUST be integer, >= 0; values MUST be integer, > 0\n//\n    StateInline.prototype.cacheSet = function (key, val) {\n        for (var i = this.cache.length; i <= key; i++) {\n            this.cache.push(0);\n        }\n\n        this.cache[key] = val;\n    };\n\n\n// Get cache value\n//\n    StateInline.prototype.cacheGet = function (key) {\n        return key < this.cache.length ? this.cache[key] : 0;\n    };\n\n\n    module.exports = StateInline;\n\n},{}],57:[function(require,module,exports){\n// Process ~subscript~\n\n    'use strict';\n\n// same as UNESCAPE_MD_RE plus a space\n    var UNESCAPE_RE = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\n    module.exports = function sub(state, silent) {\n        var found,\n            content,\n            max = state.posMax,\n            start = state.pos;\n\n        if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }\n        if (silent) { return false; } // don't run any pairs in validation mode\n        if (start + 2 >= max) { return false; }\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        state.pos = start + 1;\n\n        while (state.pos < max) {\n            if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {\n                found = true;\n                break;\n            }\n\n            state.parser.skipToken(state);\n        }\n\n        if (!found || start + 1 === state.pos) {\n            state.pos = start;\n            return false;\n        }\n\n        content = state.src.slice(start + 1, state.pos);\n\n        // don't allow unescaped spaces/newlines inside\n        if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n            state.pos = start;\n            return false;\n        }\n\n        // found!\n        state.posMax = state.pos;\n        state.pos = start + 1;\n\n        if (!silent) {\n            state.push({\n                type: 'sub',\n                level: state.level,\n                content: content.replace(UNESCAPE_RE, '$1')\n            });\n        }\n\n        state.pos = state.posMax + 1;\n        state.posMax = max;\n        return true;\n    };\n\n},{}],58:[function(require,module,exports){\n// Process ^superscript^\n\n    'use strict';\n\n// same as UNESCAPE_MD_RE plus a space\n    var UNESCAPE_RE = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\n    module.exports = function sup(state, silent) {\n        var found,\n            content,\n            max = state.posMax,\n            start = state.pos;\n\n        if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }\n        if (silent) { return false; } // don't run any pairs in validation mode\n        if (start + 2 >= max) { return false; }\n        if (state.level >= state.options.maxNesting) { return false; }\n\n        state.pos = start + 1;\n\n        while (state.pos < max) {\n            if (state.src.charCodeAt(state.pos) === 0x5E/* ^ */) {\n                found = true;\n                break;\n            }\n\n            state.parser.skipToken(state);\n        }\n\n        if (!found || start + 1 === state.pos) {\n            state.pos = start;\n            return false;\n        }\n\n        content = state.src.slice(start + 1, state.pos);\n\n        // don't allow unescaped spaces/newlines inside\n        if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n            state.pos = start;\n            return false;\n        }\n\n        // found!\n        state.posMax = state.pos;\n        state.pos = start + 1;\n\n        if (!silent) {\n            state.push({\n                type: 'sup',\n                level: state.level,\n                content: content.replace(UNESCAPE_RE, '$1')\n            });\n        }\n\n        state.pos = state.posMax + 1;\n        state.posMax = max;\n        return true;\n    };\n\n},{}],59:[function(require,module,exports){\n// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n    'use strict';\n\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\n    function isTerminatorChar(ch) {\n        switch (ch) {\n            case 0x0A/* \\n */:\n            case 0x5C/* \\ */:\n            case 0x60/* ` */:\n            case 0x2A/* * */:\n            case 0x5F/* _ */:\n            case 0x5E/* ^ */:\n            case 0x5B/* [ */:\n            case 0x5D/* ] */:\n            case 0x21/* ! */:\n            case 0x26/* & */:\n            case 0x3C/* < */:\n            case 0x3E/* > */:\n            case 0x7B/* { */:\n            case 0x7D/* } */:\n            case 0x24/* $ */:\n            case 0x25/* % */:\n            case 0x40/* @ */:\n            case 0x7E/* ~ */:\n            case 0x2B/* + */:\n            case 0x3D/* = */:\n            case 0x3A/* : */:\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    module.exports = function text(state, silent) {\n        var pos = state.pos;\n\n        while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n            pos++;\n        }\n\n        if (pos === state.pos) { return false; }\n\n        if (!silent) { state.pending += state.src.slice(state.pos, pos); }\n\n        state.pos = pos;\n\n        return true;\n    };\n\n},{}],60:[function(require,module,exports){\n    (function (root, factory) {\n        if (typeof define === 'function' && define.amd) {\n            // AMD. Register as an anonymous module unless amdModuleId is set\n            define([], function () {\n                return (root['Autolinker'] = factory());\n            });\n        } else if (typeof exports === 'object') {\n            // Node. Does not work with strict CommonJS, but\n            // only CommonJS-like environments that support module.exports,\n            // like Node.\n            module.exports = factory();\n        } else {\n            root['Autolinker'] = factory();\n        }\n    }(this, function () {\n\n        /*!\n         * Autolinker.js\n         * 0.15.3\n         *\n         * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>\n         * MIT Licensed. http://www.opensource.org/licenses/mit-license.php\n         *\n         * https://github.com/gregjacobs/Autolinker.js\n         */\n        /**\n         * @class Autolinker\n         * @extends Object\n         *\n         * Utility class used to process a given string of text, and wrap the URLs, email addresses, and Twitter handles in\n         * the appropriate anchor (&lt;a&gt;) tags to turn them into links.\n         *\n         * Any of the configuration options may be provided in an Object (map) provided to the Autolinker constructor, which\n         * will configure how the {@link #link link()} method will process the links.\n         *\n         * For example:\n         *\n         *     var autolinker = new Autolinker( {\n *         newWindow : false,\n *         truncate  : 30\n *     } );\n         *\n         *     var html = autolinker.link( \"Joe went to www.yahoo.com\" );\n         *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n         *\n         *\n         * The {@link #static-link static link()} method may also be used to inline options into a single call, which may\n         * be more convenient for one-off uses. For example:\n         *\n         *     var html = Autolinker.link( \"Joe went to www.yahoo.com\", {\n *         newWindow : false,\n *         truncate  : 30\n *     } );\n         *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n         *\n         *\n         * ## Custom Replacements of Links\n         *\n         * If the configuration options do not provide enough flexibility, a {@link #replaceFn} may be provided to fully customize\n         * the output of Autolinker. This function is called once for each URL/Email/Twitter handle match that is encountered.\n         *\n         * For example:\n         *\n         *     var input = \"...\";  // string with URLs, Email Addresses, and Twitter Handles\n         *\n         *     var linkedText = Autolinker.link( input, {\n *         replaceFn : function( autolinker, match ) {\n *             console.log( \"href = \", match.getAnchorHref() );\n *             console.log( \"text = \", match.getAnchorText() );\n *\n *             switch( match.getType() ) {\n *                 case 'url' :\n *                     console.log( \"url: \", match.getUrl() );\n *\n *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {\n *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes\n *                         tag.setAttr( 'rel', 'nofollow' );\n *                         tag.addClass( 'external-link' );\n *\n *                         return tag;\n *\n *                     } else {\n *                         return true;  // let Autolinker perform its normal anchor tag replacement\n *                     }\n *\n *                 case 'email' :\n *                     var email = match.getEmail();\n *                     console.log( \"email: \", email );\n *\n *                     if( email === \"my@own.address\" ) {\n *                         return false;  // don't auto-link this particular email address; leave as-is\n *                     } else {\n *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)\n *                     }\n *\n *                 case 'twitter' :\n *                     var twitterHandle = match.getTwitterHandle();\n *                     console.log( twitterHandle );\n *\n *                     return '<a href=\"http://newplace.to.link.twitter.handles.to/\">' + twitterHandle + '</a>';\n *             }\n *         }\n *     } );\n         *\n         *\n         * The function may return the following values:\n         *\n         * - `true` (Boolean): Allow Autolinker to replace the match as it normally would.\n         * - `false` (Boolean): Do not replace the current match at all - leave as-is.\n         * - Any String: If a string is returned from the function, the string will be used directly as the replacement HTML for\n         *   the match.\n         * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify an HTML tag before writing out its HTML text.\n         *\n         * @constructor\n         * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).\n         */\n        var Autolinker = function( cfg ) {\n            Autolinker.Util.assign( this, cfg );  // assign the properties of `cfg` onto the Autolinker instance. Prototype properties will be used for missing configs.\n        };\n\n\n        Autolinker.prototype = {\n            constructor : Autolinker,  // fix constructor property\n\n            /**\n             * @cfg {Boolean} urls\n             *\n             * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.\n             */\n            urls : true,\n\n            /**\n             * @cfg {Boolean} email\n             *\n             * `true` if email addresses should be automatically linked, `false` if they should not be.\n             */\n            email : true,\n\n            /**\n             * @cfg {Boolean} twitter\n             *\n             * `true` if Twitter handles (\"@example\") should be automatically linked, `false` if they should not be.\n             */\n            twitter : true,\n\n            /**\n             * @cfg {Boolean} newWindow\n             *\n             * `true` if the links should open in a new window, `false` otherwise.\n             */\n            newWindow : true,\n\n            /**\n             * @cfg {Boolean} stripPrefix\n             *\n             * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of URL links' text,\n             * `false` otherwise.\n             */\n            stripPrefix : true,\n\n            /**\n             * @cfg {Number} truncate\n             *\n             * A number for how many characters long URLs/emails/twitter handles should be truncated to inside the text of\n             * a link. If the URL/email/twitter is over this number of characters, it will be truncated to this length by\n             * adding a two period ellipsis ('..') to the end of the string.\n             *\n             * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look\n             * something like this: 'yahoo.com/some/long/pat..'\n             */\n            truncate : undefined,\n\n            /**\n             * @cfg {String} className\n             *\n             * A CSS class name to add to the generated links. This class will be added to all links, as well as this class\n             * plus url/email/twitter suffixes for styling url/email/twitter links differently.\n             *\n             * For example, if this config is provided as \"myLink\", then:\n             *\n             * - URL links will have the CSS classes: \"myLink myLink-url\"\n             * - Email links will have the CSS classes: \"myLink myLink-email\", and\n             * - Twitter links will have the CSS classes: \"myLink myLink-twitter\"\n             */\n            className : \"\",\n\n            /**\n             * @cfg {Function} replaceFn\n             *\n             * A function to individually process each URL/Email/Twitter match found in the input string.\n             *\n             * See the class's description for usage.\n             *\n             * This function is called with the following parameters:\n             *\n             * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may be used to retrieve child objects from (such\n             *   as the instance's {@link #getTagBuilder tag builder}).\n             * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which can be used to retrieve information about the\n             *   {@link Autolinker.match.Url URL}/{@link Autolinker.match.Email email}/{@link Autolinker.match.Twitter Twitter}\n             *   match that the `replaceFn` is currently processing.\n             */\n\n\n            /**\n             * @private\n             * @property {Autolinker.htmlParser.HtmlParser} htmlParser\n             *\n             * The HtmlParser instance used to skip over HTML tags, while finding text nodes to process. This is lazily instantiated\n             * in the {@link #getHtmlParser} method.\n             */\n            htmlParser : undefined,\n\n            /**\n             * @private\n             * @property {Autolinker.matchParser.MatchParser} matchParser\n             *\n             * The MatchParser instance used to find URL/email/Twitter matches in the text nodes of an input string passed to\n             * {@link #link}. This is lazily instantiated in the {@link #getMatchParser} method.\n             */\n            matchParser : undefined,\n\n            /**\n             * @private\n             * @property {Autolinker.AnchorTagBuilder} tagBuilder\n             *\n             * The AnchorTagBuilder instance used to build the URL/email/Twitter replacement anchor tags. This is lazily instantiated\n             * in the {@link #getTagBuilder} method.\n             */\n            tagBuilder : undefined,\n\n\n            /**\n             * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML.\n             * Does not link URLs found within HTML tags.\n             *\n             * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result\n             * will be `You should go to &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n             *\n             * This method finds the text around any HTML elements in the input `textOrHtml`, which will be the text that is processed.\n             * Any original HTML elements will be left as-is, as well as the text that is already wrapped in anchor (&lt;a&gt;) tags.\n             *\n             * @param {String} textOrHtml The HTML or text to link URLs, email addresses, and Twitter handles within (depending on if\n             *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).\n             * @return {String} The HTML, with URLs/emails/Twitter handles automatically linked.\n             */\n            link : function( textOrHtml ) {\n                var htmlParser = this.getHtmlParser(),\n                    htmlNodes = htmlParser.parse( textOrHtml ),\n                    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have\n                    resultHtml = [];\n\n                for( var i = 0, len = htmlNodes.length; i < len; i++ ) {\n                    var node = htmlNodes[ i ],\n                        nodeType = node.getType(),\n                        nodeText = node.getText();\n\n                    if( nodeType === 'element' ) {\n                        // Process HTML nodes in the input `textOrHtml`\n                        if( node.getTagName() === 'a' ) {\n                            if( !node.isClosing() ) {  // it's the start <a> tag\n                                anchorTagStackCount++;\n                            } else {   // it's the end </a> tag\n                                anchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0\n                            }\n                        }\n                        resultHtml.push( nodeText );  // now add the text of the tag itself verbatim\n\n                    } else if( nodeType === 'entity' ) {\n                        resultHtml.push( nodeText );  // append HTML entity nodes (such as '&nbsp;') verbatim\n\n                    } else {\n                        // Process text nodes in the input `textOrHtml`\n                        if( anchorTagStackCount === 0 ) {\n                            // If we're not within an <a> tag, process the text node to linkify\n                            var linkifiedStr = this.linkifyStr( nodeText );\n                            resultHtml.push( linkifiedStr );\n\n                        } else {\n                            // `text` is within an <a> tag, simply append the text - we do not want to autolink anything\n                            // already within an <a>...</a> tag\n                            resultHtml.push( nodeText );\n                        }\n                    }\n                }\n\n                return resultHtml.join( \"\" );\n            },\n\n\n            /**\n             * Process the text that lies in between HTML tags, performing the anchor tag replacements for matched\n             * URLs/emails/Twitter handles, and returns the string with the replacements made.\n             *\n             * This method does the actual wrapping of URLs/emails/Twitter handles with anchor tags.\n             *\n             * @private\n             * @param {String} str The string of text to auto-link.\n             * @return {String} The text with anchor tags auto-filled.\n             */\n            linkifyStr : function( str ) {\n                return this.getMatchParser().replace( str, this.createMatchReturnVal, this );\n            },\n\n\n            /**\n             * Creates the return string value for a given match in the input string, for the {@link #processTextNode} method.\n             *\n             * This method handles the {@link #replaceFn}, if one was provided.\n             *\n             * @private\n             * @param {Autolinker.match.Match} match The Match object that represents the match.\n             * @return {String} The string that the `match` should be replaced with. This is usually the anchor tag string, but\n             *   may be the `matchStr` itself if the match is not to be replaced.\n             */\n            createMatchReturnVal : function( match ) {\n                // Handle a custom `replaceFn` being provided\n                var replaceFnResult;\n                if( this.replaceFn ) {\n                    replaceFnResult = this.replaceFn.call( this, this, match );  // Autolinker instance is the context, and the first arg\n                }\n\n                if( typeof replaceFnResult === 'string' ) {\n                    return replaceFnResult;  // `replaceFn` returned a string, use that\n\n                } else if( replaceFnResult === false ) {\n                    return match.getMatchedText();  // no replacement for the match\n\n                } else if( replaceFnResult instanceof Autolinker.HtmlTag ) {\n                    return replaceFnResult.toString();\n\n                } else {  // replaceFnResult === true, or no/unknown return value from function\n                    // Perform Autolinker's default anchor tag generation\n                    var tagBuilder = this.getTagBuilder(),\n                        anchorTag = tagBuilder.build( match );  // returns an Autolinker.HtmlTag instance\n\n                    return anchorTag.toString();\n                }\n            },\n\n\n            /**\n             * Lazily instantiates and returns the {@link #htmlParser} instance for this Autolinker instance.\n             *\n             * @protected\n             * @return {Autolinker.htmlParser.HtmlParser}\n             */\n            getHtmlParser : function() {\n                var htmlParser = this.htmlParser;\n\n                if( !htmlParser ) {\n                    htmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();\n                }\n\n                return htmlParser;\n            },\n\n\n            /**\n             * Lazily instantiates and returns the {@link #matchParser} instance for this Autolinker instance.\n             *\n             * @protected\n             * @return {Autolinker.matchParser.MatchParser}\n             */\n            getMatchParser : function() {\n                var matchParser = this.matchParser;\n\n                if( !matchParser ) {\n                    matchParser = this.matchParser = new Autolinker.matchParser.MatchParser( {\n                        urls : this.urls,\n                        email : this.email,\n                        twitter : this.twitter,\n                        stripPrefix : this.stripPrefix\n                    } );\n                }\n\n                return matchParser;\n            },\n\n\n            /**\n             * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it\n             * if it does not yet exist.\n             *\n             * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that\n             * Autolinker would normally generate, and then allow for modifications before returning it. For example:\n             *\n             *     var html = Autolinker.link( \"Test google.com\", {\n\t *         replaceFn : function( autolinker, match ) {\n\t *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance\n\t *             tag.setAttr( 'rel', 'nofollow' );\n\t *\n\t *             return tag;\n\t *         }\n\t *     } );\n             *\n             *     // generated html:\n             *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n             *\n             * @return {Autolinker.AnchorTagBuilder}\n             */\n            getTagBuilder : function() {\n                var tagBuilder = this.tagBuilder;\n\n                if( !tagBuilder ) {\n                    tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {\n                        newWindow   : this.newWindow,\n                        truncate    : this.truncate,\n                        className   : this.className\n                    } );\n                }\n\n                return tagBuilder;\n            }\n\n        };\n\n\n        /**\n         * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML.\n         * Does not link URLs found within HTML tags.\n         *\n         * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result\n         * will be `You should go to &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n         *\n         * Example:\n         *\n         *     var linkedText = Autolinker.link( \"Go to google.com\", { newWindow: false } );\n         *     // Produces: \"Go to <a href=\"http://google.com\">google.com</a>\"\n         *\n         * @static\n         * @param {String} textOrHtml The HTML or text to find URLs, email addresses, and Twitter handles within (depending on if\n         *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).\n         * @param {Object} [options] Any of the configuration options for the Autolinker class, specified in an Object (map).\n         *   See the class description for an example call.\n         * @return {String} The HTML text, with URLs automatically linked\n         */\n        Autolinker.link = function( textOrHtml, options ) {\n            var autolinker = new Autolinker( options );\n            return autolinker.link( textOrHtml );\n        };\n\n\n// Autolinker Namespaces\n        Autolinker.match = {};\n        Autolinker.htmlParser = {};\n        Autolinker.matchParser = {};\n        /*global Autolinker */\n        /*jshint eqnull:true, boss:true */\n        /**\n         * @class Autolinker.Util\n         * @singleton\n         *\n         * A few utility methods for Autolinker.\n         */\n        Autolinker.Util = {\n\n            /**\n             * @property {Function} abstractMethod\n             *\n             * A function object which represents an abstract method.\n             */\n            abstractMethod : function() { throw \"abstract\"; },\n\n\n            /**\n             * Assigns (shallow copies) the properties of `src` onto `dest`.\n             *\n             * @param {Object} dest The destination object.\n             * @param {Object} src The source object.\n             * @return {Object} The destination object (`dest`)\n             */\n            assign : function( dest, src ) {\n                for( var prop in src ) {\n                    if( src.hasOwnProperty( prop ) ) {\n                        dest[ prop ] = src[ prop ];\n                    }\n                }\n\n                return dest;\n            },\n\n\n            /**\n             * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.\n             *\n             * @param {Function} superclass The constructor function for the superclass.\n             * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the\n             *   special property `constructor`, which will be used as the new subclass's constructor function.\n             * @return {Function} The new subclass function.\n             */\n            extend : function( superclass, protoProps ) {\n                var superclassProto = superclass.prototype;\n\n                var F = function() {};\n                F.prototype = superclassProto;\n\n                var subclass;\n                if( protoProps.hasOwnProperty( 'constructor' ) ) {\n                    subclass = protoProps.constructor;\n                } else {\n                    subclass = function() { superclassProto.constructor.apply( this, arguments ); };\n                }\n\n                var subclassProto = subclass.prototype = new F();  // set up prototype chain\n                subclassProto.constructor = subclass;  // fix constructor property\n                subclassProto.superclass = superclassProto;\n\n                delete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there\n                Autolinker.Util.assign( subclassProto, protoProps );\n\n                return subclass;\n            },\n\n\n            /**\n             * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the\n             * end of the string (by default, two periods: '..'). If the `str` length does not exceed\n             * `len`, the string will be returned unchanged.\n             *\n             * @param {String} str The string to truncate and add an ellipsis to.\n             * @param {Number} truncateLen The length to truncate the string at.\n             * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`\n             *   when truncated. Defaults to '..'\n             */\n            ellipsis : function( str, truncateLen, ellipsisChars ) {\n                if( str.length > truncateLen ) {\n                    ellipsisChars = ( ellipsisChars == null ) ? '..' : ellipsisChars;\n                    str = str.substring( 0, truncateLen - ellipsisChars.length ) + ellipsisChars;\n                }\n                return str;\n            },\n\n\n            /**\n             * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).\n             *\n             * @param {Array} arr The array to find an element of.\n             * @param {*} element The element to find in the array, and return the index of.\n             * @return {Number} The index of the `element`, or -1 if it was not found.\n             */\n            indexOf : function( arr, element ) {\n                if( Array.prototype.indexOf ) {\n                    return arr.indexOf( element );\n\n                } else {\n                    for( var i = 0, len = arr.length; i < len; i++ ) {\n                        if( arr[ i ] === element ) return i;\n                    }\n                    return -1;\n                }\n            },\n\n\n\n            /**\n             * Performs the functionality of what modern browsers do when `String.prototype.split()` is called\n             * with a regular expression that contains capturing parenthesis.\n             *\n             * For example:\n             *\n             *     // Modern browsers:\n             *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]\n             *\n             *     // Old IE (including IE8):\n             *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]\n             *\n             * This method emulates the functionality of modern browsers for the old IE case.\n             *\n             * @param {String} str The string to split.\n             * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting\n             *   character(s) will be spliced into the array, as in the \"modern browsers\" example in the\n             *   description of this method.\n             *   Note #1: the supplied regular expression **must** have the 'g' flag specified.\n             *   Note #2: for simplicity's sake, the regular expression does not need\n             *   to contain capturing parenthesis - it will be assumed that any match has them.\n             * @return {String[]} The split array of strings, with the splitting character(s) included.\n             */\n            splitAndCapture : function( str, splitRegex ) {\n                if( !splitRegex.global ) throw new Error( \"`splitRegex` must have the 'g' flag set\" );\n\n                var result = [],\n                    lastIdx = 0,\n                    match;\n\n                while( match = splitRegex.exec( str ) ) {\n                    result.push( str.substring( lastIdx, match.index ) );\n                    result.push( match[ 0 ] );  // push the splitting char(s)\n\n                    lastIdx = match.index + match[ 0 ].length;\n                }\n                result.push( str.substring( lastIdx ) );\n\n                return result;\n            }\n\n        };\n        /*global Autolinker */\n        /*jshint boss:true */\n        /**\n         * @class Autolinker.HtmlTag\n         * @extends Object\n         *\n         * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.\n         *\n         * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use\n         * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.\n         *\n         * ## Examples\n         *\n         * Example instantiation:\n         *\n         *     var tag = new Autolinker.HtmlTag( {\n *         tagName : 'a',\n *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },\n *         innerHtml : 'Google'\n *     } );\n         *\n         *     tag.toString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n         *\n         *     // Individual accessor methods\n         *     tag.getTagName();                 // 'a'\n         *     tag.getAttr( 'href' );            // 'http://google.com'\n         *     tag.hasClass( 'external-link' );  // true\n         *\n         *\n         * Using mutator methods (which may be used in combination with instantiation config properties):\n         *\n         *     var tag = new Autolinker.HtmlTag();\n         *     tag.setTagName( 'a' );\n         *     tag.setAttr( 'href', 'http://google.com' );\n         *     tag.addClass( 'external-link' );\n         *     tag.setInnerHtml( 'Google' );\n         *\n         *     tag.getTagName();                 // 'a'\n         *     tag.getAttr( 'href' );            // 'http://google.com'\n         *     tag.hasClass( 'external-link' );  // true\n         *\n         *     tag.toString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n         *\n         *\n         * ## Example use within a {@link Autolinker#replaceFn replaceFn}\n         *\n         *     var html = Autolinker.link( \"Test google.com\", {\n *         replaceFn : function( autolinker, match ) {\n *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text\n *             tag.setAttr( 'rel', 'nofollow' );\n *\n *             return tag;\n *         }\n *     } );\n         *\n         *     // generated html:\n         *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n         *\n         *\n         * ## Example use with a new tag for the replacement\n         *\n         *     var html = Autolinker.link( \"Test google.com\", {\n *         replaceFn : function( autolinker, match ) {\n *             var tag = new Autolinker.HtmlTag( {\n *                 tagName : 'button',\n *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },\n *                 innerHtml : 'Load URL: ' + match.getAnchorText()\n *             } );\n *\n *             return tag;\n *         }\n *     } );\n         *\n         *     // generated html:\n         *     //   Test <button title=\"Load URL: http://google.com\">Load URL: google.com</button>\n         */\n        Autolinker.HtmlTag = Autolinker.Util.extend( Object, {\n\n            /**\n             * @cfg {String} tagName\n             *\n             * The tag name. Ex: 'a', 'button', etc.\n             *\n             * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toString}\n             * is executed.\n             */\n\n            /**\n             * @cfg {Object.<String, String>} attrs\n             *\n             * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the\n             * values are the attribute values.\n             */\n\n            /**\n             * @cfg {String} innerHtml\n             *\n             * The inner HTML for the tag.\n             *\n             * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym\n             * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}\n             * if you prefer, but this one is recommended.\n             */\n\n            /**\n             * @cfg {String} innerHTML\n             *\n             * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version\n             * for acronym names.\n             */\n\n\n            /**\n             * @protected\n             * @property {RegExp} whitespaceRegex\n             *\n             * Regular expression used to match whitespace in a string of CSS classes.\n             */\n            whitespaceRegex : /\\s+/,\n\n\n            /**\n             * @constructor\n             * @param {Object} [cfg] The configuration properties for this class, in an Object (map)\n             */\n            constructor : function( cfg ) {\n                Autolinker.Util.assign( this, cfg );\n\n                this.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym\n            },\n\n\n            /**\n             * Sets the tag name that will be used to generate the tag with.\n             *\n             * @param {String} tagName\n             * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n             */\n            setTagName : function( tagName ) {\n                this.tagName = tagName;\n                return this;\n            },\n\n\n            /**\n             * Retrieves the tag name.\n             *\n             * @return {String}\n             */\n            getTagName : function() {\n                return this.tagName || \"\";\n            },\n\n\n            /**\n             * Sets an attribute on the HtmlTag.\n             *\n             * @param {String} attrName The attribute name to set.\n             * @param {String} attrValue The attribute value to set.\n             * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n             */\n            setAttr : function( attrName, attrValue ) {\n                var tagAttrs = this.getAttrs();\n                tagAttrs[ attrName ] = attrValue;\n\n                return this;\n            },\n\n\n            /**\n             * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.\n             *\n             * @param {String} name The attribute name to retrieve.\n             * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.\n             */\n            getAttr : function( attrName ) {\n                return this.getAttrs()[ attrName ];\n            },\n\n\n            /**\n             * Sets one or more attributes on the HtmlTag.\n             *\n             * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.\n             * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n             */\n            setAttrs : function( attrs ) {\n                var tagAttrs = this.getAttrs();\n                Autolinker.Util.assign( tagAttrs, attrs );\n\n                return this;\n            },\n\n\n            /**\n             * Retrieves the attributes Object (map) for the HtmlTag.\n             *\n             * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.\n             */\n            getAttrs : function() {\n                return this.attrs || ( this.attrs = {} );\n            },\n\n\n            /**\n             * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.\n             *\n             * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).\n             * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n             */\n            setClass : function( cssClass ) {\n                return this.setAttr( 'class', cssClass );\n            },\n\n\n            /**\n             * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.\n             *\n             * @param {String} cssClass One or more space-separated CSS classes to add.\n             * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n             */\n            addClass : function( cssClass ) {\n                var classAttr = this.getClass(),\n                    whitespaceRegex = this.whitespaceRegex,\n                    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below\n                    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),\n                    newClasses = cssClass.split( whitespaceRegex ),\n                    newClass;\n\n                while( newClass = newClasses.shift() ) {\n                    if( indexOf( classes, newClass ) === -1 ) {\n                        classes.push( newClass );\n                    }\n                }\n\n                this.getAttrs()[ 'class' ] = classes.join( \" \" );\n                return this;\n            },\n\n\n            /**\n             * Convenience method to remove one or more CSS classes from the HtmlTag.\n             *\n             * @param {String} cssClass One or more space-separated CSS classes to remove.\n             * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n             */\n            removeClass : function( cssClass ) {\n                var classAttr = this.getClass(),\n                    whitespaceRegex = this.whitespaceRegex,\n                    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below\n                    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),\n                    removeClasses = cssClass.split( whitespaceRegex ),\n                    removeClass;\n\n                while( classes.length && ( removeClass = removeClasses.shift() ) ) {\n                    var idx = indexOf( classes, removeClass );\n                    if( idx !== -1 ) {\n                        classes.splice( idx, 1 );\n                    }\n                }\n\n                this.getAttrs()[ 'class' ] = classes.join( \" \" );\n                return this;\n            },\n\n\n            /**\n             * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when\n             * there are multiple.\n             *\n             * @return {String}\n             */\n            getClass : function() {\n                return this.getAttrs()[ 'class' ] || \"\";\n            },\n\n\n            /**\n             * Convenience method to check if the tag has a CSS class or not.\n             *\n             * @param {String} cssClass The CSS class to check for.\n             * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.\n             */\n            hasClass : function( cssClass ) {\n                return ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;\n            },\n\n\n            /**\n             * Sets the inner HTML for the tag.\n             *\n             * @param {String} html The inner HTML to set.\n             * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n             */\n            setInnerHtml : function( html ) {\n                this.innerHtml = html;\n\n                return this;\n            },\n\n\n            /**\n             * Retrieves the inner HTML for the tag.\n             *\n             * @return {String}\n             */\n            getInnerHtml : function() {\n                return this.innerHtml || \"\";\n            },\n\n\n            /**\n             * Override of superclass method used to generate the HTML string for the tag.\n             *\n             * @return {String}\n             */\n            toString : function() {\n                var tagName = this.getTagName(),\n                    attrsStr = this.buildAttrsStr();\n\n                attrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes\n\n                return [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( \"\" );\n            },\n\n\n            /**\n             * Support method for {@link #toString}, returns the string space-separated key=\"value\" pairs, used to populate\n             * the stringified HtmlTag.\n             *\n             * @protected\n             * @return {String} Example return: `attr1=\"value1\" attr2=\"value2\"`\n             */\n            buildAttrsStr : function() {\n                if( !this.attrs ) return \"\";  // no `attrs` Object (map) has been set, return empty string\n\n                var attrs = this.getAttrs(),\n                    attrsArr = [];\n\n                for( var prop in attrs ) {\n                    if( attrs.hasOwnProperty( prop ) ) {\n                        attrsArr.push( prop + '=\"' + attrs[ prop ] + '\"' );\n                    }\n                }\n                return attrsArr.join( \" \" );\n            }\n\n        } );\n        /*global Autolinker */\n        /*jshint sub:true */\n        /**\n         * @protected\n         * @class Autolinker.AnchorTagBuilder\n         * @extends Object\n         *\n         * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is found.\n         *\n         * Normally this class is instantiated, configured, and used internally by an {@link Autolinker} instance, but may\n         * actually be retrieved in a {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag} instances\n         * which may be modified before returning from the {@link Autolinker#replaceFn replaceFn}. For example:\n         *\n         *     var html = Autolinker.link( \"Test google.com\", {\n *         replaceFn : function( autolinker, match ) {\n *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance\n *             tag.setAttr( 'rel', 'nofollow' );\n *\n *             return tag;\n *         }\n *     } );\n         *\n         *     // generated html:\n         *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n         */\n        Autolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {\n\n            /**\n             * @cfg {Boolean} newWindow\n             * @inheritdoc Autolinker#newWindow\n             */\n\n            /**\n             * @cfg {Number} truncate\n             * @inheritdoc Autolinker#truncate\n             */\n\n            /**\n             * @cfg {String} className\n             * @inheritdoc Autolinker#className\n             */\n\n\n            /**\n             * @constructor\n             * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).\n             */\n            constructor : function( cfg ) {\n                Autolinker.Util.assign( this, cfg );\n            },\n\n\n            /**\n             * Generates the actual anchor (&lt;a&gt;) tag to use in place of the matched URL/email/Twitter text,\n             * via its `match` object.\n             *\n             * @param {Autolinker.match.Match} match The Match instance to generate an anchor tag from.\n             * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.\n             */\n            build : function( match ) {\n                var tag = new Autolinker.HtmlTag( {\n                    tagName   : 'a',\n                    attrs     : this.createAttrs( match.getType(), match.getAnchorHref() ),\n                    innerHtml : this.processAnchorText( match.getAnchorText() )\n                } );\n\n                return tag;\n            },\n\n\n            /**\n             * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;) tag being generated.\n             *\n             * @protected\n             * @param {\"url\"/\"email\"/\"twitter\"} matchType The type of match that an anchor tag is being generated for.\n             * @param {String} href The href for the anchor tag.\n             * @return {Object} A key/value Object (map) of the anchor tag's attributes.\n             */\n            createAttrs : function( matchType, anchorHref ) {\n                var attrs = {\n                    'href' : anchorHref  // we'll always have the `href` attribute\n                };\n\n                var cssClass = this.createCssClass( matchType );\n                if( cssClass ) {\n                    attrs[ 'class' ] = cssClass;\n                }\n                if( this.newWindow ) {\n                    attrs[ 'target' ] = \"_blank\";\n                }\n\n                return attrs;\n            },\n\n\n            /**\n             * Creates the CSS class that will be used for a given anchor tag, based on the `matchType` and the {@link #className}\n             * config.\n             *\n             * @private\n             * @param {\"url\"/\"email\"/\"twitter\"} matchType The type of match that an anchor tag is being generated for.\n             * @return {String} The CSS class string for the link. Example return: \"myLink myLink-url\". If no {@link #className}\n             *   was configured, returns an empty string.\n             */\n            createCssClass : function( matchType ) {\n                var className = this.className;\n\n                if( !className )\n                    return \"\";\n                else\n                    return className + \" \" + className + \"-\" + matchType;  // ex: \"myLink myLink-url\", \"myLink myLink-email\", or \"myLink myLink-twitter\"\n            },\n\n\n            /**\n             * Processes the `anchorText` by truncating the text according to the {@link #truncate} config.\n             *\n             * @private\n             * @param {String} anchorText The anchor tag's text (i.e. what will be displayed).\n             * @return {String} The processed `anchorText`.\n             */\n            processAnchorText : function( anchorText ) {\n                anchorText = this.doTruncate( anchorText );\n\n                return anchorText;\n            },\n\n\n            /**\n             * Performs the truncation of the `anchorText`, if the `anchorText` is longer than the {@link #truncate} option.\n             * Truncates the text to 2 characters fewer than the {@link #truncate} option, and adds \"..\" to the end.\n             *\n             * @private\n             * @param {String} text The anchor tag's text (i.e. what will be displayed).\n             * @return {String} The truncated anchor text.\n             */\n            doTruncate : function( anchorText ) {\n                return Autolinker.Util.ellipsis( anchorText, this.truncate || Number.POSITIVE_INFINITY );\n            }\n\n        } );\n        /*global Autolinker */\n        /**\n         * @private\n         * @class Autolinker.htmlParser.HtmlParser\n         * @extends Object\n         *\n         * An HTML parser implementation which simply walks an HTML string and returns an array of\n         * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.\n         *\n         * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, effectively ignoring / \"walking\n         * around\" HTML tags.\n         */\n        Autolinker.htmlParser.HtmlParser = Autolinker.Util.extend( Object, {\n\n            /**\n             * @private\n             * @property {RegExp} htmlRegex\n             *\n             * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and\n             * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.\n             *\n             * Capturing groups:\n             *\n             * 1. The \"!DOCTYPE\" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.\n             * 2. If it is an end tag, this group will have the '/'.\n             * 3. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)\n             */\n            htmlRegex : (function() {\n                var tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,\n                    attrNameRegex = /[^\\s\\0\"'>\\/=\\x01-\\x1F\\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char\n                    attrValueRegex = /(?:\"[^\"]*?\"|'[^']*?'|[^'\"=<>`\\s]+)/, // double quoted, single quoted, or unquoted attribute values\n                    nameEqualsValueRegex = attrNameRegex.source + '(?:\\\\s*=\\\\s*' + attrValueRegex.source + ')?';  // optional '=[value]'\n\n                return new RegExp( [\n                    // for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n                    '(?:',\n                    '<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag\n\n                    // Zero or more attributes following the tag name\n                    '(?:',\n                    '\\\\s+',  // one or more whitespace chars before an attribute\n\n                    // Either:\n                    // A. attr=\"value\", or\n                    // B. \"value\" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n                    '(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')',\n                    ')*',\n                    '>',\n                    ')',\n\n                    '|',\n\n                    // All other HTML tags (i.e. tags that are not <!DOCTYPE>)\n                    '(?:',\n                    '<(/)?',  // Beginning of a tag. Either '<' for a start tag, or '</' for an end tag.\n                              // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.\n\n                    // *** Capturing Group 3 - The tag name\n                    '(' + tagNameRegex.source + ')',\n\n                    // Zero or more attributes following the tag name\n                    '(?:',\n                    '\\\\s+',                // one or more whitespace chars before an attribute\n                    nameEqualsValueRegex,  // attr=\"value\" (with optional =\"value\" part)\n                    ')*',\n\n                    '\\\\s*/?',  // any trailing spaces and optional '/' before the closing '>'\n                    '>',\n                    ')'\n                ].join( \"\" ), 'gi' );\n            } )(),\n\n            /**\n             * @private\n             * @property {RegExp} htmlCharacterEntitiesRegex\n             *\n             * The regular expression that matches common HTML character entities.\n             *\n             * Ignoring &amp; as it could be part of a query string -- handling it separately.\n             */\n            htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,\n\n\n            /**\n             * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes} to represent\n             * the HTML structure of the input string.\n             *\n             * @param {String} html The HTML to parse.\n             * @return {Autolinker.htmlParser.HtmlNode[]}\n             */\n            parse : function( html ) {\n                var htmlRegex = this.htmlRegex,\n                    currentResult,\n                    lastIndex = 0,\n                    textAndEntityNodes,\n                    nodes = [];  // will be the result of the method\n\n                while( ( currentResult = htmlRegex.exec( html ) ) !== null ) {\n                    var tagText = currentResult[ 0 ],\n                        tagName = currentResult[ 1 ] || currentResult[ 3 ],  // The <!DOCTYPE> tag (ex: \"!DOCTYPE\"), or another tag (ex: \"a\" or \"img\")\n                        isClosingTag = !!currentResult[ 2 ],\n                        inBetweenTagsText = html.substring( lastIndex, currentResult.index );\n\n                    // Push TextNodes and EntityNodes for any text found between tags\n                    if( inBetweenTagsText ) {\n                        textAndEntityNodes = this.parseTextAndEntityNodes( inBetweenTagsText );\n                        nodes.push.apply( nodes, textAndEntityNodes );\n                    }\n\n                    // Push the ElementNode\n                    nodes.push( this.createElementNode( tagText, tagName, isClosingTag ) );\n\n                    lastIndex = currentResult.index + tagText.length;\n                }\n\n                // Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.\n                if( lastIndex < html.length ) {\n                    var text = html.substring( lastIndex );\n\n                    // Push TextNodes and EntityNodes for any text found between tags\n                    if( text ) {\n                        textAndEntityNodes = this.parseTextAndEntityNodes( text );\n                        nodes.push.apply( nodes, textAndEntityNodes );\n                    }\n                }\n\n                return nodes;\n            },\n\n\n            /**\n             * Parses text and HTML entity nodes from a given string. The input string should not have any HTML tags (elements)\n             * within it.\n             *\n             * @private\n             * @param {String} text The text to parse.\n             * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to represent the\n             *   {@link Autolinker.htmlParser.TextNode TextNodes} and {@link Autolinker.htmlParser.EntityNode EntityNodes} found.\n             */\n            parseTextAndEntityNodes : function( text ) {\n                var nodes = [],\n                    textAndEntityTokens = Autolinker.Util.splitAndCapture( text, this.htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array\n\n                // Every even numbered token is a TextNode, and every odd numbered token is an EntityNode\n                // For example: an input `text` of \"Test &quot;this&quot; today\" would turn into the\n                //   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]\n                for( var i = 0, len = textAndEntityTokens.length; i < len; i += 2 ) {\n                    var textToken = textAndEntityTokens[ i ],\n                        entityToken = textAndEntityTokens[ i + 1 ];\n\n                    if( textToken ) nodes.push( this.createTextNode( textToken ) );\n                    if( entityToken ) nodes.push( this.createEntityNode( entityToken ) );\n                }\n                return nodes;\n            },\n\n\n            /**\n             * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.\n             *\n             * @private\n             * @param {String} tagText The full text of the tag (element) that was matched, including its attributes.\n             * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would be passed to this method as \"img\".\n             * @param {Boolean} isClosingTag `true` if it's a closing tag, false otherwise.\n             * @return {Autolinker.htmlParser.ElementNode}\n             */\n            createElementNode : function( tagText, tagName, isClosingTag ) {\n                return new Autolinker.htmlParser.ElementNode( {\n                    text    : tagText,\n                    tagName : tagName.toLowerCase(),\n                    closing : isClosingTag\n                } );\n            },\n\n\n            /**\n             * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.\n             *\n             * @private\n             * @param {String} text The text that was matched for the HTML entity (such as '&amp;nbsp;').\n             * @return {Autolinker.htmlParser.EntityNode}\n             */\n            createEntityNode : function( text ) {\n                return new Autolinker.htmlParser.EntityNode( { text: text } );\n            },\n\n\n            /**\n             * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.\n             *\n             * @private\n             * @param {String} text The text that was matched.\n             * @return {Autolinker.htmlParser.TextNode}\n             */\n            createTextNode : function( text ) {\n                return new Autolinker.htmlParser.TextNode( { text: text } );\n            }\n\n        } );\n        /*global Autolinker */\n        /**\n         * @abstract\n         * @class Autolinker.htmlParser.HtmlNode\n         *\n         * Represents an HTML node found in an input string. An HTML node is one of the following:\n         *\n         * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents HTML tags.\n         * 2. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text outside or within HTML tags.\n         * 3. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents one of the known HTML\n         *    entities that Autolinker looks for. This includes common ones such as &amp;quot; and &amp;nbsp;\n         */\n        Autolinker.htmlParser.HtmlNode = Autolinker.Util.extend( Object, {\n\n            /**\n             * @cfg {String} text (required)\n             *\n             * The original text that was matched for the HtmlNode.\n             *\n             * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode}, this will be the tag's\n             *   text.\n             * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this will be the text itself.\n             * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode}, this will be the text of\n             *   the HTML entity.\n             */\n            text : \"\",\n\n\n            /**\n             * @constructor\n             * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).\n             */\n            constructor : function( cfg ) {\n                Autolinker.Util.assign( this, cfg );\n            },\n\n\n            /**\n             * Returns a string name for the type of node that this class represents.\n             *\n             * @abstract\n             * @return {String}\n             */\n            getType : Autolinker.Util.abstractMethod,\n\n\n            /**\n             * Retrieves the {@link #text} for the HtmlNode.\n             *\n             * @return {String}\n             */\n            getText : function() {\n                return this.text;\n            }\n\n        } );\n        /*global Autolinker */\n        /**\n         * @class Autolinker.htmlParser.ElementNode\n         * @extends Autolinker.htmlParser.HtmlNode\n         *\n         * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n         *\n         * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.\n         */\n        Autolinker.htmlParser.ElementNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {\n\n            /**\n             * @cfg {String} tagName (required)\n             *\n             * The name of the tag that was matched.\n             */\n            tagName : '',\n\n            /**\n             * @cfg {Boolean} closing (required)\n             *\n             * `true` if the element (tag) is a closing tag, `false` if its an opening tag.\n             */\n            closing : false,\n\n\n            /**\n             * Returns a string name for the type of node that this class represents.\n             *\n             * @return {String}\n             */\n            getType : function() {\n                return 'element';\n            },\n\n\n            /**\n             * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag, returns \"img\".\n             *\n             * @return {String}\n             */\n            getTagName : function() {\n                return this.tagName;\n            },\n\n\n            /**\n             * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt; returns\n             * `false`, while &lt;/div&gt; returns `true`.\n             *\n             * @return {Boolean}\n             */\n            isClosing : function() {\n                return this.closing;\n            }\n\n        } );\n        /*global Autolinker */\n        /**\n         * @class Autolinker.htmlParser.EntityNode\n         * @extends Autolinker.htmlParser.HtmlNode\n         *\n         * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n         * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText} method.\n         *\n         * Note that this class will only be returned from the HtmlParser for the set of checked HTML entity nodes\n         * defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.\n         *\n         * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.\n         */\n        Autolinker.htmlParser.EntityNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {\n\n            /**\n             * Returns a string name for the type of node that this class represents.\n             *\n             * @return {String}\n             */\n            getType : function() {\n                return 'entity';\n            }\n\n        } );\n        /*global Autolinker */\n        /**\n         * @class Autolinker.htmlParser.TextNode\n         * @extends Autolinker.htmlParser.HtmlNode\n         *\n         * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n         *\n         * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.\n         */\n        Autolinker.htmlParser.TextNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {\n\n            /**\n             * Returns a string name for the type of node that this class represents.\n             *\n             * @return {String}\n             */\n            getType : function() {\n                return 'text';\n            }\n\n        } );\n        /*global Autolinker */\n        /**\n         * @private\n         * @class Autolinker.matchParser.MatchParser\n         * @extends Object\n         *\n         * Used by Autolinker to parse {@link #urls URLs}, {@link #emails email addresses}, and {@link #twitter Twitter handles},\n         * given an input string of text.\n         *\n         * The MatchParser is fed a non-HTML string in order to search out URLs, email addresses and Twitter handles. Autolinker\n         * first uses the {@link HtmlParser} to \"walk around\" HTML tags, and then the text around the HTML tags is passed into\n         * the MatchParser in order to find the actual matches.\n         */\n        Autolinker.matchParser.MatchParser = Autolinker.Util.extend( Object, {\n\n            /**\n             * @cfg {Boolean} urls\n             *\n             * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.\n             */\n            urls : true,\n\n            /**\n             * @cfg {Boolean} email\n             *\n             * `true` if email addresses should be automatically linked, `false` if they should not be.\n             */\n            email : true,\n\n            /**\n             * @cfg {Boolean} twitter\n             *\n             * `true` if Twitter handles (\"@example\") should be automatically linked, `false` if they should not be.\n             */\n            twitter : true,\n\n            /**\n             * @cfg {Boolean} stripPrefix\n             *\n             * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of URL links' text\n             * in {@link Autolinker.match.Url URL matches}, `false` otherwise.\n             *\n             * TODO: Handle this before a URL Match object is instantiated.\n             */\n            stripPrefix : true,\n\n\n            /**\n             * @private\n             * @property {RegExp} matcherRegex\n             *\n             * The regular expression that matches URLs, email addresses, and Twitter handles.\n             *\n             * This regular expression has the following capturing groups:\n             *\n             * 1. Group that is used to determine if there is a Twitter handle match (i.e. \\@someTwitterUser). Simply check for its\n             *    existence to determine if there is a Twitter handle match. The next couple of capturing groups give information\n             *    about the Twitter handle match.\n             * 2. The whitespace character before the \\@sign in a Twitter handle. This is needed because there are no lookbehinds in\n             *    JS regular expressions, and can be used to reconstruct the original string in a replace().\n             * 3. The Twitter handle itself in a Twitter match. If the match is '@someTwitterUser', the handle is 'someTwitterUser'.\n             * 4. Group that matches an email address. Used to determine if the match is an email address, as well as holding the full\n             *    address. Ex: 'me@my.com'\n             * 5. Group that matches a URL in the input text. Ex: 'http://google.com', 'www.google.com', or just 'google.com'.\n             *    This also includes a path, url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor\n             * 6. Group that matches a protocol URL (i.e. 'http://google.com'). This is used to match protocol URLs with just a single\n             *    word, like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.\n             * 7. A protocol-relative ('//') match for the case of a 'www.' prefixed URL. Will be an empty string if it is not a\n             *    protocol-relative match. We need to know the character before the '//' in order to determine if it is a valid match\n             *    or the // was in a string we don't want to auto-link.\n             * 8. A protocol-relative ('//') match for the case of a known TLD prefixed URL. Will be an empty string if it is not a\n             *    protocol-relative match. See #6 for more info.\n             */\n            matcherRegex : (function() {\n                var twitterRegex = /(^|[^\\w])@(\\w{1,15})/,              // For matching a twitter handle. Ex: @gregory_jacobs\n\n                    emailRegex = /(?:[\\-;:&=\\+\\$,\\w\\.]+@)/,             // something@ for email addresses (a.k.a. local-part)\n\n                    protocolRegex = /(?:[A-Za-z][-.+A-Za-z0-9]+:(?![A-Za-z][-.+A-Za-z0-9]+:\\/\\/)(?!\\d+\\/?)(?:\\/\\/)?)/,  // match protocol, allow in format \"http://\" or \"mailto:\". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match \"link:\"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)\n                    wwwRegex = /(?:www\\.)/,                             // starting with 'www.'\n                    domainNameRegex = /[A-Za-z0-9\\.\\-]*[A-Za-z0-9\\-]/,  // anything looking at all like a domain, non-unicode domains, not ending in a period\n                    tldRegex = /\\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\\b/,   // match our known top level domains (TLDs)\n\n                    // Allow optional path, query string, and hash anchor, not ending in the following characters: \"?!:,.;\"\n                    // http://blog.codinghorror.com/the-problem-with-urls/\n                    urlSuffixRegex = /[\\-A-Za-z0-9+&@#\\/%=~_()|'$*\\[\\]?!:,.;]*[\\-A-Za-z0-9+&@#\\/%=~_()|'$*\\[\\]]/;\n\n                return new RegExp( [\n                    '(',  // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace()\n                    // *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and\n                    // *** Capturing group $3, which matches the actual twitter handle\n                    twitterRegex.source,\n                    ')',\n\n                    '|',\n\n                    '(',  // *** Capturing group $4, which is used to determine an email match\n                    emailRegex.source,\n                    domainNameRegex.source,\n                    tldRegex.source,\n                    ')',\n\n                    '|',\n\n                    '(',  // *** Capturing group $5, which is used to match a URL\n                    '(?:', // parens to cover match for protocol (optional), and domain\n                    '(',  // *** Capturing group $6, for a protocol-prefixed url (ex: http://google.com)\n                    protocolRegex.source,\n                    domainNameRegex.source,\n                    ')',\n\n                    '|',\n\n                    '(?:',  // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)\n                    '(.?//)?',  // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character\n                    wwwRegex.source,\n                    domainNameRegex.source,\n                    ')',\n\n                    '|',\n\n                    '(?:',  // non-capturing paren for known a TLD url (ex: google.com)\n                    '(.?//)?',  // *** Capturing group $8 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character\n                    domainNameRegex.source,\n                    tldRegex.source,\n                    ')',\n                    ')',\n\n                    '(?:' + urlSuffixRegex.source + ')?',  // match for path, query string, and/or hash anchor - optional\n                    ')'\n                ].join( \"\" ), 'gi' );\n            } )(),\n\n            /**\n             * @private\n             * @property {RegExp} charBeforeProtocolRelMatchRegex\n             *\n             * The regular expression used to retrieve the character before a protocol-relative URL match.\n             *\n             * This is used in conjunction with the {@link #matcherRegex}, which needs to grab the character before a protocol-relative\n             * '//' due to the lack of a negative look-behind in JavaScript regular expressions. The character before the match is stripped\n             * from the URL.\n             */\n            charBeforeProtocolRelMatchRegex : /^(.)?\\/\\//,\n\n            /**\n             * @private\n             * @property {Autolinker.MatchValidator} matchValidator\n             *\n             * The MatchValidator object, used to filter out any false positives from the {@link #matcherRegex}. See\n             * {@link Autolinker.MatchValidator} for details.\n             */\n\n\n            /**\n             * @constructor\n             * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).\n             */\n            constructor : function( cfg ) {\n                Autolinker.Util.assign( this, cfg );\n\n                this.matchValidator = new Autolinker.MatchValidator();\n            },\n\n\n            /**\n             * Parses the input `text` to search for URLs/emails/Twitter handles, and calls the `replaceFn`\n             * to allow replacements of the matches. Returns the `text` with matches replaced.\n             *\n             * @param {String} text The text to search and repace matches in.\n             * @param {Function} replaceFn The iterator function to handle the replacements. The function takes a\n             *   single argument, a {@link Autolinker.match.Match} object, and should return the text that should\n             *   make the replacement.\n             * @param {Object} [contextObj=window] The context object (\"scope\") to run the `replaceFn` in.\n             * @return {String}\n             */\n            replace : function( text, replaceFn, contextObj ) {\n                var me = this;  // for closure\n\n                return text.replace( this.matcherRegex, function( matchStr, $1, $2, $3, $4, $5, $6, $7, $8 ) {\n                    var matchDescObj = me.processCandidateMatch( matchStr, $1, $2, $3, $4, $5, $6, $7, $8 );  // \"match description\" object\n\n                    // Return out with no changes for match types that are disabled (url, email, twitter), or for matches that are\n                    // invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).\n                    if( !matchDescObj ) {\n                        return matchStr;\n\n                    } else {\n                        // Generate replacement text for the match from the `replaceFn`\n                        var replaceStr = replaceFn.call( contextObj, matchDescObj.match );\n                        return matchDescObj.prefixStr + replaceStr + matchDescObj.suffixStr;\n                    }\n                } );\n            },\n\n\n            /**\n             * Processes a candidate match from the {@link #matcherRegex}.\n             *\n             * Not all matches found by the regex are actual URL/email/Twitter matches, as determined by the {@link #matchValidator}. In\n             * this case, the method returns `null`. Otherwise, a valid Object with `prefixStr`, `match`, and `suffixStr` is returned.\n             *\n             * @private\n             * @param {String} matchStr The full match that was found by the {@link #matcherRegex}.\n             * @param {String} twitterMatch The matched text of a Twitter handle, if the match is a Twitter match.\n             * @param {String} twitterHandlePrefixWhitespaceChar The whitespace char before the @ sign in a Twitter handle match. This\n             *   is needed because of no lookbehinds in JS regexes, and is need to re-include the character for the anchor tag replacement.\n             * @param {String} twitterHandle The actual Twitter user (i.e the word after the @ sign in a Twitter match).\n             * @param {String} emailAddressMatch The matched email address for an email address match.\n             * @param {String} urlMatch The matched URL string for a URL match.\n             * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match\n             *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.\n             * @param {String} wwwProtocolRelativeMatch The '//' for a protocol-relative match from a 'www' url, with the character that\n             *   comes before the '//'.\n             * @param {String} tldProtocolRelativeMatch The '//' for a protocol-relative match from a TLD (top level domain) match, with\n             *   the character that comes before the '//'.\n             *\n             * @return {Object} A \"match description object\". This will be `null` if the match was invalid, or if a match type is disabled.\n             *   Otherwise, this will be an Object (map) with the following properties:\n             * @return {String} return.prefixStr The char(s) that should be prepended to the replacement string. These are char(s) that\n             *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into\n             *   the replacement stream.\n             * @return {String} return.suffixStr The char(s) that should be appended to the replacement string. These are char(s) that\n             *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into\n             *   the replacement stream.\n             * @return {Autolinker.match.Match} return.match The Match object that represents the match that was found.\n             */\n            processCandidateMatch : function(\n                matchStr, twitterMatch, twitterHandlePrefixWhitespaceChar, twitterHandle,\n                emailAddressMatch, urlMatch, protocolUrlMatch, wwwProtocolRelativeMatch, tldProtocolRelativeMatch\n            ) {\n                // Note: The `matchStr` variable wil be fixed up to remove characters that are no longer needed (which will\n                // be added to `prefixStr` and `suffixStr`).\n\n                var protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,\n                    match,  // Will be an Autolinker.match.Match object\n\n                    prefixStr = \"\",       // A string to use to prefix the anchor tag that is created. This is needed for the Twitter handle match\n                    suffixStr = \"\";       // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.\n\n\n                // Return out with `null` for match types that are disabled (url, email, twitter), or for matches that are\n                // invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).\n                if(\n                    ( twitterMatch && !this.twitter ) || ( emailAddressMatch && !this.email ) || ( urlMatch && !this.urls ) ||\n                    !this.matchValidator.isValidMatch( urlMatch, protocolUrlMatch, protocolRelativeMatch )\n                ) {\n                    return null;\n                }\n\n                // Handle a closing parenthesis at the end of the match, and exclude it if there is not a matching open parenthesis\n                // in the match itself.\n                if( this.matchHasUnbalancedClosingParen( matchStr ) ) {\n                    matchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing \")\"\n                    suffixStr = \")\";  // this will be added after the generated <a> tag\n                }\n\n\n                if( emailAddressMatch ) {\n                    match = new Autolinker.match.Email( { matchedText: matchStr, email: emailAddressMatch } );\n\n                } else if( twitterMatch ) {\n                    // fix up the `matchStr` if there was a preceding whitespace char, which was needed to determine the match\n                    // itself (since there are no look-behinds in JS regexes)\n                    if( twitterHandlePrefixWhitespaceChar ) {\n                        prefixStr = twitterHandlePrefixWhitespaceChar;\n                        matchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match\n                    }\n                    match = new Autolinker.match.Twitter( { matchedText: matchStr, twitterHandle: twitterHandle } );\n\n                } else {  // url match\n                    // If it's a protocol-relative '//' match, remove the character before the '//' (which the matcherRegex needed\n                    // to match due to the lack of a negative look-behind in JavaScript regular expressions)\n                    if( protocolRelativeMatch ) {\n                        var charBeforeMatch = protocolRelativeMatch.match( this.charBeforeProtocolRelMatchRegex )[ 1 ] || \"\";\n\n                        if( charBeforeMatch ) {  // fix up the `matchStr` if there was a preceding char before a protocol-relative match, which was needed to determine the match itself (since there are no look-behinds in JS regexes)\n                            prefixStr = charBeforeMatch;\n                            matchStr = matchStr.slice( 1 );  // remove the prefixed char from the match\n                        }\n                    }\n\n                    match = new Autolinker.match.Url( {\n                        matchedText : matchStr,\n                        url : matchStr,\n                        protocolUrlMatch : !!protocolUrlMatch,\n                        protocolRelativeMatch : !!protocolRelativeMatch,\n                        stripPrefix : this.stripPrefix\n                    } );\n                }\n\n                return {\n                    prefixStr : prefixStr,\n                    suffixStr : suffixStr,\n                    match     : match\n                };\n            },\n\n\n            /**\n             * Determines if a match found has an unmatched closing parenthesis. If so, this parenthesis will be removed\n             * from the match itself, and appended after the generated anchor tag in {@link #processTextNode}.\n             *\n             * A match may have an extra closing parenthesis at the end of the match because the regular expression must include parenthesis\n             * for URLs such as \"wikipedia.com/something_(disambiguation)\", which should be auto-linked.\n             *\n             * However, an extra parenthesis *will* be included when the URL itself is wrapped in parenthesis, such as in the case of\n             * \"(wikipedia.com/something_(disambiguation))\". In this case, the last closing parenthesis should *not* be part of the URL\n             * itself, and this method will return `true`.\n             *\n             * @private\n             * @param {String} matchStr The full match string from the {@link #matcherRegex}.\n             * @return {Boolean} `true` if there is an unbalanced closing parenthesis at the end of the `matchStr`, `false` otherwise.\n             */\n            matchHasUnbalancedClosingParen : function( matchStr ) {\n                var lastChar = matchStr.charAt( matchStr.length - 1 );\n\n                if( lastChar === ')' ) {\n                    var openParensMatch = matchStr.match( /\\(/g ),\n                        closeParensMatch = matchStr.match( /\\)/g ),\n                        numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,\n                        numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;\n\n                    if( numOpenParens < numCloseParens ) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n\n        } );\n        /*global Autolinker */\n        /*jshint scripturl:true */\n        /**\n         * @private\n         * @class Autolinker.MatchValidator\n         * @extends Object\n         *\n         * Used by Autolinker to filter out false positives from the {@link Autolinker#matcherRegex}.\n         *\n         * Due to the limitations of regular expressions (including the missing feature of look-behinds in JS regular expressions),\n         * we cannot always determine the validity of a given match. This class applies a bit of additional logic to filter out any\n         * false positives that have been matched by the {@link Autolinker#matcherRegex}.\n         */\n        Autolinker.MatchValidator = Autolinker.Util.extend( Object, {\n\n            /**\n             * @private\n             * @property {RegExp} invalidProtocolRelMatchRegex\n             *\n             * The regular expression used to check a potential protocol-relative URL match, coming from the\n             * {@link Autolinker#matcherRegex}. A protocol-relative URL is, for example, \"//yahoo.com\"\n             *\n             * This regular expression checks to see if there is a word character before the '//' match in order to determine if\n             * we should actually autolink a protocol-relative URL. This is needed because there is no negative look-behind in\n             * JavaScript regular expressions.\n             *\n             * For instance, we want to autolink something like \"Go to: //google.com\", but we don't want to autolink something\n             * like \"abc//google.com\"\n             */\n            invalidProtocolRelMatchRegex : /^[\\w]\\/\\//,\n\n            /**\n             * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'\n             *\n             * @private\n             * @property {RegExp} hasFullProtocolRegex\n             */\n            hasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]+:\\/\\//,\n\n            /**\n             * Regex to find the URI scheme, such as 'mailto:'.\n             *\n             * This is used to filter out 'javascript:' and 'vbscript:' schemes.\n             *\n             * @private\n             * @property {RegExp} uriSchemeRegex\n             */\n            uriSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]+:/,\n\n            /**\n             * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')\n             *\n             * @private\n             * @property {RegExp} hasWordCharAfterProtocolRegex\n             */\n            hasWordCharAfterProtocolRegex : /:[^\\s]*?[A-Za-z]/,\n\n\n            /**\n             * Determines if a given match found by {@link Autolinker#processTextNode} is valid. Will return `false` for:\n             *\n             * 1) URL matches which do not have at least have one period ('.') in the domain name (effectively skipping over\n             *    matches like \"abc:def\"). However, URL matches with a protocol will be allowed (ex: 'http://localhost')\n             * 2) URL matches which do not have at least one word character in the domain name (effectively skipping over\n             *    matches like \"git:1.0\").\n             * 3) A protocol-relative url match (a URL beginning with '//') whose previous character is a word character\n             *    (effectively skipping over strings like \"abc//google.com\")\n             *\n             * Otherwise, returns `true`.\n             *\n             * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.\n             * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match\n             *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.\n             * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding\n             *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character\n             *   preceding the '//'.\n             * @return {Boolean} `true` if the match given is valid and should be processed, or `false` if the match is invalid and/or\n             *   should just not be processed.\n             */\n            isValidMatch : function( urlMatch, protocolUrlMatch, protocolRelativeMatch ) {\n                if(\n                    ( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||\n                    this.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||       // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')\n                    this.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) ||  // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like \"git:1.0\"\n                    this.isInvalidProtocolRelativeMatch( protocolRelativeMatch )                 // A protocol-relative match which has a word character in front of it (so we can skip something like \"abc//google.com\")\n                ) {\n                    return false;\n                }\n\n                return true;\n            },\n\n\n            /**\n             * Determines if the URI scheme is a valid scheme to be autolinked. Returns `false` if the scheme is\n             * 'javascript:' or 'vbscript:'\n             *\n             * @private\n             * @param {String} uriSchemeMatch The match URL string for a full URI scheme match. Ex: 'http://yahoo.com'\n             *   or 'mailto:a@a.com'.\n             * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.\n             */\n            isValidUriScheme : function( uriSchemeMatch ) {\n                var uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ].toLowerCase();\n\n                return ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );\n            },\n\n\n            /**\n             * Determines if a URL match does not have either:\n             *\n             * a) a full protocol (i.e. 'http://'), or\n             * b) at least one dot ('.') in the domain name (for a non-full-protocol match).\n             *\n             * Either situation is considered an invalid URL (ex: 'git:d' does not have either the '://' part, or at least one dot\n             * in the domain name. If the match was 'git:abc.com', we would consider this valid.)\n             *\n             * @private\n             * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.\n             * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match\n             *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.\n             * @return {Boolean} `true` if the URL match does not have a full protocol, or at least one dot ('.') in a non-full-protocol\n             *   match.\n             */\n            urlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {\n                return ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );\n            },\n\n\n            /**\n             * Determines if a URL match does not have at least one word character after the protocol (i.e. in the domain name).\n             *\n             * At least one letter character must exist in the domain name after a protocol match. Ex: skip over something\n             * like \"git:1.0\"\n             *\n             * @private\n             * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.\n             * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to\n             *   know whether or not we have a protocol in the URL string, in order to check for a word character after the protocol\n             *   separator (':').\n             * @return {Boolean} `true` if the URL match does not have at least one word character in it after the protocol, `false`\n             *   otherwise.\n             */\n            urlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {\n                if( urlMatch && protocolUrlMatch ) {\n                    return !this.hasWordCharAfterProtocolRegex.test( urlMatch );\n                } else {\n                    return false;\n                }\n            },\n\n\n            /**\n             * Determines if a protocol-relative match is an invalid one. This method returns `true` if there is a `protocolRelativeMatch`,\n             * and that match contains a word character before the '//' (i.e. it must contain whitespace or nothing before the '//' in\n             * order to be considered valid).\n             *\n             * @private\n             * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding\n             *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character\n             *   preceding the '//'.\n             * @return {Boolean} `true` if it is an invalid protocol-relative match, `false` otherwise.\n             */\n            isInvalidProtocolRelativeMatch : function( protocolRelativeMatch ) {\n                return ( !!protocolRelativeMatch && this.invalidProtocolRelMatchRegex.test( protocolRelativeMatch ) );\n            }\n\n        } );\n        /*global Autolinker */\n        /**\n         * @abstract\n         * @class Autolinker.match.Match\n         *\n         * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a\n         * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.\n         *\n         * For example:\n         *\n         *     var input = \"...\";  // string with URLs, Email Addresses, and Twitter Handles\n         *\n         *     var linkedText = Autolinker.link( input, {\n *         replaceFn : function( autolinker, match ) {\n *             console.log( \"href = \", match.getAnchorHref() );\n *             console.log( \"text = \", match.getAnchorText() );\n *\n *             switch( match.getType() ) {\n *                 case 'url' :\n *                     console.log( \"url: \", match.getUrl() );\n *\n *                 case 'email' :\n *                     console.log( \"email: \", match.getEmail() );\n *\n *                 case 'twitter' :\n *                     console.log( \"twitter: \", match.getTwitterHandle() );\n *             }\n *         }\n *     } );\n         *\n         * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.\n         */\n        Autolinker.match.Match = Autolinker.Util.extend( Object, {\n\n            /**\n             * @cfg {String} matchedText (required)\n             *\n             * The original text that was matched.\n             */\n\n\n            /**\n             * @constructor\n             * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).\n             */\n            constructor : function( cfg ) {\n                Autolinker.Util.assign( this, cfg );\n            },\n\n\n            /**\n             * Returns a string name for the type of match that this class represents.\n             *\n             * @abstract\n             * @return {String}\n             */\n            getType : Autolinker.Util.abstractMethod,\n\n\n            /**\n             * Returns the original text that was matched.\n             *\n             * @return {String}\n             */\n            getMatchedText : function() {\n                return this.matchedText;\n            },\n\n\n            /**\n             * Returns the anchor href that should be generated for the match.\n             *\n             * @abstract\n             * @return {String}\n             */\n            getAnchorHref : Autolinker.Util.abstractMethod,\n\n\n            /**\n             * Returns the anchor text that should be generated for the match.\n             *\n             * @abstract\n             * @return {String}\n             */\n            getAnchorText : Autolinker.Util.abstractMethod\n\n        } );\n        /*global Autolinker */\n        /**\n         * @class Autolinker.match.Email\n         * @extends Autolinker.match.Match\n         *\n         * Represents a Email match found in an input string which should be Autolinked.\n         *\n         * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n         */\n        Autolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {\n\n            /**\n             * @cfg {String} email (required)\n             *\n             * The email address that was matched.\n             */\n\n\n            /**\n             * Returns a string name for the type of match that this class represents.\n             *\n             * @return {String}\n             */\n            getType : function() {\n                return 'email';\n            },\n\n\n            /**\n             * Returns the email address that was matched.\n             *\n             * @return {String}\n             */\n            getEmail : function() {\n                return this.email;\n            },\n\n\n            /**\n             * Returns the anchor href that should be generated for the match.\n             *\n             * @return {String}\n             */\n            getAnchorHref : function() {\n                return 'mailto:' + this.email;\n            },\n\n\n            /**\n             * Returns the anchor text that should be generated for the match.\n             *\n             * @return {String}\n             */\n            getAnchorText : function() {\n                return this.email;\n            }\n\n        } );\n        /*global Autolinker */\n        /**\n         * @class Autolinker.match.Twitter\n         * @extends Autolinker.match.Match\n         *\n         * Represents a Twitter match found in an input string which should be Autolinked.\n         *\n         * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n         */\n        Autolinker.match.Twitter = Autolinker.Util.extend( Autolinker.match.Match, {\n\n            /**\n             * @cfg {String} twitterHandle (required)\n             *\n             * The Twitter handle that was matched.\n             */\n\n\n            /**\n             * Returns the type of match that this class represents.\n             *\n             * @return {String}\n             */\n            getType : function() {\n                return 'twitter';\n            },\n\n\n            /**\n             * Returns a string name for the type of match that this class represents.\n             *\n             * @return {String}\n             */\n            getTwitterHandle : function() {\n                return this.twitterHandle;\n            },\n\n\n            /**\n             * Returns the anchor href that should be generated for the match.\n             *\n             * @return {String}\n             */\n            getAnchorHref : function() {\n                return 'https://twitter.com/' + this.twitterHandle;\n            },\n\n\n            /**\n             * Returns the anchor text that should be generated for the match.\n             *\n             * @return {String}\n             */\n            getAnchorText : function() {\n                return '@' + this.twitterHandle;\n            }\n\n        } );\n        /*global Autolinker */\n        /**\n         * @class Autolinker.match.Url\n         * @extends Autolinker.match.Match\n         *\n         * Represents a Url match found in an input string which should be Autolinked.\n         *\n         * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n         */\n        Autolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {\n\n            /**\n             * @cfg {String} url (required)\n             *\n             * The url that was matched.\n             */\n\n            /**\n             * @cfg {Boolean} protocolUrlMatch (required)\n             *\n             * `true` if the URL is a match which already has a protocol (i.e. 'http://'), `false` if the match was from a 'www' or\n             * known TLD match.\n             */\n\n            /**\n             * @cfg {Boolean} protocolRelativeMatch (required)\n             *\n             * `true` if the URL is a protocol-relative match. A protocol-relative match is a URL that starts with '//',\n             * and will be either http:// or https:// based on the protocol that the site is loaded under.\n             */\n\n            /**\n             * @cfg {Boolean} stripPrefix (required)\n             * @inheritdoc Autolinker#stripPrefix\n             */\n\n\n            /**\n             * @private\n             * @property {RegExp} urlPrefixRegex\n             *\n             * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.\n             */\n            urlPrefixRegex: /^(https?:\\/\\/)?(www\\.)?/i,\n\n            /**\n             * @private\n             * @property {RegExp} protocolRelativeRegex\n             *\n             * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes\n             * of {@link #getAnchorText}. A protocol-relative URL is, for example, \"//yahoo.com\"\n             */\n            protocolRelativeRegex : /^\\/\\//,\n\n            /**\n             * @private\n             * @property {Boolean} protocolPrepended\n             *\n             * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the\n             * {@link #url} did not have a protocol)\n             */\n            protocolPrepended : false,\n\n\n            /**\n             * Returns a string name for the type of match that this class represents.\n             *\n             * @return {String}\n             */\n            getType : function() {\n                return 'url';\n            },\n\n\n            /**\n             * Returns the url that was matched, assuming the protocol to be 'http://' if the original\n             * match was missing a protocol.\n             *\n             * @return {String}\n             */\n            getUrl : function() {\n                var url = this.url;\n\n                // if the url string doesn't begin with a protocol, assume 'http://'\n                if( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {\n                    url = this.url = 'http://' + url;\n\n                    this.protocolPrepended = true;\n                }\n\n                return url;\n            },\n\n\n            /**\n             * Returns the anchor href that should be generated for the match.\n             *\n             * @return {String}\n             */\n            getAnchorHref : function() {\n                var url = this.getUrl();\n\n                return url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html\n            },\n\n\n            /**\n             * Returns the anchor text that should be generated for the match.\n             *\n             * @return {String}\n             */\n            getAnchorText : function() {\n                var anchorText = this.getUrl();\n\n                if( this.protocolRelativeMatch ) {\n                    // Strip off any protocol-relative '//' from the anchor text\n                    anchorText = this.stripProtocolRelativePrefix( anchorText );\n                }\n                if( this.stripPrefix ) {\n                    anchorText = this.stripUrlPrefix( anchorText );\n                }\n                anchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one\n\n                return anchorText;\n            },\n\n\n            // ---------------------------------------\n\n            // Utility Functionality\n\n            /**\n             * Strips the URL prefix (such as \"http://\" or \"https://\") from the given text.\n             *\n             * @private\n             * @param {String} text The text of the anchor that is being generated, for which to strip off the\n             *   url prefix (such as stripping off \"http://\")\n             * @return {String} The `anchorText`, with the prefix stripped.\n             */\n            stripUrlPrefix : function( text ) {\n                return text.replace( this.urlPrefixRegex, '' );\n            },\n\n\n            /**\n             * Strips any protocol-relative '//' from the anchor text.\n             *\n             * @private\n             * @param {String} text The text of the anchor that is being generated, for which to strip off the\n             *   protocol-relative prefix (such as stripping off \"//\")\n             * @return {String} The `anchorText`, with the protocol-relative prefix stripped.\n             */\n            stripProtocolRelativePrefix : function( text ) {\n                return text.replace( this.protocolRelativeRegex, '' );\n            },\n\n\n            /**\n             * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.\n             *\n             * @private\n             * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing\n             *   slash ('/') that may exist.\n             * @return {String} The `anchorText`, with the trailing slash removed.\n             */\n            removeTrailingSlash : function( anchorText ) {\n                if( anchorText.charAt( anchorText.length - 1 ) === '/' ) {\n                    anchorText = anchorText.slice( 0, -1 );\n                }\n                return anchorText;\n            }\n\n        } );\n        return Autolinker;\n\n    }));\n\n},{}],\"/\":[function(require,module,exports){\n    'use strict';\n\n\n    module.exports = require('./lib/');\n\n},{\"./lib/\":14}]},{},[])(\"/\")\n});"],"file":"remarkable.js"}